
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model AreaOfWorks
 */

export type AreaOfWorks = {
  id: number
  project_proposal_id: number
  unit_location_id: number
  new_unit: string | null
  existing_unit: string | null
  unit_alias: string | null
  work_type: string | null
  created_at: Date
  updated_at: Date
  created_by: number | null
  updated_by: number | null
}

/**
 * Model Attributes
 */

export type Attributes = {
  id: number
  parent_id: number | null
  name: string | null
  slug: string | null
  created_at: Date
  updated_at: Date
  created_by: number | null
  updated_by: number | null
}

/**
 * Model AttributeUnits
 */

export type AttributeUnits = {
  id: number
  attribute_parent_id: number | null
  unit_name: string | null
  slug: string | null
  created_at: Date
  updated_at: Date
  created_by: number | null
  updated_by: number | null
}

/**
 * Model Backend_Users
 */

export type Backend_Users = {
  id: number
  user_id: number
  first_name: string | null
  last_name: string | null
  created_at: Date
  updated_at: Date
  created_by: number | null
  updated_by: number | null
}

/**
 * Model Cities
 */

export type Cities = {
  id: number
  state_id: number
  name: string
  status: boolean
  created_at: Date
  updated_at: Date
  created_by: number | null
  updated_by: number | null
}

/**
 * Model Contractors
 */

export type Contractors = {
  id: number
  user_id: number
  first_name: string | null
  last_name: string | null
  mobile: string | null
  company_name: string | null
  created_at: Date
  updated_at: Date
  created_by: number | null
  updated_by: number | null
}

/**
 * Model Countries
 */

export type Countries = {
  id: number
  country_name: string
  country_code: string
  iso3: string | null
  phone_code: string | null
  status: boolean
  created_at: Date
  updated_at: Date
  created_by: number | null
  updated_by: number | null
}

/**
 * Model ProductAttributeUnits
 */

export type ProductAttributeUnits = {
  id: number
  name: string | null
  product_id: number
  attribute_id: number
  attribute_unit_id: number
  html_element_type: string | null
  display_order: number | null
  created_at: Date
  updated_at: Date
  created_by: number | null
  updated_by: number | null
}

/**
 * Model ProductAttributeUnitValues
 */

export type ProductAttributeUnitValues = {
  id: number
  value: string | null
  slug: string | null
  product_attribute_unit_id: number
  custom: boolean
  custom_html_element_type: string | null
  is_default: boolean
  created_at: Date
  updated_at: Date
  created_by: number | null
  updated_by: number | null
}

/**
 * Model ProductCategories
 */

export type ProductCategories = {
  id: number
  name: string | null
  slug: string | null
  created_at: Date
  updated_at: Date
  created_by: number | null
  updated_by: number | null
}

/**
 * Model ProductPropertyUnits
 */

export type ProductPropertyUnits = {
  id: number
  property_unit_id: number
  product_id: number
  created_at: Date
  updated_at: Date
  created_by: number | null
  updated_by: number | null
}

/**
 * Model Products
 */

export type Products = {
  id: number
  parent_id: number | null
  name: string | null
  slug: string | null
  created_at: Date
  updated_at: Date
  created_by: number | null
  updated_by: number | null
}

/**
 * Model ProjectProposals
 */

export type ProjectProposals = {
  id: number
  name: string | null
  project_id: number
  proposal_status: string | null
  created_at: Date
  updated_at: Date
  created_by: number | null
  updated_by: number | null
}

/**
 * Model Projects
 */

export type Projects = {
  id: number
  name: string | null
  property_address_id: number
  created_at: Date
  updated_at: Date
  created_by: number | null
  updated_by: number | null
  start_date: Date
}

/**
 * Model ProjectTypeAssociations
 */

export type ProjectTypeAssociations = {
  id: number
  project_id: number
  project_type_id: number
  created_at: Date
  updated_at: Date
  created_by: number | null
  updated_by: number | null
}

/**
 * Model ProjectTypes
 */

export type ProjectTypes = {
  id: number
  type: string
  slug: string
  created_at: Date
  updated_at: Date
  created_by: number | null
  updated_by: number | null
}

/**
 * Model PropertyLevels
 */

export type PropertyLevels = {
  id: number
  name: string
  slug: string
  created_at: Date
  updated_at: Date
  created_by: number | null
  updated_by: number | null
}

/**
 * Model PropertyOwners
 */

export type PropertyOwners = {
  id: number
  user_id: number
  first_name: string | null
  last_name: string | null
  mobile: string | null
  created_at: Date
  updated_at: Date
  created_by: number | null
  updated_by: number | null
}

/**
 * Model PropertySubTypes
 */

export type PropertySubTypes = {
  id: number
  property_type_id: number
  name: string
  slug: string
  created_at: Date
  updated_at: Date
  created_by: number | null
  updated_by: number | null
}

/**
 * Model PropertyUnitAttributes
 */

export type PropertyUnitAttributes = {
  id: number
  property_unit_id: number
  attribute_id: number
  attribute_unit_id: number
  html_element_type: string | null
  display_order: number | null
  created_at: Date
  updated_at: Date
  created_by: number | null
  updated_by: number | null
}

/**
 * Model PropertyUnitProductCategories
 */

export type PropertyUnitProductCategories = {
  id: number
  property_unit_id: number
  product_category_id: number
  created_at: Date
  updated_at: Date
  created_by: number | null
  updated_by: number | null
}

/**
 * Model PropertyUnitProductCategoryProducts
 */

export type PropertyUnitProductCategoryProducts = {
  id: number
  property_unit_product_category_id: number
  product_id: number
  display_order: number | null
  created_at: Date
  updated_at: Date
  created_by: number | null
  updated_by: number | null
}

/**
 * Model PropertyUnits
 */

export type PropertyUnits = {
  id: number
  name: string | null
  slug: string | null
  created_at: Date
  updated_at: Date
  created_by: number | null
  updated_by: number | null
}

/**
 * Model Property_Addresses
 */

export type Property_Addresses = {
  id: number
  street: string | null
  property_owner_id: number
  city_id: number
  property_sub_type_id: number
  postal_code: string | null
  construction_type: string | null
  withBasement: boolean
  storyId: number | null
  created_at: Date
  updated_at: Date
  created_by: number | null
  updated_by: number | null
}

/**
 * Model Property_Types
 */

export type Property_Types = {
  id: number
  name: string
  slug: string
  created_at: Date
  updated_at: Date
  created_by: number | null
  updated_by: number | null
}

/**
 * Model ScopeOfWorkPropertyUnits
 */

export type ScopeOfWorkPropertyUnits = {
  id: number
  project_proposal_id: number
  area_of_work_id: number
  property_unit_attribute_id: number
  value: string | null
  attribute_custom_name: string | null
  attribute_custom_value: string | null
  attribute_custom_unit: string | null
  created_at: Date
  updated_at: Date
  created_by: number | null
  updated_by: number | null
}

/**
 * Model ScopeOfWorks
 */

export type ScopeOfWorks = {
  id: number
  project_proposal_id: number
  area_of_work_id: number
  product_attribute_unit_id: number
  product_attribute_unit_value_id: number
  attribute_custom_name: string | null
  attribute_custom_value: string | null
  attribute_custom_unit: string | null
  created_at: Date
  updated_at: Date
  created_by: number | null
  updated_by: number | null
}

/**
 * Model SequelizeMeta
 */

export type SequelizeMeta = {
  name: string
}

/**
 * Model States
 */

export type States = {
  id: number
  country_id: number
  name: string | null
  state_code: string
  status: boolean
  created_at: Date
  updated_at: Date
  created_by: number | null
  updated_by: number | null
}

/**
 * Model UnitLocations
 */

export type UnitLocations = {
  id: number
  unit_name: string | null
  property_sub_type_id: number
  property_level_id: number
  property_unit_id: number
  created_at: Date
  updated_at: Date
  created_by: number | null
  updated_by: number | null
}

/**
 * Model Users
 */

export type Users = {
  id: number
  user_type: string
  email: string
  status: boolean
  created_at: Date
  updated_at: Date
  created_by: number | null
  updated_by: number | null
  username: string | null
  email_verified: boolean
  name: string | null
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js (ORM replacement)
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more AreaOfWorks
 * const areaOfWorks = await prisma.areaOfWorks.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js (ORM replacement)
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more AreaOfWorks
   * const areaOfWorks = await prisma.areaOfWorks.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<any>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

  /**
   * Executes a raw query and returns the number of affected rows
   * @example
   * ```
   * // With parameters use prisma.executeRaw``, values will be escaped automatically
   * const result = await prisma.executeRaw`UPDATE User SET cool = ${true} WHERE id = ${1};`
   * // Or
   * const result = await prisma.executeRaw('UPDATE User SET cool = $1 WHERE id = $2 ;', true, 1)
  * ```
  * 
  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
  */
  $executeRaw < T = any > (query: string | TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a raw query and returns the SELECT data
   * @example
   * ```
   * // With parameters use prisma.queryRaw``, values will be escaped automatically
   * const result = await prisma.queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'ema.il'};`
   * // Or
   * const result = await prisma.queryRaw('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'ema.il')
  * ```
  * 
  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
  */
  $queryRaw < T = any > (query: string | TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P]): Promise<UnwrapTuple<P>>

      /**
   * `prisma.areaOfWorks`: Exposes CRUD operations for the **AreaOfWorks** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AreaOfWorks
    * const areaOfWorks = await prisma.areaOfWorks.findMany()
    * ```
    */
  get areaOfWorks(): Prisma.AreaOfWorksDelegate<GlobalReject>;

  /**
   * `prisma.attributes`: Exposes CRUD operations for the **Attributes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Attributes
    * const attributes = await prisma.attributes.findMany()
    * ```
    */
  get attributes(): Prisma.AttributesDelegate<GlobalReject>;

  /**
   * `prisma.attributeUnits`: Exposes CRUD operations for the **AttributeUnits** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AttributeUnits
    * const attributeUnits = await prisma.attributeUnits.findMany()
    * ```
    */
  get attributeUnits(): Prisma.AttributeUnitsDelegate<GlobalReject>;

  /**
   * `prisma.backend_Users`: Exposes CRUD operations for the **Backend_Users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Backend_Users
    * const backend_Users = await prisma.backend_Users.findMany()
    * ```
    */
  get backend_Users(): Prisma.Backend_UsersDelegate<GlobalReject>;

  /**
   * `prisma.cities`: Exposes CRUD operations for the **Cities** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cities
    * const cities = await prisma.cities.findMany()
    * ```
    */
  get cities(): Prisma.CitiesDelegate<GlobalReject>;

  /**
   * `prisma.contractors`: Exposes CRUD operations for the **Contractors** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contractors
    * const contractors = await prisma.contractors.findMany()
    * ```
    */
  get contractors(): Prisma.ContractorsDelegate<GlobalReject>;

  /**
   * `prisma.countries`: Exposes CRUD operations for the **Countries** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Countries
    * const countries = await prisma.countries.findMany()
    * ```
    */
  get countries(): Prisma.CountriesDelegate<GlobalReject>;

  /**
   * `prisma.productAttributeUnits`: Exposes CRUD operations for the **ProductAttributeUnits** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductAttributeUnits
    * const productAttributeUnits = await prisma.productAttributeUnits.findMany()
    * ```
    */
  get productAttributeUnits(): Prisma.ProductAttributeUnitsDelegate<GlobalReject>;

  /**
   * `prisma.productAttributeUnitValues`: Exposes CRUD operations for the **ProductAttributeUnitValues** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductAttributeUnitValues
    * const productAttributeUnitValues = await prisma.productAttributeUnitValues.findMany()
    * ```
    */
  get productAttributeUnitValues(): Prisma.ProductAttributeUnitValuesDelegate<GlobalReject>;

  /**
   * `prisma.productCategories`: Exposes CRUD operations for the **ProductCategories** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductCategories
    * const productCategories = await prisma.productCategories.findMany()
    * ```
    */
  get productCategories(): Prisma.ProductCategoriesDelegate<GlobalReject>;

  /**
   * `prisma.productPropertyUnits`: Exposes CRUD operations for the **ProductPropertyUnits** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductPropertyUnits
    * const productPropertyUnits = await prisma.productPropertyUnits.findMany()
    * ```
    */
  get productPropertyUnits(): Prisma.ProductPropertyUnitsDelegate<GlobalReject>;

  /**
   * `prisma.products`: Exposes CRUD operations for the **Products** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.products.findMany()
    * ```
    */
  get products(): Prisma.ProductsDelegate<GlobalReject>;

  /**
   * `prisma.projectProposals`: Exposes CRUD operations for the **ProjectProposals** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectProposals
    * const projectProposals = await prisma.projectProposals.findMany()
    * ```
    */
  get projectProposals(): Prisma.ProjectProposalsDelegate<GlobalReject>;

  /**
   * `prisma.projects`: Exposes CRUD operations for the **Projects** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projects
    * const projects = await prisma.projects.findMany()
    * ```
    */
  get projects(): Prisma.ProjectsDelegate<GlobalReject>;

  /**
   * `prisma.projectTypeAssociations`: Exposes CRUD operations for the **ProjectTypeAssociations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectTypeAssociations
    * const projectTypeAssociations = await prisma.projectTypeAssociations.findMany()
    * ```
    */
  get projectTypeAssociations(): Prisma.ProjectTypeAssociationsDelegate<GlobalReject>;

  /**
   * `prisma.projectTypes`: Exposes CRUD operations for the **ProjectTypes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectTypes
    * const projectTypes = await prisma.projectTypes.findMany()
    * ```
    */
  get projectTypes(): Prisma.ProjectTypesDelegate<GlobalReject>;

  /**
   * `prisma.propertyLevels`: Exposes CRUD operations for the **PropertyLevels** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PropertyLevels
    * const propertyLevels = await prisma.propertyLevels.findMany()
    * ```
    */
  get propertyLevels(): Prisma.PropertyLevelsDelegate<GlobalReject>;

  /**
   * `prisma.propertyOwners`: Exposes CRUD operations for the **PropertyOwners** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PropertyOwners
    * const propertyOwners = await prisma.propertyOwners.findMany()
    * ```
    */
  get propertyOwners(): Prisma.PropertyOwnersDelegate<GlobalReject>;

  /**
   * `prisma.propertySubTypes`: Exposes CRUD operations for the **PropertySubTypes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PropertySubTypes
    * const propertySubTypes = await prisma.propertySubTypes.findMany()
    * ```
    */
  get propertySubTypes(): Prisma.PropertySubTypesDelegate<GlobalReject>;

  /**
   * `prisma.propertyUnitAttributes`: Exposes CRUD operations for the **PropertyUnitAttributes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PropertyUnitAttributes
    * const propertyUnitAttributes = await prisma.propertyUnitAttributes.findMany()
    * ```
    */
  get propertyUnitAttributes(): Prisma.PropertyUnitAttributesDelegate<GlobalReject>;

  /**
   * `prisma.propertyUnitProductCategories`: Exposes CRUD operations for the **PropertyUnitProductCategories** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PropertyUnitProductCategories
    * const propertyUnitProductCategories = await prisma.propertyUnitProductCategories.findMany()
    * ```
    */
  get propertyUnitProductCategories(): Prisma.PropertyUnitProductCategoriesDelegate<GlobalReject>;

  /**
   * `prisma.propertyUnitProductCategoryProducts`: Exposes CRUD operations for the **PropertyUnitProductCategoryProducts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PropertyUnitProductCategoryProducts
    * const propertyUnitProductCategoryProducts = await prisma.propertyUnitProductCategoryProducts.findMany()
    * ```
    */
  get propertyUnitProductCategoryProducts(): Prisma.PropertyUnitProductCategoryProductsDelegate<GlobalReject>;

  /**
   * `prisma.propertyUnits`: Exposes CRUD operations for the **PropertyUnits** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PropertyUnits
    * const propertyUnits = await prisma.propertyUnits.findMany()
    * ```
    */
  get propertyUnits(): Prisma.PropertyUnitsDelegate<GlobalReject>;

  /**
   * `prisma.property_Addresses`: Exposes CRUD operations for the **Property_Addresses** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Property_Addresses
    * const property_Addresses = await prisma.property_Addresses.findMany()
    * ```
    */
  get property_Addresses(): Prisma.Property_AddressesDelegate<GlobalReject>;

  /**
   * `prisma.property_Types`: Exposes CRUD operations for the **Property_Types** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Property_Types
    * const property_Types = await prisma.property_Types.findMany()
    * ```
    */
  get property_Types(): Prisma.Property_TypesDelegate<GlobalReject>;

  /**
   * `prisma.scopeOfWorkPropertyUnits`: Exposes CRUD operations for the **ScopeOfWorkPropertyUnits** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ScopeOfWorkPropertyUnits
    * const scopeOfWorkPropertyUnits = await prisma.scopeOfWorkPropertyUnits.findMany()
    * ```
    */
  get scopeOfWorkPropertyUnits(): Prisma.ScopeOfWorkPropertyUnitsDelegate<GlobalReject>;

  /**
   * `prisma.scopeOfWorks`: Exposes CRUD operations for the **ScopeOfWorks** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ScopeOfWorks
    * const scopeOfWorks = await prisma.scopeOfWorks.findMany()
    * ```
    */
  get scopeOfWorks(): Prisma.ScopeOfWorksDelegate<GlobalReject>;

  /**
   * `prisma.sequelizeMeta`: Exposes CRUD operations for the **SequelizeMeta** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SequelizeMetas
    * const sequelizeMetas = await prisma.sequelizeMeta.findMany()
    * ```
    */
  get sequelizeMeta(): Prisma.SequelizeMetaDelegate<GlobalReject>;

  /**
   * `prisma.states`: Exposes CRUD operations for the **States** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more States
    * const states = await prisma.states.findMany()
    * ```
    */
  get states(): Prisma.StatesDelegate<GlobalReject>;

  /**
   * `prisma.unitLocations`: Exposes CRUD operations for the **UnitLocations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UnitLocations
    * const unitLocations = await prisma.unitLocations.findMany()
    * ```
    */
  get unitLocations(): Prisma.UnitLocationsDelegate<GlobalReject>;

  /**
   * `prisma.users`: Exposes CRUD operations for the **Users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.UsersDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  /**
   * Prisma Client JS version: 2.18.0
   * Query Engine version: da6fafb57b24e0b61ca20960c64e2d41f9e8cff1
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}
 
  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}
 
  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | null | JsonObject | JsonArray

  /**
   * Same as JsonObject, but allows undefined
   */
  export type InputJsonObject = {[Key in string]?: JsonValue}
 
  export interface InputJsonArray extends Array<JsonValue> {}
 
  export type InputJsonValue = undefined |  string | number | boolean | null | InputJsonObject | InputJsonArray
   type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> = (T | U) extends object ? (Without<T, U> & U) | (Without<U, T> & T) : T | U;


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Buffer
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  export type Union = any

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, 'avg' | 'sum' | 'count' | 'min' | 'max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    AreaOfWorks: 'AreaOfWorks',
    Attributes: 'Attributes',
    AttributeUnits: 'AttributeUnits',
    Backend_Users: 'Backend_Users',
    Cities: 'Cities',
    Contractors: 'Contractors',
    Countries: 'Countries',
    ProductAttributeUnits: 'ProductAttributeUnits',
    ProductAttributeUnitValues: 'ProductAttributeUnitValues',
    ProductCategories: 'ProductCategories',
    ProductPropertyUnits: 'ProductPropertyUnits',
    Products: 'Products',
    ProjectProposals: 'ProjectProposals',
    Projects: 'Projects',
    ProjectTypeAssociations: 'ProjectTypeAssociations',
    ProjectTypes: 'ProjectTypes',
    PropertyLevels: 'PropertyLevels',
    PropertyOwners: 'PropertyOwners',
    PropertySubTypes: 'PropertySubTypes',
    PropertyUnitAttributes: 'PropertyUnitAttributes',
    PropertyUnitProductCategories: 'PropertyUnitProductCategories',
    PropertyUnitProductCategoryProducts: 'PropertyUnitProductCategoryProducts',
    PropertyUnits: 'PropertyUnits',
    Property_Addresses: 'Property_Addresses',
    Property_Types: 'Property_Types',
    ScopeOfWorkPropertyUnits: 'ScopeOfWorkPropertyUnits',
    ScopeOfWorks: 'ScopeOfWorks',
    SequelizeMeta: 'SequelizeMeta',
    States: 'States',
    UnitLocations: 'UnitLocations',
    Users: 'Users'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends boolean
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     *  * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your prisma.schema file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'

  /**
   * These options are being passed in to the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined; 
  export type Datasource = {
    url?: string
  }


  /**
   * Model AreaOfWorks
   */


  export type AggregateAreaOfWorks = {
    count: AreaOfWorksCountAggregateOutputType | null
    avg: AreaOfWorksAvgAggregateOutputType | null
    sum: AreaOfWorksSumAggregateOutputType | null
    min: AreaOfWorksMinAggregateOutputType | null
    max: AreaOfWorksMaxAggregateOutputType | null
  }

  export type AreaOfWorksAvgAggregateOutputType = {
    id: number
    project_proposal_id: number
    unit_location_id: number
    created_by: number | null
    updated_by: number | null
  }

  export type AreaOfWorksSumAggregateOutputType = {
    id: number
    project_proposal_id: number
    unit_location_id: number
    created_by: number | null
    updated_by: number | null
  }

  export type AreaOfWorksMinAggregateOutputType = {
    id: number
    project_proposal_id: number
    unit_location_id: number
    new_unit: string | null
    existing_unit: string | null
    unit_alias: string | null
    work_type: string | null
    created_at: Date | null
    updated_at: Date | null
    created_by: number | null
    updated_by: number | null
  }

  export type AreaOfWorksMaxAggregateOutputType = {
    id: number
    project_proposal_id: number
    unit_location_id: number
    new_unit: string | null
    existing_unit: string | null
    unit_alias: string | null
    work_type: string | null
    created_at: Date | null
    updated_at: Date | null
    created_by: number | null
    updated_by: number | null
  }

  export type AreaOfWorksCountAggregateOutputType = {
    id: number
    project_proposal_id: number
    unit_location_id: number
    new_unit: number | null
    existing_unit: number | null
    unit_alias: number | null
    work_type: number | null
    created_at: number | null
    updated_at: number | null
    created_by: number | null
    updated_by: number | null
    _all: number
  }


  export type AreaOfWorksAvgAggregateInputType = {
    id?: true
    project_proposal_id?: true
    unit_location_id?: true
    created_by?: true
    updated_by?: true
  }

  export type AreaOfWorksSumAggregateInputType = {
    id?: true
    project_proposal_id?: true
    unit_location_id?: true
    created_by?: true
    updated_by?: true
  }

  export type AreaOfWorksMinAggregateInputType = {
    id?: true
    project_proposal_id?: true
    unit_location_id?: true
    new_unit?: true
    existing_unit?: true
    unit_alias?: true
    work_type?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type AreaOfWorksMaxAggregateInputType = {
    id?: true
    project_proposal_id?: true
    unit_location_id?: true
    new_unit?: true
    existing_unit?: true
    unit_alias?: true
    work_type?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type AreaOfWorksCountAggregateInputType = {
    id?: true
    project_proposal_id?: true
    unit_location_id?: true
    new_unit?: true
    existing_unit?: true
    unit_alias?: true
    work_type?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
    _all?: true
  }

  export type AreaOfWorksAggregateArgs = {
    /**
     * Filter which AreaOfWorks to aggregate.
    **/
    where?: AreaOfWorksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AreaOfWorks to fetch.
    **/
    orderBy?: Enumerable<AreaOfWorksOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: AreaOfWorksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AreaOfWorks from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AreaOfWorks.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AreaOfWorks
    **/
    count?: true | AreaOfWorksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: AreaOfWorksAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: AreaOfWorksSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: AreaOfWorksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: AreaOfWorksMaxAggregateInputType
  }

  export type GetAreaOfWorksAggregateType<T extends AreaOfWorksAggregateArgs> = {
    [P in keyof T & keyof AggregateAreaOfWorks]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAreaOfWorks[P]>
      : GetScalarType<T[P], AggregateAreaOfWorks[P]>
  }



  export type AreaOfWorksSelect = {
    id?: boolean
    project_proposal_id?: boolean
    unit_location_id?: boolean
    new_unit?: boolean
    existing_unit?: boolean
    unit_alias?: boolean
    work_type?: boolean
    created_at?: boolean
    updated_at?: boolean
    created_by?: boolean
    updated_by?: boolean
    ProjectProposals?: boolean | ProjectProposalsArgs
    UnitLocations?: boolean | UnitLocationsArgs
    ScopeOfWorkPropertyUnits?: boolean | ScopeOfWorkPropertyUnitsFindManyArgs
    ScopeOfWorks?: boolean | ScopeOfWorksFindManyArgs
  }

  export type AreaOfWorksInclude = {
    ProjectProposals?: boolean | ProjectProposalsArgs
    UnitLocations?: boolean | UnitLocationsArgs
    ScopeOfWorkPropertyUnits?: boolean | ScopeOfWorkPropertyUnitsFindManyArgs
    ScopeOfWorks?: boolean | ScopeOfWorksFindManyArgs
  }

  export type AreaOfWorksGetPayload<
    S extends boolean | null | undefined | AreaOfWorksArgs,
    U = keyof S
      > = S extends true
        ? AreaOfWorks
    : S extends undefined
    ? never
    : S extends AreaOfWorksArgs | AreaOfWorksFindManyArgs
    ?'include' extends U
    ? AreaOfWorks  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'ProjectProposals'
        ? ProjectProposalsGetPayload<S['include'][P]> :
        P extends 'UnitLocations'
        ? UnitLocationsGetPayload<S['include'][P]> :
        P extends 'ScopeOfWorkPropertyUnits'
        ? Array < ScopeOfWorkPropertyUnitsGetPayload<S['include'][P]>>  :
        P extends 'ScopeOfWorks'
        ? Array < ScopeOfWorksGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof AreaOfWorks ?AreaOfWorks [P]
  : 
          P extends 'ProjectProposals'
        ? ProjectProposalsGetPayload<S['select'][P]> :
        P extends 'UnitLocations'
        ? UnitLocationsGetPayload<S['select'][P]> :
        P extends 'ScopeOfWorkPropertyUnits'
        ? Array < ScopeOfWorkPropertyUnitsGetPayload<S['select'][P]>>  :
        P extends 'ScopeOfWorks'
        ? Array < ScopeOfWorksGetPayload<S['select'][P]>>  : never
  } 
    : AreaOfWorks
  : AreaOfWorks


  type AreaOfWorksCountArgs = Merge<
    Omit<AreaOfWorksFindManyArgs, 'select' | 'include'> & {
      select?: AreaOfWorksCountAggregateInputType | true
    }
  >

  export interface AreaOfWorksDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one AreaOfWorks that matches the filter.
     * @param {AreaOfWorksFindUniqueArgs} args - Arguments to find a AreaOfWorks
     * @example
     * // Get one AreaOfWorks
     * const areaOfWorks = await prisma.areaOfWorks.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AreaOfWorksFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AreaOfWorksFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'AreaOfWorks'> extends True ? CheckSelect<T, Prisma__AreaOfWorksClient<AreaOfWorks>, Prisma__AreaOfWorksClient<AreaOfWorksGetPayload<T>>> : CheckSelect<T, Prisma__AreaOfWorksClient<AreaOfWorks | null >, Prisma__AreaOfWorksClient<AreaOfWorksGetPayload<T> | null >>

    /**
     * Find the first AreaOfWorks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaOfWorksFindFirstArgs} args - Arguments to find a AreaOfWorks
     * @example
     * // Get one AreaOfWorks
     * const areaOfWorks = await prisma.areaOfWorks.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AreaOfWorksFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AreaOfWorksFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'AreaOfWorks'> extends True ? CheckSelect<T, Prisma__AreaOfWorksClient<AreaOfWorks>, Prisma__AreaOfWorksClient<AreaOfWorksGetPayload<T>>> : CheckSelect<T, Prisma__AreaOfWorksClient<AreaOfWorks | null >, Prisma__AreaOfWorksClient<AreaOfWorksGetPayload<T> | null >>

    /**
     * Find zero or more AreaOfWorks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaOfWorksFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AreaOfWorks
     * const areaOfWorks = await prisma.areaOfWorks.findMany()
     * 
     * // Get first 10 AreaOfWorks
     * const areaOfWorks = await prisma.areaOfWorks.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const areaOfWorksWithIdOnly = await prisma.areaOfWorks.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AreaOfWorksFindManyArgs>(
      args?: SelectSubset<T, AreaOfWorksFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<AreaOfWorks>>, PrismaPromise<Array<AreaOfWorksGetPayload<T>>>>

    /**
     * Create a AreaOfWorks.
     * @param {AreaOfWorksCreateArgs} args - Arguments to create a AreaOfWorks.
     * @example
     * // Create one AreaOfWorks
     * const AreaOfWorks = await prisma.areaOfWorks.create({
     *   data: {
     *     // ... data to create a AreaOfWorks
     *   }
     * })
     * 
    **/
    create<T extends AreaOfWorksCreateArgs>(
      args: SelectSubset<T, AreaOfWorksCreateArgs>
    ): CheckSelect<T, Prisma__AreaOfWorksClient<AreaOfWorks>, Prisma__AreaOfWorksClient<AreaOfWorksGetPayload<T>>>

    /**
     * Delete a AreaOfWorks.
     * @param {AreaOfWorksDeleteArgs} args - Arguments to delete one AreaOfWorks.
     * @example
     * // Delete one AreaOfWorks
     * const AreaOfWorks = await prisma.areaOfWorks.delete({
     *   where: {
     *     // ... filter to delete one AreaOfWorks
     *   }
     * })
     * 
    **/
    delete<T extends AreaOfWorksDeleteArgs>(
      args: SelectSubset<T, AreaOfWorksDeleteArgs>
    ): CheckSelect<T, Prisma__AreaOfWorksClient<AreaOfWorks>, Prisma__AreaOfWorksClient<AreaOfWorksGetPayload<T>>>

    /**
     * Update one AreaOfWorks.
     * @param {AreaOfWorksUpdateArgs} args - Arguments to update one AreaOfWorks.
     * @example
     * // Update one AreaOfWorks
     * const areaOfWorks = await prisma.areaOfWorks.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AreaOfWorksUpdateArgs>(
      args: SelectSubset<T, AreaOfWorksUpdateArgs>
    ): CheckSelect<T, Prisma__AreaOfWorksClient<AreaOfWorks>, Prisma__AreaOfWorksClient<AreaOfWorksGetPayload<T>>>

    /**
     * Delete zero or more AreaOfWorks.
     * @param {AreaOfWorksDeleteManyArgs} args - Arguments to filter AreaOfWorks to delete.
     * @example
     * // Delete a few AreaOfWorks
     * const { count } = await prisma.areaOfWorks.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AreaOfWorksDeleteManyArgs>(
      args?: SelectSubset<T, AreaOfWorksDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more AreaOfWorks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaOfWorksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AreaOfWorks
     * const areaOfWorks = await prisma.areaOfWorks.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AreaOfWorksUpdateManyArgs>(
      args: SelectSubset<T, AreaOfWorksUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one AreaOfWorks.
     * @param {AreaOfWorksUpsertArgs} args - Arguments to update or create a AreaOfWorks.
     * @example
     * // Update or create a AreaOfWorks
     * const areaOfWorks = await prisma.areaOfWorks.upsert({
     *   create: {
     *     // ... data to create a AreaOfWorks
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AreaOfWorks we want to update
     *   }
     * })
    **/
    upsert<T extends AreaOfWorksUpsertArgs>(
      args: SelectSubset<T, AreaOfWorksUpsertArgs>
    ): CheckSelect<T, Prisma__AreaOfWorksClient<AreaOfWorks>, Prisma__AreaOfWorksClient<AreaOfWorksGetPayload<T>>>

    /**
     * Count the number of AreaOfWorks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaOfWorksCountArgs} args - Arguments to filter AreaOfWorks to count.
     * @example
     * // Count the number of AreaOfWorks
     * const count = await prisma.areaOfWorks.count({
     *   where: {
     *     // ... the filter for the AreaOfWorks we want to count
     *   }
     * })
    **/
    count<T extends AreaOfWorksCountArgs>(
      args?: Subset<T, AreaOfWorksCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AreaOfWorksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AreaOfWorks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaOfWorksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AreaOfWorksAggregateArgs>(args: Subset<T, AreaOfWorksAggregateArgs>): PrismaPromise<GetAreaOfWorksAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for AreaOfWorks.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AreaOfWorksClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    ProjectProposals<T extends ProjectProposalsArgs = {}>(args?: Subset<T, ProjectProposalsArgs>): CheckSelect<T, Prisma__ProjectProposalsClient<ProjectProposals | null >, Prisma__ProjectProposalsClient<ProjectProposalsGetPayload<T> | null >>;

    UnitLocations<T extends UnitLocationsArgs = {}>(args?: Subset<T, UnitLocationsArgs>): CheckSelect<T, Prisma__UnitLocationsClient<UnitLocations | null >, Prisma__UnitLocationsClient<UnitLocationsGetPayload<T> | null >>;

    ScopeOfWorkPropertyUnits<T extends ScopeOfWorkPropertyUnitsFindManyArgs = {}>(args?: Subset<T, ScopeOfWorkPropertyUnitsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ScopeOfWorkPropertyUnits>>, PrismaPromise<Array<ScopeOfWorkPropertyUnitsGetPayload<T>>>>;

    ScopeOfWorks<T extends ScopeOfWorksFindManyArgs = {}>(args?: Subset<T, ScopeOfWorksFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ScopeOfWorks>>, PrismaPromise<Array<ScopeOfWorksGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * AreaOfWorks findUnique
   */
  export type AreaOfWorksFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the AreaOfWorks
    **/
    select?: AreaOfWorksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AreaOfWorksInclude | null
    /**
     * Throw an Error if a AreaOfWorks can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which AreaOfWorks to fetch.
    **/
    where: AreaOfWorksWhereUniqueInput
  }


  /**
   * AreaOfWorks findFirst
   */
  export type AreaOfWorksFindFirstArgs = {
    /**
     * Select specific fields to fetch from the AreaOfWorks
    **/
    select?: AreaOfWorksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AreaOfWorksInclude | null
    /**
     * Throw an Error if a AreaOfWorks can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which AreaOfWorks to fetch.
    **/
    where?: AreaOfWorksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AreaOfWorks to fetch.
    **/
    orderBy?: Enumerable<AreaOfWorksOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AreaOfWorks.
    **/
    cursor?: AreaOfWorksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AreaOfWorks from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AreaOfWorks.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AreaOfWorks.
    **/
    distinct?: Enumerable<AreaOfWorksScalarFieldEnum>
  }


  /**
   * AreaOfWorks findMany
   */
  export type AreaOfWorksFindManyArgs = {
    /**
     * Select specific fields to fetch from the AreaOfWorks
    **/
    select?: AreaOfWorksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AreaOfWorksInclude | null
    /**
     * Filter, which AreaOfWorks to fetch.
    **/
    where?: AreaOfWorksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AreaOfWorks to fetch.
    **/
    orderBy?: Enumerable<AreaOfWorksOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AreaOfWorks.
    **/
    cursor?: AreaOfWorksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AreaOfWorks from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AreaOfWorks.
    **/
    skip?: number
    distinct?: Enumerable<AreaOfWorksScalarFieldEnum>
  }


  /**
   * AreaOfWorks create
   */
  export type AreaOfWorksCreateArgs = {
    /**
     * Select specific fields to fetch from the AreaOfWorks
    **/
    select?: AreaOfWorksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AreaOfWorksInclude | null
    /**
     * The data needed to create a AreaOfWorks.
    **/
    data: XOR<AreaOfWorksCreateInput, AreaOfWorksUncheckedCreateInput>
  }


  /**
   * AreaOfWorks update
   */
  export type AreaOfWorksUpdateArgs = {
    /**
     * Select specific fields to fetch from the AreaOfWorks
    **/
    select?: AreaOfWorksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AreaOfWorksInclude | null
    /**
     * The data needed to update a AreaOfWorks.
    **/
    data: XOR<AreaOfWorksUpdateInput, AreaOfWorksUncheckedUpdateInput>
    /**
     * Choose, which AreaOfWorks to update.
    **/
    where: AreaOfWorksWhereUniqueInput
  }


  /**
   * AreaOfWorks updateMany
   */
  export type AreaOfWorksUpdateManyArgs = {
    data: XOR<AreaOfWorksUpdateManyMutationInput, AreaOfWorksUncheckedUpdateManyInput>
    where?: AreaOfWorksWhereInput
  }


  /**
   * AreaOfWorks upsert
   */
  export type AreaOfWorksUpsertArgs = {
    /**
     * Select specific fields to fetch from the AreaOfWorks
    **/
    select?: AreaOfWorksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AreaOfWorksInclude | null
    /**
     * The filter to search for the AreaOfWorks to update in case it exists.
    **/
    where: AreaOfWorksWhereUniqueInput
    /**
     * In case the AreaOfWorks found by the `where` argument doesn't exist, create a new AreaOfWorks with this data.
    **/
    create: XOR<AreaOfWorksCreateInput, AreaOfWorksUncheckedCreateInput>
    /**
     * In case the AreaOfWorks was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<AreaOfWorksUpdateInput, AreaOfWorksUncheckedUpdateInput>
  }


  /**
   * AreaOfWorks delete
   */
  export type AreaOfWorksDeleteArgs = {
    /**
     * Select specific fields to fetch from the AreaOfWorks
    **/
    select?: AreaOfWorksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AreaOfWorksInclude | null
    /**
     * Filter which AreaOfWorks to delete.
    **/
    where: AreaOfWorksWhereUniqueInput
  }


  /**
   * AreaOfWorks deleteMany
   */
  export type AreaOfWorksDeleteManyArgs = {
    where?: AreaOfWorksWhereInput
  }


  /**
   * AreaOfWorks without action
   */
  export type AreaOfWorksArgs = {
    /**
     * Select specific fields to fetch from the AreaOfWorks
    **/
    select?: AreaOfWorksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AreaOfWorksInclude | null
  }



  /**
   * Model Attributes
   */


  export type AggregateAttributes = {
    count: AttributesCountAggregateOutputType | null
    avg: AttributesAvgAggregateOutputType | null
    sum: AttributesSumAggregateOutputType | null
    min: AttributesMinAggregateOutputType | null
    max: AttributesMaxAggregateOutputType | null
  }

  export type AttributesAvgAggregateOutputType = {
    id: number
    parent_id: number | null
    created_by: number | null
    updated_by: number | null
  }

  export type AttributesSumAggregateOutputType = {
    id: number
    parent_id: number | null
    created_by: number | null
    updated_by: number | null
  }

  export type AttributesMinAggregateOutputType = {
    id: number
    parent_id: number | null
    name: string | null
    slug: string | null
    created_at: Date | null
    updated_at: Date | null
    created_by: number | null
    updated_by: number | null
  }

  export type AttributesMaxAggregateOutputType = {
    id: number
    parent_id: number | null
    name: string | null
    slug: string | null
    created_at: Date | null
    updated_at: Date | null
    created_by: number | null
    updated_by: number | null
  }

  export type AttributesCountAggregateOutputType = {
    id: number
    parent_id: number | null
    name: number | null
    slug: number | null
    created_at: number | null
    updated_at: number | null
    created_by: number | null
    updated_by: number | null
    _all: number
  }


  export type AttributesAvgAggregateInputType = {
    id?: true
    parent_id?: true
    created_by?: true
    updated_by?: true
  }

  export type AttributesSumAggregateInputType = {
    id?: true
    parent_id?: true
    created_by?: true
    updated_by?: true
  }

  export type AttributesMinAggregateInputType = {
    id?: true
    parent_id?: true
    name?: true
    slug?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type AttributesMaxAggregateInputType = {
    id?: true
    parent_id?: true
    name?: true
    slug?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type AttributesCountAggregateInputType = {
    id?: true
    parent_id?: true
    name?: true
    slug?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
    _all?: true
  }

  export type AttributesAggregateArgs = {
    /**
     * Filter which Attributes to aggregate.
    **/
    where?: AttributesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attributes to fetch.
    **/
    orderBy?: Enumerable<AttributesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: AttributesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attributes from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attributes.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Attributes
    **/
    count?: true | AttributesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: AttributesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: AttributesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: AttributesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: AttributesMaxAggregateInputType
  }

  export type GetAttributesAggregateType<T extends AttributesAggregateArgs> = {
    [P in keyof T & keyof AggregateAttributes]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttributes[P]>
      : GetScalarType<T[P], AggregateAttributes[P]>
  }



  export type AttributesSelect = {
    id?: boolean
    parent_id?: boolean
    name?: boolean
    slug?: boolean
    created_at?: boolean
    updated_at?: boolean
    created_by?: boolean
    updated_by?: boolean
    Attributes?: boolean | AttributesArgs
    other_Attributes?: boolean | AttributesFindManyArgs
    AttributeUnits?: boolean | AttributeUnitsFindManyArgs
    ProductAttributeUnits?: boolean | ProductAttributeUnitsFindManyArgs
    PropertyUnitAttributes?: boolean | PropertyUnitAttributesFindManyArgs
  }

  export type AttributesInclude = {
    Attributes?: boolean | AttributesArgs
    other_Attributes?: boolean | AttributesFindManyArgs
    AttributeUnits?: boolean | AttributeUnitsFindManyArgs
    ProductAttributeUnits?: boolean | ProductAttributeUnitsFindManyArgs
    PropertyUnitAttributes?: boolean | PropertyUnitAttributesFindManyArgs
  }

  export type AttributesGetPayload<
    S extends boolean | null | undefined | AttributesArgs,
    U = keyof S
      > = S extends true
        ? Attributes
    : S extends undefined
    ? never
    : S extends AttributesArgs | AttributesFindManyArgs
    ?'include' extends U
    ? Attributes  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'Attributes'
        ? AttributesGetPayload<S['include'][P]> | null :
        P extends 'other_Attributes'
        ? Array < AttributesGetPayload<S['include'][P]>>  :
        P extends 'AttributeUnits'
        ? Array < AttributeUnitsGetPayload<S['include'][P]>>  :
        P extends 'ProductAttributeUnits'
        ? Array < ProductAttributeUnitsGetPayload<S['include'][P]>>  :
        P extends 'PropertyUnitAttributes'
        ? Array < PropertyUnitAttributesGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Attributes ?Attributes [P]
  : 
          P extends 'Attributes'
        ? AttributesGetPayload<S['select'][P]> | null :
        P extends 'other_Attributes'
        ? Array < AttributesGetPayload<S['select'][P]>>  :
        P extends 'AttributeUnits'
        ? Array < AttributeUnitsGetPayload<S['select'][P]>>  :
        P extends 'ProductAttributeUnits'
        ? Array < ProductAttributeUnitsGetPayload<S['select'][P]>>  :
        P extends 'PropertyUnitAttributes'
        ? Array < PropertyUnitAttributesGetPayload<S['select'][P]>>  : never
  } 
    : Attributes
  : Attributes


  type AttributesCountArgs = Merge<
    Omit<AttributesFindManyArgs, 'select' | 'include'> & {
      select?: AttributesCountAggregateInputType | true
    }
  >

  export interface AttributesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Attributes that matches the filter.
     * @param {AttributesFindUniqueArgs} args - Arguments to find a Attributes
     * @example
     * // Get one Attributes
     * const attributes = await prisma.attributes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AttributesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AttributesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Attributes'> extends True ? CheckSelect<T, Prisma__AttributesClient<Attributes>, Prisma__AttributesClient<AttributesGetPayload<T>>> : CheckSelect<T, Prisma__AttributesClient<Attributes | null >, Prisma__AttributesClient<AttributesGetPayload<T> | null >>

    /**
     * Find the first Attributes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttributesFindFirstArgs} args - Arguments to find a Attributes
     * @example
     * // Get one Attributes
     * const attributes = await prisma.attributes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AttributesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AttributesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Attributes'> extends True ? CheckSelect<T, Prisma__AttributesClient<Attributes>, Prisma__AttributesClient<AttributesGetPayload<T>>> : CheckSelect<T, Prisma__AttributesClient<Attributes | null >, Prisma__AttributesClient<AttributesGetPayload<T> | null >>

    /**
     * Find zero or more Attributes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttributesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Attributes
     * const attributes = await prisma.attributes.findMany()
     * 
     * // Get first 10 Attributes
     * const attributes = await prisma.attributes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attributesWithIdOnly = await prisma.attributes.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AttributesFindManyArgs>(
      args?: SelectSubset<T, AttributesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Attributes>>, PrismaPromise<Array<AttributesGetPayload<T>>>>

    /**
     * Create a Attributes.
     * @param {AttributesCreateArgs} args - Arguments to create a Attributes.
     * @example
     * // Create one Attributes
     * const Attributes = await prisma.attributes.create({
     *   data: {
     *     // ... data to create a Attributes
     *   }
     * })
     * 
    **/
    create<T extends AttributesCreateArgs>(
      args: SelectSubset<T, AttributesCreateArgs>
    ): CheckSelect<T, Prisma__AttributesClient<Attributes>, Prisma__AttributesClient<AttributesGetPayload<T>>>

    /**
     * Delete a Attributes.
     * @param {AttributesDeleteArgs} args - Arguments to delete one Attributes.
     * @example
     * // Delete one Attributes
     * const Attributes = await prisma.attributes.delete({
     *   where: {
     *     // ... filter to delete one Attributes
     *   }
     * })
     * 
    **/
    delete<T extends AttributesDeleteArgs>(
      args: SelectSubset<T, AttributesDeleteArgs>
    ): CheckSelect<T, Prisma__AttributesClient<Attributes>, Prisma__AttributesClient<AttributesGetPayload<T>>>

    /**
     * Update one Attributes.
     * @param {AttributesUpdateArgs} args - Arguments to update one Attributes.
     * @example
     * // Update one Attributes
     * const attributes = await prisma.attributes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AttributesUpdateArgs>(
      args: SelectSubset<T, AttributesUpdateArgs>
    ): CheckSelect<T, Prisma__AttributesClient<Attributes>, Prisma__AttributesClient<AttributesGetPayload<T>>>

    /**
     * Delete zero or more Attributes.
     * @param {AttributesDeleteManyArgs} args - Arguments to filter Attributes to delete.
     * @example
     * // Delete a few Attributes
     * const { count } = await prisma.attributes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AttributesDeleteManyArgs>(
      args?: SelectSubset<T, AttributesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attributes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttributesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Attributes
     * const attributes = await prisma.attributes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AttributesUpdateManyArgs>(
      args: SelectSubset<T, AttributesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Attributes.
     * @param {AttributesUpsertArgs} args - Arguments to update or create a Attributes.
     * @example
     * // Update or create a Attributes
     * const attributes = await prisma.attributes.upsert({
     *   create: {
     *     // ... data to create a Attributes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Attributes we want to update
     *   }
     * })
    **/
    upsert<T extends AttributesUpsertArgs>(
      args: SelectSubset<T, AttributesUpsertArgs>
    ): CheckSelect<T, Prisma__AttributesClient<Attributes>, Prisma__AttributesClient<AttributesGetPayload<T>>>

    /**
     * Count the number of Attributes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttributesCountArgs} args - Arguments to filter Attributes to count.
     * @example
     * // Count the number of Attributes
     * const count = await prisma.attributes.count({
     *   where: {
     *     // ... the filter for the Attributes we want to count
     *   }
     * })
    **/
    count<T extends AttributesCountArgs>(
      args?: Subset<T, AttributesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttributesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Attributes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttributesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttributesAggregateArgs>(args: Subset<T, AttributesAggregateArgs>): PrismaPromise<GetAttributesAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for Attributes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AttributesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Attributes<T extends AttributesArgs = {}>(args?: Subset<T, AttributesArgs>): CheckSelect<T, Prisma__AttributesClient<Attributes | null >, Prisma__AttributesClient<AttributesGetPayload<T> | null >>;

    other_Attributes<T extends AttributesFindManyArgs = {}>(args?: Subset<T, AttributesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Attributes>>, PrismaPromise<Array<AttributesGetPayload<T>>>>;

    AttributeUnits<T extends AttributeUnitsFindManyArgs = {}>(args?: Subset<T, AttributeUnitsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<AttributeUnits>>, PrismaPromise<Array<AttributeUnitsGetPayload<T>>>>;

    ProductAttributeUnits<T extends ProductAttributeUnitsFindManyArgs = {}>(args?: Subset<T, ProductAttributeUnitsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ProductAttributeUnits>>, PrismaPromise<Array<ProductAttributeUnitsGetPayload<T>>>>;

    PropertyUnitAttributes<T extends PropertyUnitAttributesFindManyArgs = {}>(args?: Subset<T, PropertyUnitAttributesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<PropertyUnitAttributes>>, PrismaPromise<Array<PropertyUnitAttributesGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Attributes findUnique
   */
  export type AttributesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Attributes
    **/
    select?: AttributesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AttributesInclude | null
    /**
     * Throw an Error if a Attributes can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Attributes to fetch.
    **/
    where: AttributesWhereUniqueInput
  }


  /**
   * Attributes findFirst
   */
  export type AttributesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Attributes
    **/
    select?: AttributesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AttributesInclude | null
    /**
     * Throw an Error if a Attributes can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Attributes to fetch.
    **/
    where?: AttributesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attributes to fetch.
    **/
    orderBy?: Enumerable<AttributesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attributes.
    **/
    cursor?: AttributesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attributes from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attributes.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attributes.
    **/
    distinct?: Enumerable<AttributesScalarFieldEnum>
  }


  /**
   * Attributes findMany
   */
  export type AttributesFindManyArgs = {
    /**
     * Select specific fields to fetch from the Attributes
    **/
    select?: AttributesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AttributesInclude | null
    /**
     * Filter, which Attributes to fetch.
    **/
    where?: AttributesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attributes to fetch.
    **/
    orderBy?: Enumerable<AttributesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Attributes.
    **/
    cursor?: AttributesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attributes from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attributes.
    **/
    skip?: number
    distinct?: Enumerable<AttributesScalarFieldEnum>
  }


  /**
   * Attributes create
   */
  export type AttributesCreateArgs = {
    /**
     * Select specific fields to fetch from the Attributes
    **/
    select?: AttributesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AttributesInclude | null
    /**
     * The data needed to create a Attributes.
    **/
    data: XOR<AttributesCreateInput, AttributesUncheckedCreateInput>
  }


  /**
   * Attributes update
   */
  export type AttributesUpdateArgs = {
    /**
     * Select specific fields to fetch from the Attributes
    **/
    select?: AttributesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AttributesInclude | null
    /**
     * The data needed to update a Attributes.
    **/
    data: XOR<AttributesUpdateInput, AttributesUncheckedUpdateInput>
    /**
     * Choose, which Attributes to update.
    **/
    where: AttributesWhereUniqueInput
  }


  /**
   * Attributes updateMany
   */
  export type AttributesUpdateManyArgs = {
    data: XOR<AttributesUpdateManyMutationInput, AttributesUncheckedUpdateManyInput>
    where?: AttributesWhereInput
  }


  /**
   * Attributes upsert
   */
  export type AttributesUpsertArgs = {
    /**
     * Select specific fields to fetch from the Attributes
    **/
    select?: AttributesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AttributesInclude | null
    /**
     * The filter to search for the Attributes to update in case it exists.
    **/
    where: AttributesWhereUniqueInput
    /**
     * In case the Attributes found by the `where` argument doesn't exist, create a new Attributes with this data.
    **/
    create: XOR<AttributesCreateInput, AttributesUncheckedCreateInput>
    /**
     * In case the Attributes was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<AttributesUpdateInput, AttributesUncheckedUpdateInput>
  }


  /**
   * Attributes delete
   */
  export type AttributesDeleteArgs = {
    /**
     * Select specific fields to fetch from the Attributes
    **/
    select?: AttributesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AttributesInclude | null
    /**
     * Filter which Attributes to delete.
    **/
    where: AttributesWhereUniqueInput
  }


  /**
   * Attributes deleteMany
   */
  export type AttributesDeleteManyArgs = {
    where?: AttributesWhereInput
  }


  /**
   * Attributes without action
   */
  export type AttributesArgs = {
    /**
     * Select specific fields to fetch from the Attributes
    **/
    select?: AttributesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AttributesInclude | null
  }



  /**
   * Model AttributeUnits
   */


  export type AggregateAttributeUnits = {
    count: AttributeUnitsCountAggregateOutputType | null
    avg: AttributeUnitsAvgAggregateOutputType | null
    sum: AttributeUnitsSumAggregateOutputType | null
    min: AttributeUnitsMinAggregateOutputType | null
    max: AttributeUnitsMaxAggregateOutputType | null
  }

  export type AttributeUnitsAvgAggregateOutputType = {
    id: number
    attribute_parent_id: number | null
    created_by: number | null
    updated_by: number | null
  }

  export type AttributeUnitsSumAggregateOutputType = {
    id: number
    attribute_parent_id: number | null
    created_by: number | null
    updated_by: number | null
  }

  export type AttributeUnitsMinAggregateOutputType = {
    id: number
    attribute_parent_id: number | null
    unit_name: string | null
    slug: string | null
    created_at: Date | null
    updated_at: Date | null
    created_by: number | null
    updated_by: number | null
  }

  export type AttributeUnitsMaxAggregateOutputType = {
    id: number
    attribute_parent_id: number | null
    unit_name: string | null
    slug: string | null
    created_at: Date | null
    updated_at: Date | null
    created_by: number | null
    updated_by: number | null
  }

  export type AttributeUnitsCountAggregateOutputType = {
    id: number
    attribute_parent_id: number | null
    unit_name: number | null
    slug: number | null
    created_at: number | null
    updated_at: number | null
    created_by: number | null
    updated_by: number | null
    _all: number
  }


  export type AttributeUnitsAvgAggregateInputType = {
    id?: true
    attribute_parent_id?: true
    created_by?: true
    updated_by?: true
  }

  export type AttributeUnitsSumAggregateInputType = {
    id?: true
    attribute_parent_id?: true
    created_by?: true
    updated_by?: true
  }

  export type AttributeUnitsMinAggregateInputType = {
    id?: true
    attribute_parent_id?: true
    unit_name?: true
    slug?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type AttributeUnitsMaxAggregateInputType = {
    id?: true
    attribute_parent_id?: true
    unit_name?: true
    slug?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type AttributeUnitsCountAggregateInputType = {
    id?: true
    attribute_parent_id?: true
    unit_name?: true
    slug?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
    _all?: true
  }

  export type AttributeUnitsAggregateArgs = {
    /**
     * Filter which AttributeUnits to aggregate.
    **/
    where?: AttributeUnitsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttributeUnits to fetch.
    **/
    orderBy?: Enumerable<AttributeUnitsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: AttributeUnitsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttributeUnits from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttributeUnits.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AttributeUnits
    **/
    count?: true | AttributeUnitsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: AttributeUnitsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: AttributeUnitsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: AttributeUnitsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: AttributeUnitsMaxAggregateInputType
  }

  export type GetAttributeUnitsAggregateType<T extends AttributeUnitsAggregateArgs> = {
    [P in keyof T & keyof AggregateAttributeUnits]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttributeUnits[P]>
      : GetScalarType<T[P], AggregateAttributeUnits[P]>
  }



  export type AttributeUnitsSelect = {
    id?: boolean
    attribute_parent_id?: boolean
    unit_name?: boolean
    slug?: boolean
    created_at?: boolean
    updated_at?: boolean
    created_by?: boolean
    updated_by?: boolean
    Attributes?: boolean | AttributesArgs
    ProductAttributeUnits?: boolean | ProductAttributeUnitsFindManyArgs
    PropertyUnitAttributes?: boolean | PropertyUnitAttributesFindManyArgs
  }

  export type AttributeUnitsInclude = {
    Attributes?: boolean | AttributesArgs
    ProductAttributeUnits?: boolean | ProductAttributeUnitsFindManyArgs
    PropertyUnitAttributes?: boolean | PropertyUnitAttributesFindManyArgs
  }

  export type AttributeUnitsGetPayload<
    S extends boolean | null | undefined | AttributeUnitsArgs,
    U = keyof S
      > = S extends true
        ? AttributeUnits
    : S extends undefined
    ? never
    : S extends AttributeUnitsArgs | AttributeUnitsFindManyArgs
    ?'include' extends U
    ? AttributeUnits  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'Attributes'
        ? AttributesGetPayload<S['include'][P]> | null :
        P extends 'ProductAttributeUnits'
        ? Array < ProductAttributeUnitsGetPayload<S['include'][P]>>  :
        P extends 'PropertyUnitAttributes'
        ? Array < PropertyUnitAttributesGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof AttributeUnits ?AttributeUnits [P]
  : 
          P extends 'Attributes'
        ? AttributesGetPayload<S['select'][P]> | null :
        P extends 'ProductAttributeUnits'
        ? Array < ProductAttributeUnitsGetPayload<S['select'][P]>>  :
        P extends 'PropertyUnitAttributes'
        ? Array < PropertyUnitAttributesGetPayload<S['select'][P]>>  : never
  } 
    : AttributeUnits
  : AttributeUnits


  type AttributeUnitsCountArgs = Merge<
    Omit<AttributeUnitsFindManyArgs, 'select' | 'include'> & {
      select?: AttributeUnitsCountAggregateInputType | true
    }
  >

  export interface AttributeUnitsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one AttributeUnits that matches the filter.
     * @param {AttributeUnitsFindUniqueArgs} args - Arguments to find a AttributeUnits
     * @example
     * // Get one AttributeUnits
     * const attributeUnits = await prisma.attributeUnits.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AttributeUnitsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AttributeUnitsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'AttributeUnits'> extends True ? CheckSelect<T, Prisma__AttributeUnitsClient<AttributeUnits>, Prisma__AttributeUnitsClient<AttributeUnitsGetPayload<T>>> : CheckSelect<T, Prisma__AttributeUnitsClient<AttributeUnits | null >, Prisma__AttributeUnitsClient<AttributeUnitsGetPayload<T> | null >>

    /**
     * Find the first AttributeUnits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttributeUnitsFindFirstArgs} args - Arguments to find a AttributeUnits
     * @example
     * // Get one AttributeUnits
     * const attributeUnits = await prisma.attributeUnits.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AttributeUnitsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AttributeUnitsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'AttributeUnits'> extends True ? CheckSelect<T, Prisma__AttributeUnitsClient<AttributeUnits>, Prisma__AttributeUnitsClient<AttributeUnitsGetPayload<T>>> : CheckSelect<T, Prisma__AttributeUnitsClient<AttributeUnits | null >, Prisma__AttributeUnitsClient<AttributeUnitsGetPayload<T> | null >>

    /**
     * Find zero or more AttributeUnits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttributeUnitsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AttributeUnits
     * const attributeUnits = await prisma.attributeUnits.findMany()
     * 
     * // Get first 10 AttributeUnits
     * const attributeUnits = await prisma.attributeUnits.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attributeUnitsWithIdOnly = await prisma.attributeUnits.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AttributeUnitsFindManyArgs>(
      args?: SelectSubset<T, AttributeUnitsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<AttributeUnits>>, PrismaPromise<Array<AttributeUnitsGetPayload<T>>>>

    /**
     * Create a AttributeUnits.
     * @param {AttributeUnitsCreateArgs} args - Arguments to create a AttributeUnits.
     * @example
     * // Create one AttributeUnits
     * const AttributeUnits = await prisma.attributeUnits.create({
     *   data: {
     *     // ... data to create a AttributeUnits
     *   }
     * })
     * 
    **/
    create<T extends AttributeUnitsCreateArgs>(
      args: SelectSubset<T, AttributeUnitsCreateArgs>
    ): CheckSelect<T, Prisma__AttributeUnitsClient<AttributeUnits>, Prisma__AttributeUnitsClient<AttributeUnitsGetPayload<T>>>

    /**
     * Delete a AttributeUnits.
     * @param {AttributeUnitsDeleteArgs} args - Arguments to delete one AttributeUnits.
     * @example
     * // Delete one AttributeUnits
     * const AttributeUnits = await prisma.attributeUnits.delete({
     *   where: {
     *     // ... filter to delete one AttributeUnits
     *   }
     * })
     * 
    **/
    delete<T extends AttributeUnitsDeleteArgs>(
      args: SelectSubset<T, AttributeUnitsDeleteArgs>
    ): CheckSelect<T, Prisma__AttributeUnitsClient<AttributeUnits>, Prisma__AttributeUnitsClient<AttributeUnitsGetPayload<T>>>

    /**
     * Update one AttributeUnits.
     * @param {AttributeUnitsUpdateArgs} args - Arguments to update one AttributeUnits.
     * @example
     * // Update one AttributeUnits
     * const attributeUnits = await prisma.attributeUnits.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AttributeUnitsUpdateArgs>(
      args: SelectSubset<T, AttributeUnitsUpdateArgs>
    ): CheckSelect<T, Prisma__AttributeUnitsClient<AttributeUnits>, Prisma__AttributeUnitsClient<AttributeUnitsGetPayload<T>>>

    /**
     * Delete zero or more AttributeUnits.
     * @param {AttributeUnitsDeleteManyArgs} args - Arguments to filter AttributeUnits to delete.
     * @example
     * // Delete a few AttributeUnits
     * const { count } = await prisma.attributeUnits.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AttributeUnitsDeleteManyArgs>(
      args?: SelectSubset<T, AttributeUnitsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more AttributeUnits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttributeUnitsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AttributeUnits
     * const attributeUnits = await prisma.attributeUnits.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AttributeUnitsUpdateManyArgs>(
      args: SelectSubset<T, AttributeUnitsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one AttributeUnits.
     * @param {AttributeUnitsUpsertArgs} args - Arguments to update or create a AttributeUnits.
     * @example
     * // Update or create a AttributeUnits
     * const attributeUnits = await prisma.attributeUnits.upsert({
     *   create: {
     *     // ... data to create a AttributeUnits
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AttributeUnits we want to update
     *   }
     * })
    **/
    upsert<T extends AttributeUnitsUpsertArgs>(
      args: SelectSubset<T, AttributeUnitsUpsertArgs>
    ): CheckSelect<T, Prisma__AttributeUnitsClient<AttributeUnits>, Prisma__AttributeUnitsClient<AttributeUnitsGetPayload<T>>>

    /**
     * Count the number of AttributeUnits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttributeUnitsCountArgs} args - Arguments to filter AttributeUnits to count.
     * @example
     * // Count the number of AttributeUnits
     * const count = await prisma.attributeUnits.count({
     *   where: {
     *     // ... the filter for the AttributeUnits we want to count
     *   }
     * })
    **/
    count<T extends AttributeUnitsCountArgs>(
      args?: Subset<T, AttributeUnitsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttributeUnitsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AttributeUnits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttributeUnitsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttributeUnitsAggregateArgs>(args: Subset<T, AttributeUnitsAggregateArgs>): PrismaPromise<GetAttributeUnitsAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for AttributeUnits.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AttributeUnitsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Attributes<T extends AttributesArgs = {}>(args?: Subset<T, AttributesArgs>): CheckSelect<T, Prisma__AttributesClient<Attributes | null >, Prisma__AttributesClient<AttributesGetPayload<T> | null >>;

    ProductAttributeUnits<T extends ProductAttributeUnitsFindManyArgs = {}>(args?: Subset<T, ProductAttributeUnitsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ProductAttributeUnits>>, PrismaPromise<Array<ProductAttributeUnitsGetPayload<T>>>>;

    PropertyUnitAttributes<T extends PropertyUnitAttributesFindManyArgs = {}>(args?: Subset<T, PropertyUnitAttributesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<PropertyUnitAttributes>>, PrismaPromise<Array<PropertyUnitAttributesGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * AttributeUnits findUnique
   */
  export type AttributeUnitsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the AttributeUnits
    **/
    select?: AttributeUnitsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AttributeUnitsInclude | null
    /**
     * Throw an Error if a AttributeUnits can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which AttributeUnits to fetch.
    **/
    where: AttributeUnitsWhereUniqueInput
  }


  /**
   * AttributeUnits findFirst
   */
  export type AttributeUnitsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the AttributeUnits
    **/
    select?: AttributeUnitsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AttributeUnitsInclude | null
    /**
     * Throw an Error if a AttributeUnits can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which AttributeUnits to fetch.
    **/
    where?: AttributeUnitsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttributeUnits to fetch.
    **/
    orderBy?: Enumerable<AttributeUnitsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttributeUnits.
    **/
    cursor?: AttributeUnitsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttributeUnits from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttributeUnits.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttributeUnits.
    **/
    distinct?: Enumerable<AttributeUnitsScalarFieldEnum>
  }


  /**
   * AttributeUnits findMany
   */
  export type AttributeUnitsFindManyArgs = {
    /**
     * Select specific fields to fetch from the AttributeUnits
    **/
    select?: AttributeUnitsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AttributeUnitsInclude | null
    /**
     * Filter, which AttributeUnits to fetch.
    **/
    where?: AttributeUnitsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttributeUnits to fetch.
    **/
    orderBy?: Enumerable<AttributeUnitsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AttributeUnits.
    **/
    cursor?: AttributeUnitsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttributeUnits from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttributeUnits.
    **/
    skip?: number
    distinct?: Enumerable<AttributeUnitsScalarFieldEnum>
  }


  /**
   * AttributeUnits create
   */
  export type AttributeUnitsCreateArgs = {
    /**
     * Select specific fields to fetch from the AttributeUnits
    **/
    select?: AttributeUnitsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AttributeUnitsInclude | null
    /**
     * The data needed to create a AttributeUnits.
    **/
    data: XOR<AttributeUnitsCreateInput, AttributeUnitsUncheckedCreateInput>
  }


  /**
   * AttributeUnits update
   */
  export type AttributeUnitsUpdateArgs = {
    /**
     * Select specific fields to fetch from the AttributeUnits
    **/
    select?: AttributeUnitsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AttributeUnitsInclude | null
    /**
     * The data needed to update a AttributeUnits.
    **/
    data: XOR<AttributeUnitsUpdateInput, AttributeUnitsUncheckedUpdateInput>
    /**
     * Choose, which AttributeUnits to update.
    **/
    where: AttributeUnitsWhereUniqueInput
  }


  /**
   * AttributeUnits updateMany
   */
  export type AttributeUnitsUpdateManyArgs = {
    data: XOR<AttributeUnitsUpdateManyMutationInput, AttributeUnitsUncheckedUpdateManyInput>
    where?: AttributeUnitsWhereInput
  }


  /**
   * AttributeUnits upsert
   */
  export type AttributeUnitsUpsertArgs = {
    /**
     * Select specific fields to fetch from the AttributeUnits
    **/
    select?: AttributeUnitsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AttributeUnitsInclude | null
    /**
     * The filter to search for the AttributeUnits to update in case it exists.
    **/
    where: AttributeUnitsWhereUniqueInput
    /**
     * In case the AttributeUnits found by the `where` argument doesn't exist, create a new AttributeUnits with this data.
    **/
    create: XOR<AttributeUnitsCreateInput, AttributeUnitsUncheckedCreateInput>
    /**
     * In case the AttributeUnits was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<AttributeUnitsUpdateInput, AttributeUnitsUncheckedUpdateInput>
  }


  /**
   * AttributeUnits delete
   */
  export type AttributeUnitsDeleteArgs = {
    /**
     * Select specific fields to fetch from the AttributeUnits
    **/
    select?: AttributeUnitsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AttributeUnitsInclude | null
    /**
     * Filter which AttributeUnits to delete.
    **/
    where: AttributeUnitsWhereUniqueInput
  }


  /**
   * AttributeUnits deleteMany
   */
  export type AttributeUnitsDeleteManyArgs = {
    where?: AttributeUnitsWhereInput
  }


  /**
   * AttributeUnits without action
   */
  export type AttributeUnitsArgs = {
    /**
     * Select specific fields to fetch from the AttributeUnits
    **/
    select?: AttributeUnitsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AttributeUnitsInclude | null
  }



  /**
   * Model Backend_Users
   */


  export type AggregateBackend_Users = {
    count: Backend_UsersCountAggregateOutputType | null
    avg: Backend_UsersAvgAggregateOutputType | null
    sum: Backend_UsersSumAggregateOutputType | null
    min: Backend_UsersMinAggregateOutputType | null
    max: Backend_UsersMaxAggregateOutputType | null
  }

  export type Backend_UsersAvgAggregateOutputType = {
    id: number
    user_id: number
    created_by: number | null
    updated_by: number | null
  }

  export type Backend_UsersSumAggregateOutputType = {
    id: number
    user_id: number
    created_by: number | null
    updated_by: number | null
  }

  export type Backend_UsersMinAggregateOutputType = {
    id: number
    user_id: number
    first_name: string | null
    last_name: string | null
    created_at: Date | null
    updated_at: Date | null
    created_by: number | null
    updated_by: number | null
  }

  export type Backend_UsersMaxAggregateOutputType = {
    id: number
    user_id: number
    first_name: string | null
    last_name: string | null
    created_at: Date | null
    updated_at: Date | null
    created_by: number | null
    updated_by: number | null
  }

  export type Backend_UsersCountAggregateOutputType = {
    id: number
    user_id: number
    first_name: number | null
    last_name: number | null
    created_at: number | null
    updated_at: number | null
    created_by: number | null
    updated_by: number | null
    _all: number
  }


  export type Backend_UsersAvgAggregateInputType = {
    id?: true
    user_id?: true
    created_by?: true
    updated_by?: true
  }

  export type Backend_UsersSumAggregateInputType = {
    id?: true
    user_id?: true
    created_by?: true
    updated_by?: true
  }

  export type Backend_UsersMinAggregateInputType = {
    id?: true
    user_id?: true
    first_name?: true
    last_name?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type Backend_UsersMaxAggregateInputType = {
    id?: true
    user_id?: true
    first_name?: true
    last_name?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type Backend_UsersCountAggregateInputType = {
    id?: true
    user_id?: true
    first_name?: true
    last_name?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
    _all?: true
  }

  export type Backend_UsersAggregateArgs = {
    /**
     * Filter which Backend_Users to aggregate.
    **/
    where?: Backend_UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Backend_Users to fetch.
    **/
    orderBy?: Enumerable<Backend_UsersOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: Backend_UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Backend_Users from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Backend_Users.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Backend_Users
    **/
    count?: true | Backend_UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: Backend_UsersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: Backend_UsersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: Backend_UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: Backend_UsersMaxAggregateInputType
  }

  export type GetBackend_UsersAggregateType<T extends Backend_UsersAggregateArgs> = {
    [P in keyof T & keyof AggregateBackend_Users]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBackend_Users[P]>
      : GetScalarType<T[P], AggregateBackend_Users[P]>
  }



  export type Backend_UsersSelect = {
    id?: boolean
    user_id?: boolean
    first_name?: boolean
    last_name?: boolean
    created_at?: boolean
    updated_at?: boolean
    created_by?: boolean
    updated_by?: boolean
    Users?: boolean | UsersArgs
  }

  export type Backend_UsersInclude = {
    Users?: boolean | UsersArgs
  }

  export type Backend_UsersGetPayload<
    S extends boolean | null | undefined | Backend_UsersArgs,
    U = keyof S
      > = S extends true
        ? Backend_Users
    : S extends undefined
    ? never
    : S extends Backend_UsersArgs | Backend_UsersFindManyArgs
    ?'include' extends U
    ? Backend_Users  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'Users'
        ? UsersGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Backend_Users ?Backend_Users [P]
  : 
          P extends 'Users'
        ? UsersGetPayload<S['select'][P]> : never
  } 
    : Backend_Users
  : Backend_Users


  type Backend_UsersCountArgs = Merge<
    Omit<Backend_UsersFindManyArgs, 'select' | 'include'> & {
      select?: Backend_UsersCountAggregateInputType | true
    }
  >

  export interface Backend_UsersDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Backend_Users that matches the filter.
     * @param {Backend_UsersFindUniqueArgs} args - Arguments to find a Backend_Users
     * @example
     * // Get one Backend_Users
     * const backend_Users = await prisma.backend_Users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends Backend_UsersFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, Backend_UsersFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Backend_Users'> extends True ? CheckSelect<T, Prisma__Backend_UsersClient<Backend_Users>, Prisma__Backend_UsersClient<Backend_UsersGetPayload<T>>> : CheckSelect<T, Prisma__Backend_UsersClient<Backend_Users | null >, Prisma__Backend_UsersClient<Backend_UsersGetPayload<T> | null >>

    /**
     * Find the first Backend_Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Backend_UsersFindFirstArgs} args - Arguments to find a Backend_Users
     * @example
     * // Get one Backend_Users
     * const backend_Users = await prisma.backend_Users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends Backend_UsersFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, Backend_UsersFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Backend_Users'> extends True ? CheckSelect<T, Prisma__Backend_UsersClient<Backend_Users>, Prisma__Backend_UsersClient<Backend_UsersGetPayload<T>>> : CheckSelect<T, Prisma__Backend_UsersClient<Backend_Users | null >, Prisma__Backend_UsersClient<Backend_UsersGetPayload<T> | null >>

    /**
     * Find zero or more Backend_Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Backend_UsersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Backend_Users
     * const backend_Users = await prisma.backend_Users.findMany()
     * 
     * // Get first 10 Backend_Users
     * const backend_Users = await prisma.backend_Users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const backend_UsersWithIdOnly = await prisma.backend_Users.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends Backend_UsersFindManyArgs>(
      args?: SelectSubset<T, Backend_UsersFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Backend_Users>>, PrismaPromise<Array<Backend_UsersGetPayload<T>>>>

    /**
     * Create a Backend_Users.
     * @param {Backend_UsersCreateArgs} args - Arguments to create a Backend_Users.
     * @example
     * // Create one Backend_Users
     * const Backend_Users = await prisma.backend_Users.create({
     *   data: {
     *     // ... data to create a Backend_Users
     *   }
     * })
     * 
    **/
    create<T extends Backend_UsersCreateArgs>(
      args: SelectSubset<T, Backend_UsersCreateArgs>
    ): CheckSelect<T, Prisma__Backend_UsersClient<Backend_Users>, Prisma__Backend_UsersClient<Backend_UsersGetPayload<T>>>

    /**
     * Delete a Backend_Users.
     * @param {Backend_UsersDeleteArgs} args - Arguments to delete one Backend_Users.
     * @example
     * // Delete one Backend_Users
     * const Backend_Users = await prisma.backend_Users.delete({
     *   where: {
     *     // ... filter to delete one Backend_Users
     *   }
     * })
     * 
    **/
    delete<T extends Backend_UsersDeleteArgs>(
      args: SelectSubset<T, Backend_UsersDeleteArgs>
    ): CheckSelect<T, Prisma__Backend_UsersClient<Backend_Users>, Prisma__Backend_UsersClient<Backend_UsersGetPayload<T>>>

    /**
     * Update one Backend_Users.
     * @param {Backend_UsersUpdateArgs} args - Arguments to update one Backend_Users.
     * @example
     * // Update one Backend_Users
     * const backend_Users = await prisma.backend_Users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends Backend_UsersUpdateArgs>(
      args: SelectSubset<T, Backend_UsersUpdateArgs>
    ): CheckSelect<T, Prisma__Backend_UsersClient<Backend_Users>, Prisma__Backend_UsersClient<Backend_UsersGetPayload<T>>>

    /**
     * Delete zero or more Backend_Users.
     * @param {Backend_UsersDeleteManyArgs} args - Arguments to filter Backend_Users to delete.
     * @example
     * // Delete a few Backend_Users
     * const { count } = await prisma.backend_Users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends Backend_UsersDeleteManyArgs>(
      args?: SelectSubset<T, Backend_UsersDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Backend_Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Backend_UsersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Backend_Users
     * const backend_Users = await prisma.backend_Users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends Backend_UsersUpdateManyArgs>(
      args: SelectSubset<T, Backend_UsersUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Backend_Users.
     * @param {Backend_UsersUpsertArgs} args - Arguments to update or create a Backend_Users.
     * @example
     * // Update or create a Backend_Users
     * const backend_Users = await prisma.backend_Users.upsert({
     *   create: {
     *     // ... data to create a Backend_Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Backend_Users we want to update
     *   }
     * })
    **/
    upsert<T extends Backend_UsersUpsertArgs>(
      args: SelectSubset<T, Backend_UsersUpsertArgs>
    ): CheckSelect<T, Prisma__Backend_UsersClient<Backend_Users>, Prisma__Backend_UsersClient<Backend_UsersGetPayload<T>>>

    /**
     * Count the number of Backend_Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Backend_UsersCountArgs} args - Arguments to filter Backend_Users to count.
     * @example
     * // Count the number of Backend_Users
     * const count = await prisma.backend_Users.count({
     *   where: {
     *     // ... the filter for the Backend_Users we want to count
     *   }
     * })
    **/
    count<T extends Backend_UsersCountArgs>(
      args?: Subset<T, Backend_UsersCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Backend_UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Backend_Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Backend_UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Backend_UsersAggregateArgs>(args: Subset<T, Backend_UsersAggregateArgs>): PrismaPromise<GetBackend_UsersAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for Backend_Users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__Backend_UsersClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Users<T extends UsersArgs = {}>(args?: Subset<T, UsersArgs>): CheckSelect<T, Prisma__UsersClient<Users | null >, Prisma__UsersClient<UsersGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Backend_Users findUnique
   */
  export type Backend_UsersFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Backend_Users
    **/
    select?: Backend_UsersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: Backend_UsersInclude | null
    /**
     * Throw an Error if a Backend_Users can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Backend_Users to fetch.
    **/
    where: Backend_UsersWhereUniqueInput
  }


  /**
   * Backend_Users findFirst
   */
  export type Backend_UsersFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Backend_Users
    **/
    select?: Backend_UsersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: Backend_UsersInclude | null
    /**
     * Throw an Error if a Backend_Users can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Backend_Users to fetch.
    **/
    where?: Backend_UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Backend_Users to fetch.
    **/
    orderBy?: Enumerable<Backend_UsersOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Backend_Users.
    **/
    cursor?: Backend_UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Backend_Users from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Backend_Users.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Backend_Users.
    **/
    distinct?: Enumerable<Backend_UsersScalarFieldEnum>
  }


  /**
   * Backend_Users findMany
   */
  export type Backend_UsersFindManyArgs = {
    /**
     * Select specific fields to fetch from the Backend_Users
    **/
    select?: Backend_UsersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: Backend_UsersInclude | null
    /**
     * Filter, which Backend_Users to fetch.
    **/
    where?: Backend_UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Backend_Users to fetch.
    **/
    orderBy?: Enumerable<Backend_UsersOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Backend_Users.
    **/
    cursor?: Backend_UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Backend_Users from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Backend_Users.
    **/
    skip?: number
    distinct?: Enumerable<Backend_UsersScalarFieldEnum>
  }


  /**
   * Backend_Users create
   */
  export type Backend_UsersCreateArgs = {
    /**
     * Select specific fields to fetch from the Backend_Users
    **/
    select?: Backend_UsersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: Backend_UsersInclude | null
    /**
     * The data needed to create a Backend_Users.
    **/
    data: XOR<Backend_UsersCreateInput, Backend_UsersUncheckedCreateInput>
  }


  /**
   * Backend_Users update
   */
  export type Backend_UsersUpdateArgs = {
    /**
     * Select specific fields to fetch from the Backend_Users
    **/
    select?: Backend_UsersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: Backend_UsersInclude | null
    /**
     * The data needed to update a Backend_Users.
    **/
    data: XOR<Backend_UsersUpdateInput, Backend_UsersUncheckedUpdateInput>
    /**
     * Choose, which Backend_Users to update.
    **/
    where: Backend_UsersWhereUniqueInput
  }


  /**
   * Backend_Users updateMany
   */
  export type Backend_UsersUpdateManyArgs = {
    data: XOR<Backend_UsersUpdateManyMutationInput, Backend_UsersUncheckedUpdateManyInput>
    where?: Backend_UsersWhereInput
  }


  /**
   * Backend_Users upsert
   */
  export type Backend_UsersUpsertArgs = {
    /**
     * Select specific fields to fetch from the Backend_Users
    **/
    select?: Backend_UsersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: Backend_UsersInclude | null
    /**
     * The filter to search for the Backend_Users to update in case it exists.
    **/
    where: Backend_UsersWhereUniqueInput
    /**
     * In case the Backend_Users found by the `where` argument doesn't exist, create a new Backend_Users with this data.
    **/
    create: XOR<Backend_UsersCreateInput, Backend_UsersUncheckedCreateInput>
    /**
     * In case the Backend_Users was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<Backend_UsersUpdateInput, Backend_UsersUncheckedUpdateInput>
  }


  /**
   * Backend_Users delete
   */
  export type Backend_UsersDeleteArgs = {
    /**
     * Select specific fields to fetch from the Backend_Users
    **/
    select?: Backend_UsersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: Backend_UsersInclude | null
    /**
     * Filter which Backend_Users to delete.
    **/
    where: Backend_UsersWhereUniqueInput
  }


  /**
   * Backend_Users deleteMany
   */
  export type Backend_UsersDeleteManyArgs = {
    where?: Backend_UsersWhereInput
  }


  /**
   * Backend_Users without action
   */
  export type Backend_UsersArgs = {
    /**
     * Select specific fields to fetch from the Backend_Users
    **/
    select?: Backend_UsersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: Backend_UsersInclude | null
  }



  /**
   * Model Cities
   */


  export type AggregateCities = {
    count: CitiesCountAggregateOutputType | null
    avg: CitiesAvgAggregateOutputType | null
    sum: CitiesSumAggregateOutputType | null
    min: CitiesMinAggregateOutputType | null
    max: CitiesMaxAggregateOutputType | null
  }

  export type CitiesAvgAggregateOutputType = {
    id: number
    state_id: number
    created_by: number | null
    updated_by: number | null
  }

  export type CitiesSumAggregateOutputType = {
    id: number
    state_id: number
    created_by: number | null
    updated_by: number | null
  }

  export type CitiesMinAggregateOutputType = {
    id: number
    state_id: number
    name: string | null
    status: boolean | null
    created_at: Date | null
    updated_at: Date | null
    created_by: number | null
    updated_by: number | null
  }

  export type CitiesMaxAggregateOutputType = {
    id: number
    state_id: number
    name: string | null
    status: boolean | null
    created_at: Date | null
    updated_at: Date | null
    created_by: number | null
    updated_by: number | null
  }

  export type CitiesCountAggregateOutputType = {
    id: number
    state_id: number
    name: number | null
    status: number | null
    created_at: number | null
    updated_at: number | null
    created_by: number | null
    updated_by: number | null
    _all: number
  }


  export type CitiesAvgAggregateInputType = {
    id?: true
    state_id?: true
    created_by?: true
    updated_by?: true
  }

  export type CitiesSumAggregateInputType = {
    id?: true
    state_id?: true
    created_by?: true
    updated_by?: true
  }

  export type CitiesMinAggregateInputType = {
    id?: true
    state_id?: true
    name?: true
    status?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type CitiesMaxAggregateInputType = {
    id?: true
    state_id?: true
    name?: true
    status?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type CitiesCountAggregateInputType = {
    id?: true
    state_id?: true
    name?: true
    status?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
    _all?: true
  }

  export type CitiesAggregateArgs = {
    /**
     * Filter which Cities to aggregate.
    **/
    where?: CitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
    **/
    orderBy?: Enumerable<CitiesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: CitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cities
    **/
    count?: true | CitiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: CitiesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: CitiesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: CitiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: CitiesMaxAggregateInputType
  }

  export type GetCitiesAggregateType<T extends CitiesAggregateArgs> = {
    [P in keyof T & keyof AggregateCities]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCities[P]>
      : GetScalarType<T[P], AggregateCities[P]>
  }



  export type CitiesSelect = {
    id?: boolean
    state_id?: boolean
    name?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    created_by?: boolean
    updated_by?: boolean
    States?: boolean | StatesArgs
    Property_Addresses?: boolean | Property_AddressesFindManyArgs
  }

  export type CitiesInclude = {
    States?: boolean | StatesArgs
    Property_Addresses?: boolean | Property_AddressesFindManyArgs
  }

  export type CitiesGetPayload<
    S extends boolean | null | undefined | CitiesArgs,
    U = keyof S
      > = S extends true
        ? Cities
    : S extends undefined
    ? never
    : S extends CitiesArgs | CitiesFindManyArgs
    ?'include' extends U
    ? Cities  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'States'
        ? StatesGetPayload<S['include'][P]> :
        P extends 'Property_Addresses'
        ? Array < Property_AddressesGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Cities ?Cities [P]
  : 
          P extends 'States'
        ? StatesGetPayload<S['select'][P]> :
        P extends 'Property_Addresses'
        ? Array < Property_AddressesGetPayload<S['select'][P]>>  : never
  } 
    : Cities
  : Cities


  type CitiesCountArgs = Merge<
    Omit<CitiesFindManyArgs, 'select' | 'include'> & {
      select?: CitiesCountAggregateInputType | true
    }
  >

  export interface CitiesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Cities that matches the filter.
     * @param {CitiesFindUniqueArgs} args - Arguments to find a Cities
     * @example
     * // Get one Cities
     * const cities = await prisma.cities.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CitiesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CitiesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Cities'> extends True ? CheckSelect<T, Prisma__CitiesClient<Cities>, Prisma__CitiesClient<CitiesGetPayload<T>>> : CheckSelect<T, Prisma__CitiesClient<Cities | null >, Prisma__CitiesClient<CitiesGetPayload<T> | null >>

    /**
     * Find the first Cities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CitiesFindFirstArgs} args - Arguments to find a Cities
     * @example
     * // Get one Cities
     * const cities = await prisma.cities.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CitiesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CitiesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Cities'> extends True ? CheckSelect<T, Prisma__CitiesClient<Cities>, Prisma__CitiesClient<CitiesGetPayload<T>>> : CheckSelect<T, Prisma__CitiesClient<Cities | null >, Prisma__CitiesClient<CitiesGetPayload<T> | null >>

    /**
     * Find zero or more Cities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CitiesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cities
     * const cities = await prisma.cities.findMany()
     * 
     * // Get first 10 Cities
     * const cities = await prisma.cities.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const citiesWithIdOnly = await prisma.cities.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CitiesFindManyArgs>(
      args?: SelectSubset<T, CitiesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Cities>>, PrismaPromise<Array<CitiesGetPayload<T>>>>

    /**
     * Create a Cities.
     * @param {CitiesCreateArgs} args - Arguments to create a Cities.
     * @example
     * // Create one Cities
     * const Cities = await prisma.cities.create({
     *   data: {
     *     // ... data to create a Cities
     *   }
     * })
     * 
    **/
    create<T extends CitiesCreateArgs>(
      args: SelectSubset<T, CitiesCreateArgs>
    ): CheckSelect<T, Prisma__CitiesClient<Cities>, Prisma__CitiesClient<CitiesGetPayload<T>>>

    /**
     * Delete a Cities.
     * @param {CitiesDeleteArgs} args - Arguments to delete one Cities.
     * @example
     * // Delete one Cities
     * const Cities = await prisma.cities.delete({
     *   where: {
     *     // ... filter to delete one Cities
     *   }
     * })
     * 
    **/
    delete<T extends CitiesDeleteArgs>(
      args: SelectSubset<T, CitiesDeleteArgs>
    ): CheckSelect<T, Prisma__CitiesClient<Cities>, Prisma__CitiesClient<CitiesGetPayload<T>>>

    /**
     * Update one Cities.
     * @param {CitiesUpdateArgs} args - Arguments to update one Cities.
     * @example
     * // Update one Cities
     * const cities = await prisma.cities.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CitiesUpdateArgs>(
      args: SelectSubset<T, CitiesUpdateArgs>
    ): CheckSelect<T, Prisma__CitiesClient<Cities>, Prisma__CitiesClient<CitiesGetPayload<T>>>

    /**
     * Delete zero or more Cities.
     * @param {CitiesDeleteManyArgs} args - Arguments to filter Cities to delete.
     * @example
     * // Delete a few Cities
     * const { count } = await prisma.cities.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CitiesDeleteManyArgs>(
      args?: SelectSubset<T, CitiesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CitiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cities
     * const cities = await prisma.cities.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CitiesUpdateManyArgs>(
      args: SelectSubset<T, CitiesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Cities.
     * @param {CitiesUpsertArgs} args - Arguments to update or create a Cities.
     * @example
     * // Update or create a Cities
     * const cities = await prisma.cities.upsert({
     *   create: {
     *     // ... data to create a Cities
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cities we want to update
     *   }
     * })
    **/
    upsert<T extends CitiesUpsertArgs>(
      args: SelectSubset<T, CitiesUpsertArgs>
    ): CheckSelect<T, Prisma__CitiesClient<Cities>, Prisma__CitiesClient<CitiesGetPayload<T>>>

    /**
     * Count the number of Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CitiesCountArgs} args - Arguments to filter Cities to count.
     * @example
     * // Count the number of Cities
     * const count = await prisma.cities.count({
     *   where: {
     *     // ... the filter for the Cities we want to count
     *   }
     * })
    **/
    count<T extends CitiesCountArgs>(
      args?: Subset<T, CitiesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CitiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CitiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CitiesAggregateArgs>(args: Subset<T, CitiesAggregateArgs>): PrismaPromise<GetCitiesAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for Cities.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CitiesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    States<T extends StatesArgs = {}>(args?: Subset<T, StatesArgs>): CheckSelect<T, Prisma__StatesClient<States | null >, Prisma__StatesClient<StatesGetPayload<T> | null >>;

    Property_Addresses<T extends Property_AddressesFindManyArgs = {}>(args?: Subset<T, Property_AddressesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Property_Addresses>>, PrismaPromise<Array<Property_AddressesGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Cities findUnique
   */
  export type CitiesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Cities
    **/
    select?: CitiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CitiesInclude | null
    /**
     * Throw an Error if a Cities can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Cities to fetch.
    **/
    where: CitiesWhereUniqueInput
  }


  /**
   * Cities findFirst
   */
  export type CitiesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Cities
    **/
    select?: CitiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CitiesInclude | null
    /**
     * Throw an Error if a Cities can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Cities to fetch.
    **/
    where?: CitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
    **/
    orderBy?: Enumerable<CitiesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cities.
    **/
    cursor?: CitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cities.
    **/
    distinct?: Enumerable<CitiesScalarFieldEnum>
  }


  /**
   * Cities findMany
   */
  export type CitiesFindManyArgs = {
    /**
     * Select specific fields to fetch from the Cities
    **/
    select?: CitiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CitiesInclude | null
    /**
     * Filter, which Cities to fetch.
    **/
    where?: CitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
    **/
    orderBy?: Enumerable<CitiesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cities.
    **/
    cursor?: CitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
    **/
    skip?: number
    distinct?: Enumerable<CitiesScalarFieldEnum>
  }


  /**
   * Cities create
   */
  export type CitiesCreateArgs = {
    /**
     * Select specific fields to fetch from the Cities
    **/
    select?: CitiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CitiesInclude | null
    /**
     * The data needed to create a Cities.
    **/
    data: XOR<CitiesCreateInput, CitiesUncheckedCreateInput>
  }


  /**
   * Cities update
   */
  export type CitiesUpdateArgs = {
    /**
     * Select specific fields to fetch from the Cities
    **/
    select?: CitiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CitiesInclude | null
    /**
     * The data needed to update a Cities.
    **/
    data: XOR<CitiesUpdateInput, CitiesUncheckedUpdateInput>
    /**
     * Choose, which Cities to update.
    **/
    where: CitiesWhereUniqueInput
  }


  /**
   * Cities updateMany
   */
  export type CitiesUpdateManyArgs = {
    data: XOR<CitiesUpdateManyMutationInput, CitiesUncheckedUpdateManyInput>
    where?: CitiesWhereInput
  }


  /**
   * Cities upsert
   */
  export type CitiesUpsertArgs = {
    /**
     * Select specific fields to fetch from the Cities
    **/
    select?: CitiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CitiesInclude | null
    /**
     * The filter to search for the Cities to update in case it exists.
    **/
    where: CitiesWhereUniqueInput
    /**
     * In case the Cities found by the `where` argument doesn't exist, create a new Cities with this data.
    **/
    create: XOR<CitiesCreateInput, CitiesUncheckedCreateInput>
    /**
     * In case the Cities was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<CitiesUpdateInput, CitiesUncheckedUpdateInput>
  }


  /**
   * Cities delete
   */
  export type CitiesDeleteArgs = {
    /**
     * Select specific fields to fetch from the Cities
    **/
    select?: CitiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CitiesInclude | null
    /**
     * Filter which Cities to delete.
    **/
    where: CitiesWhereUniqueInput
  }


  /**
   * Cities deleteMany
   */
  export type CitiesDeleteManyArgs = {
    where?: CitiesWhereInput
  }


  /**
   * Cities without action
   */
  export type CitiesArgs = {
    /**
     * Select specific fields to fetch from the Cities
    **/
    select?: CitiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CitiesInclude | null
  }



  /**
   * Model Contractors
   */


  export type AggregateContractors = {
    count: ContractorsCountAggregateOutputType | null
    avg: ContractorsAvgAggregateOutputType | null
    sum: ContractorsSumAggregateOutputType | null
    min: ContractorsMinAggregateOutputType | null
    max: ContractorsMaxAggregateOutputType | null
  }

  export type ContractorsAvgAggregateOutputType = {
    id: number
    user_id: number
    created_by: number | null
    updated_by: number | null
  }

  export type ContractorsSumAggregateOutputType = {
    id: number
    user_id: number
    created_by: number | null
    updated_by: number | null
  }

  export type ContractorsMinAggregateOutputType = {
    id: number
    user_id: number
    first_name: string | null
    last_name: string | null
    mobile: string | null
    company_name: string | null
    created_at: Date | null
    updated_at: Date | null
    created_by: number | null
    updated_by: number | null
  }

  export type ContractorsMaxAggregateOutputType = {
    id: number
    user_id: number
    first_name: string | null
    last_name: string | null
    mobile: string | null
    company_name: string | null
    created_at: Date | null
    updated_at: Date | null
    created_by: number | null
    updated_by: number | null
  }

  export type ContractorsCountAggregateOutputType = {
    id: number
    user_id: number
    first_name: number | null
    last_name: number | null
    mobile: number | null
    company_name: number | null
    created_at: number | null
    updated_at: number | null
    created_by: number | null
    updated_by: number | null
    _all: number
  }


  export type ContractorsAvgAggregateInputType = {
    id?: true
    user_id?: true
    created_by?: true
    updated_by?: true
  }

  export type ContractorsSumAggregateInputType = {
    id?: true
    user_id?: true
    created_by?: true
    updated_by?: true
  }

  export type ContractorsMinAggregateInputType = {
    id?: true
    user_id?: true
    first_name?: true
    last_name?: true
    mobile?: true
    company_name?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type ContractorsMaxAggregateInputType = {
    id?: true
    user_id?: true
    first_name?: true
    last_name?: true
    mobile?: true
    company_name?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type ContractorsCountAggregateInputType = {
    id?: true
    user_id?: true
    first_name?: true
    last_name?: true
    mobile?: true
    company_name?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
    _all?: true
  }

  export type ContractorsAggregateArgs = {
    /**
     * Filter which Contractors to aggregate.
    **/
    where?: ContractorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contractors to fetch.
    **/
    orderBy?: Enumerable<ContractorsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: ContractorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contractors from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contractors.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contractors
    **/
    count?: true | ContractorsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: ContractorsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: ContractorsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: ContractorsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: ContractorsMaxAggregateInputType
  }

  export type GetContractorsAggregateType<T extends ContractorsAggregateArgs> = {
    [P in keyof T & keyof AggregateContractors]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContractors[P]>
      : GetScalarType<T[P], AggregateContractors[P]>
  }



  export type ContractorsSelect = {
    id?: boolean
    user_id?: boolean
    first_name?: boolean
    last_name?: boolean
    mobile?: boolean
    company_name?: boolean
    created_at?: boolean
    updated_at?: boolean
    created_by?: boolean
    updated_by?: boolean
    Users?: boolean | UsersArgs
  }

  export type ContractorsInclude = {
    Users?: boolean | UsersArgs
  }

  export type ContractorsGetPayload<
    S extends boolean | null | undefined | ContractorsArgs,
    U = keyof S
      > = S extends true
        ? Contractors
    : S extends undefined
    ? never
    : S extends ContractorsArgs | ContractorsFindManyArgs
    ?'include' extends U
    ? Contractors  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'Users'
        ? UsersGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Contractors ?Contractors [P]
  : 
          P extends 'Users'
        ? UsersGetPayload<S['select'][P]> : never
  } 
    : Contractors
  : Contractors


  type ContractorsCountArgs = Merge<
    Omit<ContractorsFindManyArgs, 'select' | 'include'> & {
      select?: ContractorsCountAggregateInputType | true
    }
  >

  export interface ContractorsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Contractors that matches the filter.
     * @param {ContractorsFindUniqueArgs} args - Arguments to find a Contractors
     * @example
     * // Get one Contractors
     * const contractors = await prisma.contractors.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ContractorsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ContractorsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Contractors'> extends True ? CheckSelect<T, Prisma__ContractorsClient<Contractors>, Prisma__ContractorsClient<ContractorsGetPayload<T>>> : CheckSelect<T, Prisma__ContractorsClient<Contractors | null >, Prisma__ContractorsClient<ContractorsGetPayload<T> | null >>

    /**
     * Find the first Contractors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractorsFindFirstArgs} args - Arguments to find a Contractors
     * @example
     * // Get one Contractors
     * const contractors = await prisma.contractors.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ContractorsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ContractorsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Contractors'> extends True ? CheckSelect<T, Prisma__ContractorsClient<Contractors>, Prisma__ContractorsClient<ContractorsGetPayload<T>>> : CheckSelect<T, Prisma__ContractorsClient<Contractors | null >, Prisma__ContractorsClient<ContractorsGetPayload<T> | null >>

    /**
     * Find zero or more Contractors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractorsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contractors
     * const contractors = await prisma.contractors.findMany()
     * 
     * // Get first 10 Contractors
     * const contractors = await prisma.contractors.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contractorsWithIdOnly = await prisma.contractors.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ContractorsFindManyArgs>(
      args?: SelectSubset<T, ContractorsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Contractors>>, PrismaPromise<Array<ContractorsGetPayload<T>>>>

    /**
     * Create a Contractors.
     * @param {ContractorsCreateArgs} args - Arguments to create a Contractors.
     * @example
     * // Create one Contractors
     * const Contractors = await prisma.contractors.create({
     *   data: {
     *     // ... data to create a Contractors
     *   }
     * })
     * 
    **/
    create<T extends ContractorsCreateArgs>(
      args: SelectSubset<T, ContractorsCreateArgs>
    ): CheckSelect<T, Prisma__ContractorsClient<Contractors>, Prisma__ContractorsClient<ContractorsGetPayload<T>>>

    /**
     * Delete a Contractors.
     * @param {ContractorsDeleteArgs} args - Arguments to delete one Contractors.
     * @example
     * // Delete one Contractors
     * const Contractors = await prisma.contractors.delete({
     *   where: {
     *     // ... filter to delete one Contractors
     *   }
     * })
     * 
    **/
    delete<T extends ContractorsDeleteArgs>(
      args: SelectSubset<T, ContractorsDeleteArgs>
    ): CheckSelect<T, Prisma__ContractorsClient<Contractors>, Prisma__ContractorsClient<ContractorsGetPayload<T>>>

    /**
     * Update one Contractors.
     * @param {ContractorsUpdateArgs} args - Arguments to update one Contractors.
     * @example
     * // Update one Contractors
     * const contractors = await prisma.contractors.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ContractorsUpdateArgs>(
      args: SelectSubset<T, ContractorsUpdateArgs>
    ): CheckSelect<T, Prisma__ContractorsClient<Contractors>, Prisma__ContractorsClient<ContractorsGetPayload<T>>>

    /**
     * Delete zero or more Contractors.
     * @param {ContractorsDeleteManyArgs} args - Arguments to filter Contractors to delete.
     * @example
     * // Delete a few Contractors
     * const { count } = await prisma.contractors.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ContractorsDeleteManyArgs>(
      args?: SelectSubset<T, ContractorsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contractors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractorsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contractors
     * const contractors = await prisma.contractors.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ContractorsUpdateManyArgs>(
      args: SelectSubset<T, ContractorsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Contractors.
     * @param {ContractorsUpsertArgs} args - Arguments to update or create a Contractors.
     * @example
     * // Update or create a Contractors
     * const contractors = await prisma.contractors.upsert({
     *   create: {
     *     // ... data to create a Contractors
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contractors we want to update
     *   }
     * })
    **/
    upsert<T extends ContractorsUpsertArgs>(
      args: SelectSubset<T, ContractorsUpsertArgs>
    ): CheckSelect<T, Prisma__ContractorsClient<Contractors>, Prisma__ContractorsClient<ContractorsGetPayload<T>>>

    /**
     * Count the number of Contractors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractorsCountArgs} args - Arguments to filter Contractors to count.
     * @example
     * // Count the number of Contractors
     * const count = await prisma.contractors.count({
     *   where: {
     *     // ... the filter for the Contractors we want to count
     *   }
     * })
    **/
    count<T extends ContractorsCountArgs>(
      args?: Subset<T, ContractorsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContractorsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contractors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractorsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContractorsAggregateArgs>(args: Subset<T, ContractorsAggregateArgs>): PrismaPromise<GetContractorsAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for Contractors.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ContractorsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Users<T extends UsersArgs = {}>(args?: Subset<T, UsersArgs>): CheckSelect<T, Prisma__UsersClient<Users | null >, Prisma__UsersClient<UsersGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Contractors findUnique
   */
  export type ContractorsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Contractors
    **/
    select?: ContractorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ContractorsInclude | null
    /**
     * Throw an Error if a Contractors can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Contractors to fetch.
    **/
    where: ContractorsWhereUniqueInput
  }


  /**
   * Contractors findFirst
   */
  export type ContractorsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Contractors
    **/
    select?: ContractorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ContractorsInclude | null
    /**
     * Throw an Error if a Contractors can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Contractors to fetch.
    **/
    where?: ContractorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contractors to fetch.
    **/
    orderBy?: Enumerable<ContractorsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contractors.
    **/
    cursor?: ContractorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contractors from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contractors.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contractors.
    **/
    distinct?: Enumerable<ContractorsScalarFieldEnum>
  }


  /**
   * Contractors findMany
   */
  export type ContractorsFindManyArgs = {
    /**
     * Select specific fields to fetch from the Contractors
    **/
    select?: ContractorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ContractorsInclude | null
    /**
     * Filter, which Contractors to fetch.
    **/
    where?: ContractorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contractors to fetch.
    **/
    orderBy?: Enumerable<ContractorsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contractors.
    **/
    cursor?: ContractorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contractors from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contractors.
    **/
    skip?: number
    distinct?: Enumerable<ContractorsScalarFieldEnum>
  }


  /**
   * Contractors create
   */
  export type ContractorsCreateArgs = {
    /**
     * Select specific fields to fetch from the Contractors
    **/
    select?: ContractorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ContractorsInclude | null
    /**
     * The data needed to create a Contractors.
    **/
    data: XOR<ContractorsCreateInput, ContractorsUncheckedCreateInput>
  }


  /**
   * Contractors update
   */
  export type ContractorsUpdateArgs = {
    /**
     * Select specific fields to fetch from the Contractors
    **/
    select?: ContractorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ContractorsInclude | null
    /**
     * The data needed to update a Contractors.
    **/
    data: XOR<ContractorsUpdateInput, ContractorsUncheckedUpdateInput>
    /**
     * Choose, which Contractors to update.
    **/
    where: ContractorsWhereUniqueInput
  }


  /**
   * Contractors updateMany
   */
  export type ContractorsUpdateManyArgs = {
    data: XOR<ContractorsUpdateManyMutationInput, ContractorsUncheckedUpdateManyInput>
    where?: ContractorsWhereInput
  }


  /**
   * Contractors upsert
   */
  export type ContractorsUpsertArgs = {
    /**
     * Select specific fields to fetch from the Contractors
    **/
    select?: ContractorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ContractorsInclude | null
    /**
     * The filter to search for the Contractors to update in case it exists.
    **/
    where: ContractorsWhereUniqueInput
    /**
     * In case the Contractors found by the `where` argument doesn't exist, create a new Contractors with this data.
    **/
    create: XOR<ContractorsCreateInput, ContractorsUncheckedCreateInput>
    /**
     * In case the Contractors was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<ContractorsUpdateInput, ContractorsUncheckedUpdateInput>
  }


  /**
   * Contractors delete
   */
  export type ContractorsDeleteArgs = {
    /**
     * Select specific fields to fetch from the Contractors
    **/
    select?: ContractorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ContractorsInclude | null
    /**
     * Filter which Contractors to delete.
    **/
    where: ContractorsWhereUniqueInput
  }


  /**
   * Contractors deleteMany
   */
  export type ContractorsDeleteManyArgs = {
    where?: ContractorsWhereInput
  }


  /**
   * Contractors without action
   */
  export type ContractorsArgs = {
    /**
     * Select specific fields to fetch from the Contractors
    **/
    select?: ContractorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ContractorsInclude | null
  }



  /**
   * Model Countries
   */


  export type AggregateCountries = {
    count: CountriesCountAggregateOutputType | null
    avg: CountriesAvgAggregateOutputType | null
    sum: CountriesSumAggregateOutputType | null
    min: CountriesMinAggregateOutputType | null
    max: CountriesMaxAggregateOutputType | null
  }

  export type CountriesAvgAggregateOutputType = {
    id: number
    created_by: number | null
    updated_by: number | null
  }

  export type CountriesSumAggregateOutputType = {
    id: number
    created_by: number | null
    updated_by: number | null
  }

  export type CountriesMinAggregateOutputType = {
    id: number
    country_name: string | null
    country_code: string | null
    iso3: string | null
    phone_code: string | null
    status: boolean | null
    created_at: Date | null
    updated_at: Date | null
    created_by: number | null
    updated_by: number | null
  }

  export type CountriesMaxAggregateOutputType = {
    id: number
    country_name: string | null
    country_code: string | null
    iso3: string | null
    phone_code: string | null
    status: boolean | null
    created_at: Date | null
    updated_at: Date | null
    created_by: number | null
    updated_by: number | null
  }

  export type CountriesCountAggregateOutputType = {
    id: number
    country_name: number | null
    country_code: number | null
    iso3: number | null
    phone_code: number | null
    status: number | null
    created_at: number | null
    updated_at: number | null
    created_by: number | null
    updated_by: number | null
    _all: number
  }


  export type CountriesAvgAggregateInputType = {
    id?: true
    created_by?: true
    updated_by?: true
  }

  export type CountriesSumAggregateInputType = {
    id?: true
    created_by?: true
    updated_by?: true
  }

  export type CountriesMinAggregateInputType = {
    id?: true
    country_name?: true
    country_code?: true
    iso3?: true
    phone_code?: true
    status?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type CountriesMaxAggregateInputType = {
    id?: true
    country_name?: true
    country_code?: true
    iso3?: true
    phone_code?: true
    status?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type CountriesCountAggregateInputType = {
    id?: true
    country_name?: true
    country_code?: true
    iso3?: true
    phone_code?: true
    status?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
    _all?: true
  }

  export type CountriesAggregateArgs = {
    /**
     * Filter which Countries to aggregate.
    **/
    where?: CountriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
    **/
    orderBy?: Enumerable<CountriesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: CountriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Countries
    **/
    count?: true | CountriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: CountriesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: CountriesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: CountriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: CountriesMaxAggregateInputType
  }

  export type GetCountriesAggregateType<T extends CountriesAggregateArgs> = {
    [P in keyof T & keyof AggregateCountries]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCountries[P]>
      : GetScalarType<T[P], AggregateCountries[P]>
  }



  export type CountriesSelect = {
    id?: boolean
    country_name?: boolean
    country_code?: boolean
    iso3?: boolean
    phone_code?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    created_by?: boolean
    updated_by?: boolean
    States?: boolean | StatesFindManyArgs
  }

  export type CountriesInclude = {
    States?: boolean | StatesFindManyArgs
  }

  export type CountriesGetPayload<
    S extends boolean | null | undefined | CountriesArgs,
    U = keyof S
      > = S extends true
        ? Countries
    : S extends undefined
    ? never
    : S extends CountriesArgs | CountriesFindManyArgs
    ?'include' extends U
    ? Countries  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'States'
        ? Array < StatesGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Countries ?Countries [P]
  : 
          P extends 'States'
        ? Array < StatesGetPayload<S['select'][P]>>  : never
  } 
    : Countries
  : Countries


  type CountriesCountArgs = Merge<
    Omit<CountriesFindManyArgs, 'select' | 'include'> & {
      select?: CountriesCountAggregateInputType | true
    }
  >

  export interface CountriesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Countries that matches the filter.
     * @param {CountriesFindUniqueArgs} args - Arguments to find a Countries
     * @example
     * // Get one Countries
     * const countries = await prisma.countries.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CountriesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CountriesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Countries'> extends True ? CheckSelect<T, Prisma__CountriesClient<Countries>, Prisma__CountriesClient<CountriesGetPayload<T>>> : CheckSelect<T, Prisma__CountriesClient<Countries | null >, Prisma__CountriesClient<CountriesGetPayload<T> | null >>

    /**
     * Find the first Countries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountriesFindFirstArgs} args - Arguments to find a Countries
     * @example
     * // Get one Countries
     * const countries = await prisma.countries.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CountriesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CountriesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Countries'> extends True ? CheckSelect<T, Prisma__CountriesClient<Countries>, Prisma__CountriesClient<CountriesGetPayload<T>>> : CheckSelect<T, Prisma__CountriesClient<Countries | null >, Prisma__CountriesClient<CountriesGetPayload<T> | null >>

    /**
     * Find zero or more Countries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountriesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Countries
     * const countries = await prisma.countries.findMany()
     * 
     * // Get first 10 Countries
     * const countries = await prisma.countries.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const countriesWithIdOnly = await prisma.countries.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CountriesFindManyArgs>(
      args?: SelectSubset<T, CountriesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Countries>>, PrismaPromise<Array<CountriesGetPayload<T>>>>

    /**
     * Create a Countries.
     * @param {CountriesCreateArgs} args - Arguments to create a Countries.
     * @example
     * // Create one Countries
     * const Countries = await prisma.countries.create({
     *   data: {
     *     // ... data to create a Countries
     *   }
     * })
     * 
    **/
    create<T extends CountriesCreateArgs>(
      args: SelectSubset<T, CountriesCreateArgs>
    ): CheckSelect<T, Prisma__CountriesClient<Countries>, Prisma__CountriesClient<CountriesGetPayload<T>>>

    /**
     * Delete a Countries.
     * @param {CountriesDeleteArgs} args - Arguments to delete one Countries.
     * @example
     * // Delete one Countries
     * const Countries = await prisma.countries.delete({
     *   where: {
     *     // ... filter to delete one Countries
     *   }
     * })
     * 
    **/
    delete<T extends CountriesDeleteArgs>(
      args: SelectSubset<T, CountriesDeleteArgs>
    ): CheckSelect<T, Prisma__CountriesClient<Countries>, Prisma__CountriesClient<CountriesGetPayload<T>>>

    /**
     * Update one Countries.
     * @param {CountriesUpdateArgs} args - Arguments to update one Countries.
     * @example
     * // Update one Countries
     * const countries = await prisma.countries.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CountriesUpdateArgs>(
      args: SelectSubset<T, CountriesUpdateArgs>
    ): CheckSelect<T, Prisma__CountriesClient<Countries>, Prisma__CountriesClient<CountriesGetPayload<T>>>

    /**
     * Delete zero or more Countries.
     * @param {CountriesDeleteManyArgs} args - Arguments to filter Countries to delete.
     * @example
     * // Delete a few Countries
     * const { count } = await prisma.countries.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CountriesDeleteManyArgs>(
      args?: SelectSubset<T, CountriesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Countries
     * const countries = await prisma.countries.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CountriesUpdateManyArgs>(
      args: SelectSubset<T, CountriesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Countries.
     * @param {CountriesUpsertArgs} args - Arguments to update or create a Countries.
     * @example
     * // Update or create a Countries
     * const countries = await prisma.countries.upsert({
     *   create: {
     *     // ... data to create a Countries
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Countries we want to update
     *   }
     * })
    **/
    upsert<T extends CountriesUpsertArgs>(
      args: SelectSubset<T, CountriesUpsertArgs>
    ): CheckSelect<T, Prisma__CountriesClient<Countries>, Prisma__CountriesClient<CountriesGetPayload<T>>>

    /**
     * Count the number of Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountriesCountArgs} args - Arguments to filter Countries to count.
     * @example
     * // Count the number of Countries
     * const count = await prisma.countries.count({
     *   where: {
     *     // ... the filter for the Countries we want to count
     *   }
     * })
    **/
    count<T extends CountriesCountArgs>(
      args?: Subset<T, CountriesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CountriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CountriesAggregateArgs>(args: Subset<T, CountriesAggregateArgs>): PrismaPromise<GetCountriesAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for Countries.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CountriesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    States<T extends StatesFindManyArgs = {}>(args?: Subset<T, StatesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<States>>, PrismaPromise<Array<StatesGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Countries findUnique
   */
  export type CountriesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Countries
    **/
    select?: CountriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CountriesInclude | null
    /**
     * Throw an Error if a Countries can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Countries to fetch.
    **/
    where: CountriesWhereUniqueInput
  }


  /**
   * Countries findFirst
   */
  export type CountriesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Countries
    **/
    select?: CountriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CountriesInclude | null
    /**
     * Throw an Error if a Countries can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Countries to fetch.
    **/
    where?: CountriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
    **/
    orderBy?: Enumerable<CountriesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Countries.
    **/
    cursor?: CountriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Countries.
    **/
    distinct?: Enumerable<CountriesScalarFieldEnum>
  }


  /**
   * Countries findMany
   */
  export type CountriesFindManyArgs = {
    /**
     * Select specific fields to fetch from the Countries
    **/
    select?: CountriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CountriesInclude | null
    /**
     * Filter, which Countries to fetch.
    **/
    where?: CountriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
    **/
    orderBy?: Enumerable<CountriesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Countries.
    **/
    cursor?: CountriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
    **/
    skip?: number
    distinct?: Enumerable<CountriesScalarFieldEnum>
  }


  /**
   * Countries create
   */
  export type CountriesCreateArgs = {
    /**
     * Select specific fields to fetch from the Countries
    **/
    select?: CountriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CountriesInclude | null
    /**
     * The data needed to create a Countries.
    **/
    data: XOR<CountriesCreateInput, CountriesUncheckedCreateInput>
  }


  /**
   * Countries update
   */
  export type CountriesUpdateArgs = {
    /**
     * Select specific fields to fetch from the Countries
    **/
    select?: CountriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CountriesInclude | null
    /**
     * The data needed to update a Countries.
    **/
    data: XOR<CountriesUpdateInput, CountriesUncheckedUpdateInput>
    /**
     * Choose, which Countries to update.
    **/
    where: CountriesWhereUniqueInput
  }


  /**
   * Countries updateMany
   */
  export type CountriesUpdateManyArgs = {
    data: XOR<CountriesUpdateManyMutationInput, CountriesUncheckedUpdateManyInput>
    where?: CountriesWhereInput
  }


  /**
   * Countries upsert
   */
  export type CountriesUpsertArgs = {
    /**
     * Select specific fields to fetch from the Countries
    **/
    select?: CountriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CountriesInclude | null
    /**
     * The filter to search for the Countries to update in case it exists.
    **/
    where: CountriesWhereUniqueInput
    /**
     * In case the Countries found by the `where` argument doesn't exist, create a new Countries with this data.
    **/
    create: XOR<CountriesCreateInput, CountriesUncheckedCreateInput>
    /**
     * In case the Countries was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<CountriesUpdateInput, CountriesUncheckedUpdateInput>
  }


  /**
   * Countries delete
   */
  export type CountriesDeleteArgs = {
    /**
     * Select specific fields to fetch from the Countries
    **/
    select?: CountriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CountriesInclude | null
    /**
     * Filter which Countries to delete.
    **/
    where: CountriesWhereUniqueInput
  }


  /**
   * Countries deleteMany
   */
  export type CountriesDeleteManyArgs = {
    where?: CountriesWhereInput
  }


  /**
   * Countries without action
   */
  export type CountriesArgs = {
    /**
     * Select specific fields to fetch from the Countries
    **/
    select?: CountriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CountriesInclude | null
  }



  /**
   * Model ProductAttributeUnits
   */


  export type AggregateProductAttributeUnits = {
    count: ProductAttributeUnitsCountAggregateOutputType | null
    avg: ProductAttributeUnitsAvgAggregateOutputType | null
    sum: ProductAttributeUnitsSumAggregateOutputType | null
    min: ProductAttributeUnitsMinAggregateOutputType | null
    max: ProductAttributeUnitsMaxAggregateOutputType | null
  }

  export type ProductAttributeUnitsAvgAggregateOutputType = {
    id: number
    product_id: number
    attribute_id: number
    attribute_unit_id: number
    display_order: number | null
    created_by: number | null
    updated_by: number | null
  }

  export type ProductAttributeUnitsSumAggregateOutputType = {
    id: number
    product_id: number
    attribute_id: number
    attribute_unit_id: number
    display_order: number | null
    created_by: number | null
    updated_by: number | null
  }

  export type ProductAttributeUnitsMinAggregateOutputType = {
    id: number
    name: string | null
    product_id: number
    attribute_id: number
    attribute_unit_id: number
    html_element_type: string | null
    display_order: number | null
    created_at: Date | null
    updated_at: Date | null
    created_by: number | null
    updated_by: number | null
  }

  export type ProductAttributeUnitsMaxAggregateOutputType = {
    id: number
    name: string | null
    product_id: number
    attribute_id: number
    attribute_unit_id: number
    html_element_type: string | null
    display_order: number | null
    created_at: Date | null
    updated_at: Date | null
    created_by: number | null
    updated_by: number | null
  }

  export type ProductAttributeUnitsCountAggregateOutputType = {
    id: number
    name: number | null
    product_id: number
    attribute_id: number
    attribute_unit_id: number
    html_element_type: number | null
    display_order: number | null
    created_at: number | null
    updated_at: number | null
    created_by: number | null
    updated_by: number | null
    _all: number
  }


  export type ProductAttributeUnitsAvgAggregateInputType = {
    id?: true
    product_id?: true
    attribute_id?: true
    attribute_unit_id?: true
    display_order?: true
    created_by?: true
    updated_by?: true
  }

  export type ProductAttributeUnitsSumAggregateInputType = {
    id?: true
    product_id?: true
    attribute_id?: true
    attribute_unit_id?: true
    display_order?: true
    created_by?: true
    updated_by?: true
  }

  export type ProductAttributeUnitsMinAggregateInputType = {
    id?: true
    name?: true
    product_id?: true
    attribute_id?: true
    attribute_unit_id?: true
    html_element_type?: true
    display_order?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type ProductAttributeUnitsMaxAggregateInputType = {
    id?: true
    name?: true
    product_id?: true
    attribute_id?: true
    attribute_unit_id?: true
    html_element_type?: true
    display_order?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type ProductAttributeUnitsCountAggregateInputType = {
    id?: true
    name?: true
    product_id?: true
    attribute_id?: true
    attribute_unit_id?: true
    html_element_type?: true
    display_order?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
    _all?: true
  }

  export type ProductAttributeUnitsAggregateArgs = {
    /**
     * Filter which ProductAttributeUnits to aggregate.
    **/
    where?: ProductAttributeUnitsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductAttributeUnits to fetch.
    **/
    orderBy?: Enumerable<ProductAttributeUnitsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: ProductAttributeUnitsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductAttributeUnits from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductAttributeUnits.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductAttributeUnits
    **/
    count?: true | ProductAttributeUnitsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: ProductAttributeUnitsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: ProductAttributeUnitsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: ProductAttributeUnitsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: ProductAttributeUnitsMaxAggregateInputType
  }

  export type GetProductAttributeUnitsAggregateType<T extends ProductAttributeUnitsAggregateArgs> = {
    [P in keyof T & keyof AggregateProductAttributeUnits]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductAttributeUnits[P]>
      : GetScalarType<T[P], AggregateProductAttributeUnits[P]>
  }



  export type ProductAttributeUnitsSelect = {
    id?: boolean
    name?: boolean
    product_id?: boolean
    attribute_id?: boolean
    attribute_unit_id?: boolean
    html_element_type?: boolean
    display_order?: boolean
    created_at?: boolean
    updated_at?: boolean
    created_by?: boolean
    updated_by?: boolean
    Attributes?: boolean | AttributesArgs
    AttributeUnits?: boolean | AttributeUnitsArgs
    Products?: boolean | ProductsArgs
    ProductAttributeUnitValues?: boolean | ProductAttributeUnitValuesFindManyArgs
    ScopeOfWorks?: boolean | ScopeOfWorksFindManyArgs
  }

  export type ProductAttributeUnitsInclude = {
    Attributes?: boolean | AttributesArgs
    AttributeUnits?: boolean | AttributeUnitsArgs
    Products?: boolean | ProductsArgs
    ProductAttributeUnitValues?: boolean | ProductAttributeUnitValuesFindManyArgs
    ScopeOfWorks?: boolean | ScopeOfWorksFindManyArgs
  }

  export type ProductAttributeUnitsGetPayload<
    S extends boolean | null | undefined | ProductAttributeUnitsArgs,
    U = keyof S
      > = S extends true
        ? ProductAttributeUnits
    : S extends undefined
    ? never
    : S extends ProductAttributeUnitsArgs | ProductAttributeUnitsFindManyArgs
    ?'include' extends U
    ? ProductAttributeUnits  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'Attributes'
        ? AttributesGetPayload<S['include'][P]> :
        P extends 'AttributeUnits'
        ? AttributeUnitsGetPayload<S['include'][P]> :
        P extends 'Products'
        ? ProductsGetPayload<S['include'][P]> :
        P extends 'ProductAttributeUnitValues'
        ? Array < ProductAttributeUnitValuesGetPayload<S['include'][P]>>  :
        P extends 'ScopeOfWorks'
        ? Array < ScopeOfWorksGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof ProductAttributeUnits ?ProductAttributeUnits [P]
  : 
          P extends 'Attributes'
        ? AttributesGetPayload<S['select'][P]> :
        P extends 'AttributeUnits'
        ? AttributeUnitsGetPayload<S['select'][P]> :
        P extends 'Products'
        ? ProductsGetPayload<S['select'][P]> :
        P extends 'ProductAttributeUnitValues'
        ? Array < ProductAttributeUnitValuesGetPayload<S['select'][P]>>  :
        P extends 'ScopeOfWorks'
        ? Array < ScopeOfWorksGetPayload<S['select'][P]>>  : never
  } 
    : ProductAttributeUnits
  : ProductAttributeUnits


  type ProductAttributeUnitsCountArgs = Merge<
    Omit<ProductAttributeUnitsFindManyArgs, 'select' | 'include'> & {
      select?: ProductAttributeUnitsCountAggregateInputType | true
    }
  >

  export interface ProductAttributeUnitsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one ProductAttributeUnits that matches the filter.
     * @param {ProductAttributeUnitsFindUniqueArgs} args - Arguments to find a ProductAttributeUnits
     * @example
     * // Get one ProductAttributeUnits
     * const productAttributeUnits = await prisma.productAttributeUnits.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductAttributeUnitsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProductAttributeUnitsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ProductAttributeUnits'> extends True ? CheckSelect<T, Prisma__ProductAttributeUnitsClient<ProductAttributeUnits>, Prisma__ProductAttributeUnitsClient<ProductAttributeUnitsGetPayload<T>>> : CheckSelect<T, Prisma__ProductAttributeUnitsClient<ProductAttributeUnits | null >, Prisma__ProductAttributeUnitsClient<ProductAttributeUnitsGetPayload<T> | null >>

    /**
     * Find the first ProductAttributeUnits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAttributeUnitsFindFirstArgs} args - Arguments to find a ProductAttributeUnits
     * @example
     * // Get one ProductAttributeUnits
     * const productAttributeUnits = await prisma.productAttributeUnits.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductAttributeUnitsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProductAttributeUnitsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ProductAttributeUnits'> extends True ? CheckSelect<T, Prisma__ProductAttributeUnitsClient<ProductAttributeUnits>, Prisma__ProductAttributeUnitsClient<ProductAttributeUnitsGetPayload<T>>> : CheckSelect<T, Prisma__ProductAttributeUnitsClient<ProductAttributeUnits | null >, Prisma__ProductAttributeUnitsClient<ProductAttributeUnitsGetPayload<T> | null >>

    /**
     * Find zero or more ProductAttributeUnits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAttributeUnitsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductAttributeUnits
     * const productAttributeUnits = await prisma.productAttributeUnits.findMany()
     * 
     * // Get first 10 ProductAttributeUnits
     * const productAttributeUnits = await prisma.productAttributeUnits.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productAttributeUnitsWithIdOnly = await prisma.productAttributeUnits.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductAttributeUnitsFindManyArgs>(
      args?: SelectSubset<T, ProductAttributeUnitsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ProductAttributeUnits>>, PrismaPromise<Array<ProductAttributeUnitsGetPayload<T>>>>

    /**
     * Create a ProductAttributeUnits.
     * @param {ProductAttributeUnitsCreateArgs} args - Arguments to create a ProductAttributeUnits.
     * @example
     * // Create one ProductAttributeUnits
     * const ProductAttributeUnits = await prisma.productAttributeUnits.create({
     *   data: {
     *     // ... data to create a ProductAttributeUnits
     *   }
     * })
     * 
    **/
    create<T extends ProductAttributeUnitsCreateArgs>(
      args: SelectSubset<T, ProductAttributeUnitsCreateArgs>
    ): CheckSelect<T, Prisma__ProductAttributeUnitsClient<ProductAttributeUnits>, Prisma__ProductAttributeUnitsClient<ProductAttributeUnitsGetPayload<T>>>

    /**
     * Delete a ProductAttributeUnits.
     * @param {ProductAttributeUnitsDeleteArgs} args - Arguments to delete one ProductAttributeUnits.
     * @example
     * // Delete one ProductAttributeUnits
     * const ProductAttributeUnits = await prisma.productAttributeUnits.delete({
     *   where: {
     *     // ... filter to delete one ProductAttributeUnits
     *   }
     * })
     * 
    **/
    delete<T extends ProductAttributeUnitsDeleteArgs>(
      args: SelectSubset<T, ProductAttributeUnitsDeleteArgs>
    ): CheckSelect<T, Prisma__ProductAttributeUnitsClient<ProductAttributeUnits>, Prisma__ProductAttributeUnitsClient<ProductAttributeUnitsGetPayload<T>>>

    /**
     * Update one ProductAttributeUnits.
     * @param {ProductAttributeUnitsUpdateArgs} args - Arguments to update one ProductAttributeUnits.
     * @example
     * // Update one ProductAttributeUnits
     * const productAttributeUnits = await prisma.productAttributeUnits.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductAttributeUnitsUpdateArgs>(
      args: SelectSubset<T, ProductAttributeUnitsUpdateArgs>
    ): CheckSelect<T, Prisma__ProductAttributeUnitsClient<ProductAttributeUnits>, Prisma__ProductAttributeUnitsClient<ProductAttributeUnitsGetPayload<T>>>

    /**
     * Delete zero or more ProductAttributeUnits.
     * @param {ProductAttributeUnitsDeleteManyArgs} args - Arguments to filter ProductAttributeUnits to delete.
     * @example
     * // Delete a few ProductAttributeUnits
     * const { count } = await prisma.productAttributeUnits.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductAttributeUnitsDeleteManyArgs>(
      args?: SelectSubset<T, ProductAttributeUnitsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductAttributeUnits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAttributeUnitsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductAttributeUnits
     * const productAttributeUnits = await prisma.productAttributeUnits.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductAttributeUnitsUpdateManyArgs>(
      args: SelectSubset<T, ProductAttributeUnitsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductAttributeUnits.
     * @param {ProductAttributeUnitsUpsertArgs} args - Arguments to update or create a ProductAttributeUnits.
     * @example
     * // Update or create a ProductAttributeUnits
     * const productAttributeUnits = await prisma.productAttributeUnits.upsert({
     *   create: {
     *     // ... data to create a ProductAttributeUnits
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductAttributeUnits we want to update
     *   }
     * })
    **/
    upsert<T extends ProductAttributeUnitsUpsertArgs>(
      args: SelectSubset<T, ProductAttributeUnitsUpsertArgs>
    ): CheckSelect<T, Prisma__ProductAttributeUnitsClient<ProductAttributeUnits>, Prisma__ProductAttributeUnitsClient<ProductAttributeUnitsGetPayload<T>>>

    /**
     * Count the number of ProductAttributeUnits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAttributeUnitsCountArgs} args - Arguments to filter ProductAttributeUnits to count.
     * @example
     * // Count the number of ProductAttributeUnits
     * const count = await prisma.productAttributeUnits.count({
     *   where: {
     *     // ... the filter for the ProductAttributeUnits we want to count
     *   }
     * })
    **/
    count<T extends ProductAttributeUnitsCountArgs>(
      args?: Subset<T, ProductAttributeUnitsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductAttributeUnitsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductAttributeUnits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAttributeUnitsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAttributeUnitsAggregateArgs>(args: Subset<T, ProductAttributeUnitsAggregateArgs>): PrismaPromise<GetProductAttributeUnitsAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductAttributeUnits.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProductAttributeUnitsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Attributes<T extends AttributesArgs = {}>(args?: Subset<T, AttributesArgs>): CheckSelect<T, Prisma__AttributesClient<Attributes | null >, Prisma__AttributesClient<AttributesGetPayload<T> | null >>;

    AttributeUnits<T extends AttributeUnitsArgs = {}>(args?: Subset<T, AttributeUnitsArgs>): CheckSelect<T, Prisma__AttributeUnitsClient<AttributeUnits | null >, Prisma__AttributeUnitsClient<AttributeUnitsGetPayload<T> | null >>;

    Products<T extends ProductsArgs = {}>(args?: Subset<T, ProductsArgs>): CheckSelect<T, Prisma__ProductsClient<Products | null >, Prisma__ProductsClient<ProductsGetPayload<T> | null >>;

    ProductAttributeUnitValues<T extends ProductAttributeUnitValuesFindManyArgs = {}>(args?: Subset<T, ProductAttributeUnitValuesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ProductAttributeUnitValues>>, PrismaPromise<Array<ProductAttributeUnitValuesGetPayload<T>>>>;

    ScopeOfWorks<T extends ScopeOfWorksFindManyArgs = {}>(args?: Subset<T, ScopeOfWorksFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ScopeOfWorks>>, PrismaPromise<Array<ScopeOfWorksGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * ProductAttributeUnits findUnique
   */
  export type ProductAttributeUnitsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the ProductAttributeUnits
    **/
    select?: ProductAttributeUnitsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProductAttributeUnitsInclude | null
    /**
     * Throw an Error if a ProductAttributeUnits can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ProductAttributeUnits to fetch.
    **/
    where: ProductAttributeUnitsWhereUniqueInput
  }


  /**
   * ProductAttributeUnits findFirst
   */
  export type ProductAttributeUnitsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the ProductAttributeUnits
    **/
    select?: ProductAttributeUnitsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProductAttributeUnitsInclude | null
    /**
     * Throw an Error if a ProductAttributeUnits can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ProductAttributeUnits to fetch.
    **/
    where?: ProductAttributeUnitsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductAttributeUnits to fetch.
    **/
    orderBy?: Enumerable<ProductAttributeUnitsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductAttributeUnits.
    **/
    cursor?: ProductAttributeUnitsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductAttributeUnits from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductAttributeUnits.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductAttributeUnits.
    **/
    distinct?: Enumerable<ProductAttributeUnitsScalarFieldEnum>
  }


  /**
   * ProductAttributeUnits findMany
   */
  export type ProductAttributeUnitsFindManyArgs = {
    /**
     * Select specific fields to fetch from the ProductAttributeUnits
    **/
    select?: ProductAttributeUnitsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProductAttributeUnitsInclude | null
    /**
     * Filter, which ProductAttributeUnits to fetch.
    **/
    where?: ProductAttributeUnitsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductAttributeUnits to fetch.
    **/
    orderBy?: Enumerable<ProductAttributeUnitsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductAttributeUnits.
    **/
    cursor?: ProductAttributeUnitsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductAttributeUnits from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductAttributeUnits.
    **/
    skip?: number
    distinct?: Enumerable<ProductAttributeUnitsScalarFieldEnum>
  }


  /**
   * ProductAttributeUnits create
   */
  export type ProductAttributeUnitsCreateArgs = {
    /**
     * Select specific fields to fetch from the ProductAttributeUnits
    **/
    select?: ProductAttributeUnitsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProductAttributeUnitsInclude | null
    /**
     * The data needed to create a ProductAttributeUnits.
    **/
    data: XOR<ProductAttributeUnitsCreateInput, ProductAttributeUnitsUncheckedCreateInput>
  }


  /**
   * ProductAttributeUnits update
   */
  export type ProductAttributeUnitsUpdateArgs = {
    /**
     * Select specific fields to fetch from the ProductAttributeUnits
    **/
    select?: ProductAttributeUnitsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProductAttributeUnitsInclude | null
    /**
     * The data needed to update a ProductAttributeUnits.
    **/
    data: XOR<ProductAttributeUnitsUpdateInput, ProductAttributeUnitsUncheckedUpdateInput>
    /**
     * Choose, which ProductAttributeUnits to update.
    **/
    where: ProductAttributeUnitsWhereUniqueInput
  }


  /**
   * ProductAttributeUnits updateMany
   */
  export type ProductAttributeUnitsUpdateManyArgs = {
    data: XOR<ProductAttributeUnitsUpdateManyMutationInput, ProductAttributeUnitsUncheckedUpdateManyInput>
    where?: ProductAttributeUnitsWhereInput
  }


  /**
   * ProductAttributeUnits upsert
   */
  export type ProductAttributeUnitsUpsertArgs = {
    /**
     * Select specific fields to fetch from the ProductAttributeUnits
    **/
    select?: ProductAttributeUnitsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProductAttributeUnitsInclude | null
    /**
     * The filter to search for the ProductAttributeUnits to update in case it exists.
    **/
    where: ProductAttributeUnitsWhereUniqueInput
    /**
     * In case the ProductAttributeUnits found by the `where` argument doesn't exist, create a new ProductAttributeUnits with this data.
    **/
    create: XOR<ProductAttributeUnitsCreateInput, ProductAttributeUnitsUncheckedCreateInput>
    /**
     * In case the ProductAttributeUnits was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<ProductAttributeUnitsUpdateInput, ProductAttributeUnitsUncheckedUpdateInput>
  }


  /**
   * ProductAttributeUnits delete
   */
  export type ProductAttributeUnitsDeleteArgs = {
    /**
     * Select specific fields to fetch from the ProductAttributeUnits
    **/
    select?: ProductAttributeUnitsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProductAttributeUnitsInclude | null
    /**
     * Filter which ProductAttributeUnits to delete.
    **/
    where: ProductAttributeUnitsWhereUniqueInput
  }


  /**
   * ProductAttributeUnits deleteMany
   */
  export type ProductAttributeUnitsDeleteManyArgs = {
    where?: ProductAttributeUnitsWhereInput
  }


  /**
   * ProductAttributeUnits without action
   */
  export type ProductAttributeUnitsArgs = {
    /**
     * Select specific fields to fetch from the ProductAttributeUnits
    **/
    select?: ProductAttributeUnitsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProductAttributeUnitsInclude | null
  }



  /**
   * Model ProductAttributeUnitValues
   */


  export type AggregateProductAttributeUnitValues = {
    count: ProductAttributeUnitValuesCountAggregateOutputType | null
    avg: ProductAttributeUnitValuesAvgAggregateOutputType | null
    sum: ProductAttributeUnitValuesSumAggregateOutputType | null
    min: ProductAttributeUnitValuesMinAggregateOutputType | null
    max: ProductAttributeUnitValuesMaxAggregateOutputType | null
  }

  export type ProductAttributeUnitValuesAvgAggregateOutputType = {
    id: number
    product_attribute_unit_id: number
    created_by: number | null
    updated_by: number | null
  }

  export type ProductAttributeUnitValuesSumAggregateOutputType = {
    id: number
    product_attribute_unit_id: number
    created_by: number | null
    updated_by: number | null
  }

  export type ProductAttributeUnitValuesMinAggregateOutputType = {
    id: number
    value: string | null
    slug: string | null
    product_attribute_unit_id: number
    custom: boolean | null
    custom_html_element_type: string | null
    is_default: boolean | null
    created_at: Date | null
    updated_at: Date | null
    created_by: number | null
    updated_by: number | null
  }

  export type ProductAttributeUnitValuesMaxAggregateOutputType = {
    id: number
    value: string | null
    slug: string | null
    product_attribute_unit_id: number
    custom: boolean | null
    custom_html_element_type: string | null
    is_default: boolean | null
    created_at: Date | null
    updated_at: Date | null
    created_by: number | null
    updated_by: number | null
  }

  export type ProductAttributeUnitValuesCountAggregateOutputType = {
    id: number
    value: number | null
    slug: number | null
    product_attribute_unit_id: number
    custom: number | null
    custom_html_element_type: number | null
    is_default: number | null
    created_at: number | null
    updated_at: number | null
    created_by: number | null
    updated_by: number | null
    _all: number
  }


  export type ProductAttributeUnitValuesAvgAggregateInputType = {
    id?: true
    product_attribute_unit_id?: true
    created_by?: true
    updated_by?: true
  }

  export type ProductAttributeUnitValuesSumAggregateInputType = {
    id?: true
    product_attribute_unit_id?: true
    created_by?: true
    updated_by?: true
  }

  export type ProductAttributeUnitValuesMinAggregateInputType = {
    id?: true
    value?: true
    slug?: true
    product_attribute_unit_id?: true
    custom?: true
    custom_html_element_type?: true
    is_default?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type ProductAttributeUnitValuesMaxAggregateInputType = {
    id?: true
    value?: true
    slug?: true
    product_attribute_unit_id?: true
    custom?: true
    custom_html_element_type?: true
    is_default?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type ProductAttributeUnitValuesCountAggregateInputType = {
    id?: true
    value?: true
    slug?: true
    product_attribute_unit_id?: true
    custom?: true
    custom_html_element_type?: true
    is_default?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
    _all?: true
  }

  export type ProductAttributeUnitValuesAggregateArgs = {
    /**
     * Filter which ProductAttributeUnitValues to aggregate.
    **/
    where?: ProductAttributeUnitValuesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductAttributeUnitValues to fetch.
    **/
    orderBy?: Enumerable<ProductAttributeUnitValuesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: ProductAttributeUnitValuesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductAttributeUnitValues from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductAttributeUnitValues.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductAttributeUnitValues
    **/
    count?: true | ProductAttributeUnitValuesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: ProductAttributeUnitValuesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: ProductAttributeUnitValuesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: ProductAttributeUnitValuesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: ProductAttributeUnitValuesMaxAggregateInputType
  }

  export type GetProductAttributeUnitValuesAggregateType<T extends ProductAttributeUnitValuesAggregateArgs> = {
    [P in keyof T & keyof AggregateProductAttributeUnitValues]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductAttributeUnitValues[P]>
      : GetScalarType<T[P], AggregateProductAttributeUnitValues[P]>
  }



  export type ProductAttributeUnitValuesSelect = {
    id?: boolean
    value?: boolean
    slug?: boolean
    product_attribute_unit_id?: boolean
    custom?: boolean
    custom_html_element_type?: boolean
    is_default?: boolean
    created_at?: boolean
    updated_at?: boolean
    created_by?: boolean
    updated_by?: boolean
    ProductAttributeUnits?: boolean | ProductAttributeUnitsArgs
    ScopeOfWorks?: boolean | ScopeOfWorksFindManyArgs
  }

  export type ProductAttributeUnitValuesInclude = {
    ProductAttributeUnits?: boolean | ProductAttributeUnitsArgs
    ScopeOfWorks?: boolean | ScopeOfWorksFindManyArgs
  }

  export type ProductAttributeUnitValuesGetPayload<
    S extends boolean | null | undefined | ProductAttributeUnitValuesArgs,
    U = keyof S
      > = S extends true
        ? ProductAttributeUnitValues
    : S extends undefined
    ? never
    : S extends ProductAttributeUnitValuesArgs | ProductAttributeUnitValuesFindManyArgs
    ?'include' extends U
    ? ProductAttributeUnitValues  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'ProductAttributeUnits'
        ? ProductAttributeUnitsGetPayload<S['include'][P]> :
        P extends 'ScopeOfWorks'
        ? Array < ScopeOfWorksGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof ProductAttributeUnitValues ?ProductAttributeUnitValues [P]
  : 
          P extends 'ProductAttributeUnits'
        ? ProductAttributeUnitsGetPayload<S['select'][P]> :
        P extends 'ScopeOfWorks'
        ? Array < ScopeOfWorksGetPayload<S['select'][P]>>  : never
  } 
    : ProductAttributeUnitValues
  : ProductAttributeUnitValues


  type ProductAttributeUnitValuesCountArgs = Merge<
    Omit<ProductAttributeUnitValuesFindManyArgs, 'select' | 'include'> & {
      select?: ProductAttributeUnitValuesCountAggregateInputType | true
    }
  >

  export interface ProductAttributeUnitValuesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one ProductAttributeUnitValues that matches the filter.
     * @param {ProductAttributeUnitValuesFindUniqueArgs} args - Arguments to find a ProductAttributeUnitValues
     * @example
     * // Get one ProductAttributeUnitValues
     * const productAttributeUnitValues = await prisma.productAttributeUnitValues.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductAttributeUnitValuesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProductAttributeUnitValuesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ProductAttributeUnitValues'> extends True ? CheckSelect<T, Prisma__ProductAttributeUnitValuesClient<ProductAttributeUnitValues>, Prisma__ProductAttributeUnitValuesClient<ProductAttributeUnitValuesGetPayload<T>>> : CheckSelect<T, Prisma__ProductAttributeUnitValuesClient<ProductAttributeUnitValues | null >, Prisma__ProductAttributeUnitValuesClient<ProductAttributeUnitValuesGetPayload<T> | null >>

    /**
     * Find the first ProductAttributeUnitValues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAttributeUnitValuesFindFirstArgs} args - Arguments to find a ProductAttributeUnitValues
     * @example
     * // Get one ProductAttributeUnitValues
     * const productAttributeUnitValues = await prisma.productAttributeUnitValues.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductAttributeUnitValuesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProductAttributeUnitValuesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ProductAttributeUnitValues'> extends True ? CheckSelect<T, Prisma__ProductAttributeUnitValuesClient<ProductAttributeUnitValues>, Prisma__ProductAttributeUnitValuesClient<ProductAttributeUnitValuesGetPayload<T>>> : CheckSelect<T, Prisma__ProductAttributeUnitValuesClient<ProductAttributeUnitValues | null >, Prisma__ProductAttributeUnitValuesClient<ProductAttributeUnitValuesGetPayload<T> | null >>

    /**
     * Find zero or more ProductAttributeUnitValues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAttributeUnitValuesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductAttributeUnitValues
     * const productAttributeUnitValues = await prisma.productAttributeUnitValues.findMany()
     * 
     * // Get first 10 ProductAttributeUnitValues
     * const productAttributeUnitValues = await prisma.productAttributeUnitValues.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productAttributeUnitValuesWithIdOnly = await prisma.productAttributeUnitValues.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductAttributeUnitValuesFindManyArgs>(
      args?: SelectSubset<T, ProductAttributeUnitValuesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ProductAttributeUnitValues>>, PrismaPromise<Array<ProductAttributeUnitValuesGetPayload<T>>>>

    /**
     * Create a ProductAttributeUnitValues.
     * @param {ProductAttributeUnitValuesCreateArgs} args - Arguments to create a ProductAttributeUnitValues.
     * @example
     * // Create one ProductAttributeUnitValues
     * const ProductAttributeUnitValues = await prisma.productAttributeUnitValues.create({
     *   data: {
     *     // ... data to create a ProductAttributeUnitValues
     *   }
     * })
     * 
    **/
    create<T extends ProductAttributeUnitValuesCreateArgs>(
      args: SelectSubset<T, ProductAttributeUnitValuesCreateArgs>
    ): CheckSelect<T, Prisma__ProductAttributeUnitValuesClient<ProductAttributeUnitValues>, Prisma__ProductAttributeUnitValuesClient<ProductAttributeUnitValuesGetPayload<T>>>

    /**
     * Delete a ProductAttributeUnitValues.
     * @param {ProductAttributeUnitValuesDeleteArgs} args - Arguments to delete one ProductAttributeUnitValues.
     * @example
     * // Delete one ProductAttributeUnitValues
     * const ProductAttributeUnitValues = await prisma.productAttributeUnitValues.delete({
     *   where: {
     *     // ... filter to delete one ProductAttributeUnitValues
     *   }
     * })
     * 
    **/
    delete<T extends ProductAttributeUnitValuesDeleteArgs>(
      args: SelectSubset<T, ProductAttributeUnitValuesDeleteArgs>
    ): CheckSelect<T, Prisma__ProductAttributeUnitValuesClient<ProductAttributeUnitValues>, Prisma__ProductAttributeUnitValuesClient<ProductAttributeUnitValuesGetPayload<T>>>

    /**
     * Update one ProductAttributeUnitValues.
     * @param {ProductAttributeUnitValuesUpdateArgs} args - Arguments to update one ProductAttributeUnitValues.
     * @example
     * // Update one ProductAttributeUnitValues
     * const productAttributeUnitValues = await prisma.productAttributeUnitValues.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductAttributeUnitValuesUpdateArgs>(
      args: SelectSubset<T, ProductAttributeUnitValuesUpdateArgs>
    ): CheckSelect<T, Prisma__ProductAttributeUnitValuesClient<ProductAttributeUnitValues>, Prisma__ProductAttributeUnitValuesClient<ProductAttributeUnitValuesGetPayload<T>>>

    /**
     * Delete zero or more ProductAttributeUnitValues.
     * @param {ProductAttributeUnitValuesDeleteManyArgs} args - Arguments to filter ProductAttributeUnitValues to delete.
     * @example
     * // Delete a few ProductAttributeUnitValues
     * const { count } = await prisma.productAttributeUnitValues.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductAttributeUnitValuesDeleteManyArgs>(
      args?: SelectSubset<T, ProductAttributeUnitValuesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductAttributeUnitValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAttributeUnitValuesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductAttributeUnitValues
     * const productAttributeUnitValues = await prisma.productAttributeUnitValues.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductAttributeUnitValuesUpdateManyArgs>(
      args: SelectSubset<T, ProductAttributeUnitValuesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductAttributeUnitValues.
     * @param {ProductAttributeUnitValuesUpsertArgs} args - Arguments to update or create a ProductAttributeUnitValues.
     * @example
     * // Update or create a ProductAttributeUnitValues
     * const productAttributeUnitValues = await prisma.productAttributeUnitValues.upsert({
     *   create: {
     *     // ... data to create a ProductAttributeUnitValues
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductAttributeUnitValues we want to update
     *   }
     * })
    **/
    upsert<T extends ProductAttributeUnitValuesUpsertArgs>(
      args: SelectSubset<T, ProductAttributeUnitValuesUpsertArgs>
    ): CheckSelect<T, Prisma__ProductAttributeUnitValuesClient<ProductAttributeUnitValues>, Prisma__ProductAttributeUnitValuesClient<ProductAttributeUnitValuesGetPayload<T>>>

    /**
     * Count the number of ProductAttributeUnitValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAttributeUnitValuesCountArgs} args - Arguments to filter ProductAttributeUnitValues to count.
     * @example
     * // Count the number of ProductAttributeUnitValues
     * const count = await prisma.productAttributeUnitValues.count({
     *   where: {
     *     // ... the filter for the ProductAttributeUnitValues we want to count
     *   }
     * })
    **/
    count<T extends ProductAttributeUnitValuesCountArgs>(
      args?: Subset<T, ProductAttributeUnitValuesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductAttributeUnitValuesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductAttributeUnitValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAttributeUnitValuesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAttributeUnitValuesAggregateArgs>(args: Subset<T, ProductAttributeUnitValuesAggregateArgs>): PrismaPromise<GetProductAttributeUnitValuesAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductAttributeUnitValues.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProductAttributeUnitValuesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    ProductAttributeUnits<T extends ProductAttributeUnitsArgs = {}>(args?: Subset<T, ProductAttributeUnitsArgs>): CheckSelect<T, Prisma__ProductAttributeUnitsClient<ProductAttributeUnits | null >, Prisma__ProductAttributeUnitsClient<ProductAttributeUnitsGetPayload<T> | null >>;

    ScopeOfWorks<T extends ScopeOfWorksFindManyArgs = {}>(args?: Subset<T, ScopeOfWorksFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ScopeOfWorks>>, PrismaPromise<Array<ScopeOfWorksGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * ProductAttributeUnitValues findUnique
   */
  export type ProductAttributeUnitValuesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the ProductAttributeUnitValues
    **/
    select?: ProductAttributeUnitValuesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProductAttributeUnitValuesInclude | null
    /**
     * Throw an Error if a ProductAttributeUnitValues can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ProductAttributeUnitValues to fetch.
    **/
    where: ProductAttributeUnitValuesWhereUniqueInput
  }


  /**
   * ProductAttributeUnitValues findFirst
   */
  export type ProductAttributeUnitValuesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the ProductAttributeUnitValues
    **/
    select?: ProductAttributeUnitValuesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProductAttributeUnitValuesInclude | null
    /**
     * Throw an Error if a ProductAttributeUnitValues can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ProductAttributeUnitValues to fetch.
    **/
    where?: ProductAttributeUnitValuesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductAttributeUnitValues to fetch.
    **/
    orderBy?: Enumerable<ProductAttributeUnitValuesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductAttributeUnitValues.
    **/
    cursor?: ProductAttributeUnitValuesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductAttributeUnitValues from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductAttributeUnitValues.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductAttributeUnitValues.
    **/
    distinct?: Enumerable<ProductAttributeUnitValuesScalarFieldEnum>
  }


  /**
   * ProductAttributeUnitValues findMany
   */
  export type ProductAttributeUnitValuesFindManyArgs = {
    /**
     * Select specific fields to fetch from the ProductAttributeUnitValues
    **/
    select?: ProductAttributeUnitValuesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProductAttributeUnitValuesInclude | null
    /**
     * Filter, which ProductAttributeUnitValues to fetch.
    **/
    where?: ProductAttributeUnitValuesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductAttributeUnitValues to fetch.
    **/
    orderBy?: Enumerable<ProductAttributeUnitValuesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductAttributeUnitValues.
    **/
    cursor?: ProductAttributeUnitValuesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductAttributeUnitValues from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductAttributeUnitValues.
    **/
    skip?: number
    distinct?: Enumerable<ProductAttributeUnitValuesScalarFieldEnum>
  }


  /**
   * ProductAttributeUnitValues create
   */
  export type ProductAttributeUnitValuesCreateArgs = {
    /**
     * Select specific fields to fetch from the ProductAttributeUnitValues
    **/
    select?: ProductAttributeUnitValuesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProductAttributeUnitValuesInclude | null
    /**
     * The data needed to create a ProductAttributeUnitValues.
    **/
    data: XOR<ProductAttributeUnitValuesCreateInput, ProductAttributeUnitValuesUncheckedCreateInput>
  }


  /**
   * ProductAttributeUnitValues update
   */
  export type ProductAttributeUnitValuesUpdateArgs = {
    /**
     * Select specific fields to fetch from the ProductAttributeUnitValues
    **/
    select?: ProductAttributeUnitValuesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProductAttributeUnitValuesInclude | null
    /**
     * The data needed to update a ProductAttributeUnitValues.
    **/
    data: XOR<ProductAttributeUnitValuesUpdateInput, ProductAttributeUnitValuesUncheckedUpdateInput>
    /**
     * Choose, which ProductAttributeUnitValues to update.
    **/
    where: ProductAttributeUnitValuesWhereUniqueInput
  }


  /**
   * ProductAttributeUnitValues updateMany
   */
  export type ProductAttributeUnitValuesUpdateManyArgs = {
    data: XOR<ProductAttributeUnitValuesUpdateManyMutationInput, ProductAttributeUnitValuesUncheckedUpdateManyInput>
    where?: ProductAttributeUnitValuesWhereInput
  }


  /**
   * ProductAttributeUnitValues upsert
   */
  export type ProductAttributeUnitValuesUpsertArgs = {
    /**
     * Select specific fields to fetch from the ProductAttributeUnitValues
    **/
    select?: ProductAttributeUnitValuesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProductAttributeUnitValuesInclude | null
    /**
     * The filter to search for the ProductAttributeUnitValues to update in case it exists.
    **/
    where: ProductAttributeUnitValuesWhereUniqueInput
    /**
     * In case the ProductAttributeUnitValues found by the `where` argument doesn't exist, create a new ProductAttributeUnitValues with this data.
    **/
    create: XOR<ProductAttributeUnitValuesCreateInput, ProductAttributeUnitValuesUncheckedCreateInput>
    /**
     * In case the ProductAttributeUnitValues was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<ProductAttributeUnitValuesUpdateInput, ProductAttributeUnitValuesUncheckedUpdateInput>
  }


  /**
   * ProductAttributeUnitValues delete
   */
  export type ProductAttributeUnitValuesDeleteArgs = {
    /**
     * Select specific fields to fetch from the ProductAttributeUnitValues
    **/
    select?: ProductAttributeUnitValuesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProductAttributeUnitValuesInclude | null
    /**
     * Filter which ProductAttributeUnitValues to delete.
    **/
    where: ProductAttributeUnitValuesWhereUniqueInput
  }


  /**
   * ProductAttributeUnitValues deleteMany
   */
  export type ProductAttributeUnitValuesDeleteManyArgs = {
    where?: ProductAttributeUnitValuesWhereInput
  }


  /**
   * ProductAttributeUnitValues without action
   */
  export type ProductAttributeUnitValuesArgs = {
    /**
     * Select specific fields to fetch from the ProductAttributeUnitValues
    **/
    select?: ProductAttributeUnitValuesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProductAttributeUnitValuesInclude | null
  }



  /**
   * Model ProductCategories
   */


  export type AggregateProductCategories = {
    count: ProductCategoriesCountAggregateOutputType | null
    avg: ProductCategoriesAvgAggregateOutputType | null
    sum: ProductCategoriesSumAggregateOutputType | null
    min: ProductCategoriesMinAggregateOutputType | null
    max: ProductCategoriesMaxAggregateOutputType | null
  }

  export type ProductCategoriesAvgAggregateOutputType = {
    id: number
    created_by: number | null
    updated_by: number | null
  }

  export type ProductCategoriesSumAggregateOutputType = {
    id: number
    created_by: number | null
    updated_by: number | null
  }

  export type ProductCategoriesMinAggregateOutputType = {
    id: number
    name: string | null
    slug: string | null
    created_at: Date | null
    updated_at: Date | null
    created_by: number | null
    updated_by: number | null
  }

  export type ProductCategoriesMaxAggregateOutputType = {
    id: number
    name: string | null
    slug: string | null
    created_at: Date | null
    updated_at: Date | null
    created_by: number | null
    updated_by: number | null
  }

  export type ProductCategoriesCountAggregateOutputType = {
    id: number
    name: number | null
    slug: number | null
    created_at: number | null
    updated_at: number | null
    created_by: number | null
    updated_by: number | null
    _all: number
  }


  export type ProductCategoriesAvgAggregateInputType = {
    id?: true
    created_by?: true
    updated_by?: true
  }

  export type ProductCategoriesSumAggregateInputType = {
    id?: true
    created_by?: true
    updated_by?: true
  }

  export type ProductCategoriesMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type ProductCategoriesMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type ProductCategoriesCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
    _all?: true
  }

  export type ProductCategoriesAggregateArgs = {
    /**
     * Filter which ProductCategories to aggregate.
    **/
    where?: ProductCategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
    **/
    orderBy?: Enumerable<ProductCategoriesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: ProductCategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductCategories
    **/
    count?: true | ProductCategoriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: ProductCategoriesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: ProductCategoriesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: ProductCategoriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: ProductCategoriesMaxAggregateInputType
  }

  export type GetProductCategoriesAggregateType<T extends ProductCategoriesAggregateArgs> = {
    [P in keyof T & keyof AggregateProductCategories]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductCategories[P]>
      : GetScalarType<T[P], AggregateProductCategories[P]>
  }



  export type ProductCategoriesSelect = {
    id?: boolean
    name?: boolean
    slug?: boolean
    created_at?: boolean
    updated_at?: boolean
    created_by?: boolean
    updated_by?: boolean
    PropertyUnitProductCategories?: boolean | PropertyUnitProductCategoriesFindManyArgs
  }

  export type ProductCategoriesInclude = {
    PropertyUnitProductCategories?: boolean | PropertyUnitProductCategoriesFindManyArgs
  }

  export type ProductCategoriesGetPayload<
    S extends boolean | null | undefined | ProductCategoriesArgs,
    U = keyof S
      > = S extends true
        ? ProductCategories
    : S extends undefined
    ? never
    : S extends ProductCategoriesArgs | ProductCategoriesFindManyArgs
    ?'include' extends U
    ? ProductCategories  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'PropertyUnitProductCategories'
        ? Array < PropertyUnitProductCategoriesGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof ProductCategories ?ProductCategories [P]
  : 
          P extends 'PropertyUnitProductCategories'
        ? Array < PropertyUnitProductCategoriesGetPayload<S['select'][P]>>  : never
  } 
    : ProductCategories
  : ProductCategories


  type ProductCategoriesCountArgs = Merge<
    Omit<ProductCategoriesFindManyArgs, 'select' | 'include'> & {
      select?: ProductCategoriesCountAggregateInputType | true
    }
  >

  export interface ProductCategoriesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one ProductCategories that matches the filter.
     * @param {ProductCategoriesFindUniqueArgs} args - Arguments to find a ProductCategories
     * @example
     * // Get one ProductCategories
     * const productCategories = await prisma.productCategories.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductCategoriesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProductCategoriesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ProductCategories'> extends True ? CheckSelect<T, Prisma__ProductCategoriesClient<ProductCategories>, Prisma__ProductCategoriesClient<ProductCategoriesGetPayload<T>>> : CheckSelect<T, Prisma__ProductCategoriesClient<ProductCategories | null >, Prisma__ProductCategoriesClient<ProductCategoriesGetPayload<T> | null >>

    /**
     * Find the first ProductCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoriesFindFirstArgs} args - Arguments to find a ProductCategories
     * @example
     * // Get one ProductCategories
     * const productCategories = await prisma.productCategories.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductCategoriesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProductCategoriesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ProductCategories'> extends True ? CheckSelect<T, Prisma__ProductCategoriesClient<ProductCategories>, Prisma__ProductCategoriesClient<ProductCategoriesGetPayload<T>>> : CheckSelect<T, Prisma__ProductCategoriesClient<ProductCategories | null >, Prisma__ProductCategoriesClient<ProductCategoriesGetPayload<T> | null >>

    /**
     * Find zero or more ProductCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoriesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductCategories
     * const productCategories = await prisma.productCategories.findMany()
     * 
     * // Get first 10 ProductCategories
     * const productCategories = await prisma.productCategories.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productCategoriesWithIdOnly = await prisma.productCategories.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductCategoriesFindManyArgs>(
      args?: SelectSubset<T, ProductCategoriesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ProductCategories>>, PrismaPromise<Array<ProductCategoriesGetPayload<T>>>>

    /**
     * Create a ProductCategories.
     * @param {ProductCategoriesCreateArgs} args - Arguments to create a ProductCategories.
     * @example
     * // Create one ProductCategories
     * const ProductCategories = await prisma.productCategories.create({
     *   data: {
     *     // ... data to create a ProductCategories
     *   }
     * })
     * 
    **/
    create<T extends ProductCategoriesCreateArgs>(
      args: SelectSubset<T, ProductCategoriesCreateArgs>
    ): CheckSelect<T, Prisma__ProductCategoriesClient<ProductCategories>, Prisma__ProductCategoriesClient<ProductCategoriesGetPayload<T>>>

    /**
     * Delete a ProductCategories.
     * @param {ProductCategoriesDeleteArgs} args - Arguments to delete one ProductCategories.
     * @example
     * // Delete one ProductCategories
     * const ProductCategories = await prisma.productCategories.delete({
     *   where: {
     *     // ... filter to delete one ProductCategories
     *   }
     * })
     * 
    **/
    delete<T extends ProductCategoriesDeleteArgs>(
      args: SelectSubset<T, ProductCategoriesDeleteArgs>
    ): CheckSelect<T, Prisma__ProductCategoriesClient<ProductCategories>, Prisma__ProductCategoriesClient<ProductCategoriesGetPayload<T>>>

    /**
     * Update one ProductCategories.
     * @param {ProductCategoriesUpdateArgs} args - Arguments to update one ProductCategories.
     * @example
     * // Update one ProductCategories
     * const productCategories = await prisma.productCategories.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductCategoriesUpdateArgs>(
      args: SelectSubset<T, ProductCategoriesUpdateArgs>
    ): CheckSelect<T, Prisma__ProductCategoriesClient<ProductCategories>, Prisma__ProductCategoriesClient<ProductCategoriesGetPayload<T>>>

    /**
     * Delete zero or more ProductCategories.
     * @param {ProductCategoriesDeleteManyArgs} args - Arguments to filter ProductCategories to delete.
     * @example
     * // Delete a few ProductCategories
     * const { count } = await prisma.productCategories.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductCategoriesDeleteManyArgs>(
      args?: SelectSubset<T, ProductCategoriesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductCategories
     * const productCategories = await prisma.productCategories.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductCategoriesUpdateManyArgs>(
      args: SelectSubset<T, ProductCategoriesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductCategories.
     * @param {ProductCategoriesUpsertArgs} args - Arguments to update or create a ProductCategories.
     * @example
     * // Update or create a ProductCategories
     * const productCategories = await prisma.productCategories.upsert({
     *   create: {
     *     // ... data to create a ProductCategories
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductCategories we want to update
     *   }
     * })
    **/
    upsert<T extends ProductCategoriesUpsertArgs>(
      args: SelectSubset<T, ProductCategoriesUpsertArgs>
    ): CheckSelect<T, Prisma__ProductCategoriesClient<ProductCategories>, Prisma__ProductCategoriesClient<ProductCategoriesGetPayload<T>>>

    /**
     * Count the number of ProductCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoriesCountArgs} args - Arguments to filter ProductCategories to count.
     * @example
     * // Count the number of ProductCategories
     * const count = await prisma.productCategories.count({
     *   where: {
     *     // ... the filter for the ProductCategories we want to count
     *   }
     * })
    **/
    count<T extends ProductCategoriesCountArgs>(
      args?: Subset<T, ProductCategoriesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCategoriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductCategoriesAggregateArgs>(args: Subset<T, ProductCategoriesAggregateArgs>): PrismaPromise<GetProductCategoriesAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductCategories.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProductCategoriesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    PropertyUnitProductCategories<T extends PropertyUnitProductCategoriesFindManyArgs = {}>(args?: Subset<T, PropertyUnitProductCategoriesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<PropertyUnitProductCategories>>, PrismaPromise<Array<PropertyUnitProductCategoriesGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * ProductCategories findUnique
   */
  export type ProductCategoriesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the ProductCategories
    **/
    select?: ProductCategoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProductCategoriesInclude | null
    /**
     * Throw an Error if a ProductCategories can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ProductCategories to fetch.
    **/
    where: ProductCategoriesWhereUniqueInput
  }


  /**
   * ProductCategories findFirst
   */
  export type ProductCategoriesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the ProductCategories
    **/
    select?: ProductCategoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProductCategoriesInclude | null
    /**
     * Throw an Error if a ProductCategories can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ProductCategories to fetch.
    **/
    where?: ProductCategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
    **/
    orderBy?: Enumerable<ProductCategoriesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductCategories.
    **/
    cursor?: ProductCategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductCategories.
    **/
    distinct?: Enumerable<ProductCategoriesScalarFieldEnum>
  }


  /**
   * ProductCategories findMany
   */
  export type ProductCategoriesFindManyArgs = {
    /**
     * Select specific fields to fetch from the ProductCategories
    **/
    select?: ProductCategoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProductCategoriesInclude | null
    /**
     * Filter, which ProductCategories to fetch.
    **/
    where?: ProductCategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
    **/
    orderBy?: Enumerable<ProductCategoriesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductCategories.
    **/
    cursor?: ProductCategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
    **/
    skip?: number
    distinct?: Enumerable<ProductCategoriesScalarFieldEnum>
  }


  /**
   * ProductCategories create
   */
  export type ProductCategoriesCreateArgs = {
    /**
     * Select specific fields to fetch from the ProductCategories
    **/
    select?: ProductCategoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProductCategoriesInclude | null
    /**
     * The data needed to create a ProductCategories.
    **/
    data: XOR<ProductCategoriesCreateInput, ProductCategoriesUncheckedCreateInput>
  }


  /**
   * ProductCategories update
   */
  export type ProductCategoriesUpdateArgs = {
    /**
     * Select specific fields to fetch from the ProductCategories
    **/
    select?: ProductCategoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProductCategoriesInclude | null
    /**
     * The data needed to update a ProductCategories.
    **/
    data: XOR<ProductCategoriesUpdateInput, ProductCategoriesUncheckedUpdateInput>
    /**
     * Choose, which ProductCategories to update.
    **/
    where: ProductCategoriesWhereUniqueInput
  }


  /**
   * ProductCategories updateMany
   */
  export type ProductCategoriesUpdateManyArgs = {
    data: XOR<ProductCategoriesUpdateManyMutationInput, ProductCategoriesUncheckedUpdateManyInput>
    where?: ProductCategoriesWhereInput
  }


  /**
   * ProductCategories upsert
   */
  export type ProductCategoriesUpsertArgs = {
    /**
     * Select specific fields to fetch from the ProductCategories
    **/
    select?: ProductCategoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProductCategoriesInclude | null
    /**
     * The filter to search for the ProductCategories to update in case it exists.
    **/
    where: ProductCategoriesWhereUniqueInput
    /**
     * In case the ProductCategories found by the `where` argument doesn't exist, create a new ProductCategories with this data.
    **/
    create: XOR<ProductCategoriesCreateInput, ProductCategoriesUncheckedCreateInput>
    /**
     * In case the ProductCategories was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<ProductCategoriesUpdateInput, ProductCategoriesUncheckedUpdateInput>
  }


  /**
   * ProductCategories delete
   */
  export type ProductCategoriesDeleteArgs = {
    /**
     * Select specific fields to fetch from the ProductCategories
    **/
    select?: ProductCategoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProductCategoriesInclude | null
    /**
     * Filter which ProductCategories to delete.
    **/
    where: ProductCategoriesWhereUniqueInput
  }


  /**
   * ProductCategories deleteMany
   */
  export type ProductCategoriesDeleteManyArgs = {
    where?: ProductCategoriesWhereInput
  }


  /**
   * ProductCategories without action
   */
  export type ProductCategoriesArgs = {
    /**
     * Select specific fields to fetch from the ProductCategories
    **/
    select?: ProductCategoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProductCategoriesInclude | null
  }



  /**
   * Model ProductPropertyUnits
   */


  export type AggregateProductPropertyUnits = {
    count: ProductPropertyUnitsCountAggregateOutputType | null
    avg: ProductPropertyUnitsAvgAggregateOutputType | null
    sum: ProductPropertyUnitsSumAggregateOutputType | null
    min: ProductPropertyUnitsMinAggregateOutputType | null
    max: ProductPropertyUnitsMaxAggregateOutputType | null
  }

  export type ProductPropertyUnitsAvgAggregateOutputType = {
    id: number
    property_unit_id: number
    product_id: number
    created_by: number | null
    updated_by: number | null
  }

  export type ProductPropertyUnitsSumAggregateOutputType = {
    id: number
    property_unit_id: number
    product_id: number
    created_by: number | null
    updated_by: number | null
  }

  export type ProductPropertyUnitsMinAggregateOutputType = {
    id: number
    property_unit_id: number
    product_id: number
    created_at: Date | null
    updated_at: Date | null
    created_by: number | null
    updated_by: number | null
  }

  export type ProductPropertyUnitsMaxAggregateOutputType = {
    id: number
    property_unit_id: number
    product_id: number
    created_at: Date | null
    updated_at: Date | null
    created_by: number | null
    updated_by: number | null
  }

  export type ProductPropertyUnitsCountAggregateOutputType = {
    id: number
    property_unit_id: number
    product_id: number
    created_at: number | null
    updated_at: number | null
    created_by: number | null
    updated_by: number | null
    _all: number
  }


  export type ProductPropertyUnitsAvgAggregateInputType = {
    id?: true
    property_unit_id?: true
    product_id?: true
    created_by?: true
    updated_by?: true
  }

  export type ProductPropertyUnitsSumAggregateInputType = {
    id?: true
    property_unit_id?: true
    product_id?: true
    created_by?: true
    updated_by?: true
  }

  export type ProductPropertyUnitsMinAggregateInputType = {
    id?: true
    property_unit_id?: true
    product_id?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type ProductPropertyUnitsMaxAggregateInputType = {
    id?: true
    property_unit_id?: true
    product_id?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type ProductPropertyUnitsCountAggregateInputType = {
    id?: true
    property_unit_id?: true
    product_id?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
    _all?: true
  }

  export type ProductPropertyUnitsAggregateArgs = {
    /**
     * Filter which ProductPropertyUnits to aggregate.
    **/
    where?: ProductPropertyUnitsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductPropertyUnits to fetch.
    **/
    orderBy?: Enumerable<ProductPropertyUnitsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: ProductPropertyUnitsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductPropertyUnits from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductPropertyUnits.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductPropertyUnits
    **/
    count?: true | ProductPropertyUnitsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: ProductPropertyUnitsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: ProductPropertyUnitsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: ProductPropertyUnitsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: ProductPropertyUnitsMaxAggregateInputType
  }

  export type GetProductPropertyUnitsAggregateType<T extends ProductPropertyUnitsAggregateArgs> = {
    [P in keyof T & keyof AggregateProductPropertyUnits]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductPropertyUnits[P]>
      : GetScalarType<T[P], AggregateProductPropertyUnits[P]>
  }



  export type ProductPropertyUnitsSelect = {
    id?: boolean
    property_unit_id?: boolean
    product_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    created_by?: boolean
    updated_by?: boolean
    Products?: boolean | ProductsArgs
    PropertyUnits?: boolean | PropertyUnitsArgs
  }

  export type ProductPropertyUnitsInclude = {
    Products?: boolean | ProductsArgs
    PropertyUnits?: boolean | PropertyUnitsArgs
  }

  export type ProductPropertyUnitsGetPayload<
    S extends boolean | null | undefined | ProductPropertyUnitsArgs,
    U = keyof S
      > = S extends true
        ? ProductPropertyUnits
    : S extends undefined
    ? never
    : S extends ProductPropertyUnitsArgs | ProductPropertyUnitsFindManyArgs
    ?'include' extends U
    ? ProductPropertyUnits  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'Products'
        ? ProductsGetPayload<S['include'][P]> :
        P extends 'PropertyUnits'
        ? PropertyUnitsGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof ProductPropertyUnits ?ProductPropertyUnits [P]
  : 
          P extends 'Products'
        ? ProductsGetPayload<S['select'][P]> :
        P extends 'PropertyUnits'
        ? PropertyUnitsGetPayload<S['select'][P]> : never
  } 
    : ProductPropertyUnits
  : ProductPropertyUnits


  type ProductPropertyUnitsCountArgs = Merge<
    Omit<ProductPropertyUnitsFindManyArgs, 'select' | 'include'> & {
      select?: ProductPropertyUnitsCountAggregateInputType | true
    }
  >

  export interface ProductPropertyUnitsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one ProductPropertyUnits that matches the filter.
     * @param {ProductPropertyUnitsFindUniqueArgs} args - Arguments to find a ProductPropertyUnits
     * @example
     * // Get one ProductPropertyUnits
     * const productPropertyUnits = await prisma.productPropertyUnits.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductPropertyUnitsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProductPropertyUnitsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ProductPropertyUnits'> extends True ? CheckSelect<T, Prisma__ProductPropertyUnitsClient<ProductPropertyUnits>, Prisma__ProductPropertyUnitsClient<ProductPropertyUnitsGetPayload<T>>> : CheckSelect<T, Prisma__ProductPropertyUnitsClient<ProductPropertyUnits | null >, Prisma__ProductPropertyUnitsClient<ProductPropertyUnitsGetPayload<T> | null >>

    /**
     * Find the first ProductPropertyUnits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductPropertyUnitsFindFirstArgs} args - Arguments to find a ProductPropertyUnits
     * @example
     * // Get one ProductPropertyUnits
     * const productPropertyUnits = await prisma.productPropertyUnits.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductPropertyUnitsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProductPropertyUnitsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ProductPropertyUnits'> extends True ? CheckSelect<T, Prisma__ProductPropertyUnitsClient<ProductPropertyUnits>, Prisma__ProductPropertyUnitsClient<ProductPropertyUnitsGetPayload<T>>> : CheckSelect<T, Prisma__ProductPropertyUnitsClient<ProductPropertyUnits | null >, Prisma__ProductPropertyUnitsClient<ProductPropertyUnitsGetPayload<T> | null >>

    /**
     * Find zero or more ProductPropertyUnits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductPropertyUnitsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductPropertyUnits
     * const productPropertyUnits = await prisma.productPropertyUnits.findMany()
     * 
     * // Get first 10 ProductPropertyUnits
     * const productPropertyUnits = await prisma.productPropertyUnits.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productPropertyUnitsWithIdOnly = await prisma.productPropertyUnits.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductPropertyUnitsFindManyArgs>(
      args?: SelectSubset<T, ProductPropertyUnitsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ProductPropertyUnits>>, PrismaPromise<Array<ProductPropertyUnitsGetPayload<T>>>>

    /**
     * Create a ProductPropertyUnits.
     * @param {ProductPropertyUnitsCreateArgs} args - Arguments to create a ProductPropertyUnits.
     * @example
     * // Create one ProductPropertyUnits
     * const ProductPropertyUnits = await prisma.productPropertyUnits.create({
     *   data: {
     *     // ... data to create a ProductPropertyUnits
     *   }
     * })
     * 
    **/
    create<T extends ProductPropertyUnitsCreateArgs>(
      args: SelectSubset<T, ProductPropertyUnitsCreateArgs>
    ): CheckSelect<T, Prisma__ProductPropertyUnitsClient<ProductPropertyUnits>, Prisma__ProductPropertyUnitsClient<ProductPropertyUnitsGetPayload<T>>>

    /**
     * Delete a ProductPropertyUnits.
     * @param {ProductPropertyUnitsDeleteArgs} args - Arguments to delete one ProductPropertyUnits.
     * @example
     * // Delete one ProductPropertyUnits
     * const ProductPropertyUnits = await prisma.productPropertyUnits.delete({
     *   where: {
     *     // ... filter to delete one ProductPropertyUnits
     *   }
     * })
     * 
    **/
    delete<T extends ProductPropertyUnitsDeleteArgs>(
      args: SelectSubset<T, ProductPropertyUnitsDeleteArgs>
    ): CheckSelect<T, Prisma__ProductPropertyUnitsClient<ProductPropertyUnits>, Prisma__ProductPropertyUnitsClient<ProductPropertyUnitsGetPayload<T>>>

    /**
     * Update one ProductPropertyUnits.
     * @param {ProductPropertyUnitsUpdateArgs} args - Arguments to update one ProductPropertyUnits.
     * @example
     * // Update one ProductPropertyUnits
     * const productPropertyUnits = await prisma.productPropertyUnits.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductPropertyUnitsUpdateArgs>(
      args: SelectSubset<T, ProductPropertyUnitsUpdateArgs>
    ): CheckSelect<T, Prisma__ProductPropertyUnitsClient<ProductPropertyUnits>, Prisma__ProductPropertyUnitsClient<ProductPropertyUnitsGetPayload<T>>>

    /**
     * Delete zero or more ProductPropertyUnits.
     * @param {ProductPropertyUnitsDeleteManyArgs} args - Arguments to filter ProductPropertyUnits to delete.
     * @example
     * // Delete a few ProductPropertyUnits
     * const { count } = await prisma.productPropertyUnits.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductPropertyUnitsDeleteManyArgs>(
      args?: SelectSubset<T, ProductPropertyUnitsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductPropertyUnits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductPropertyUnitsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductPropertyUnits
     * const productPropertyUnits = await prisma.productPropertyUnits.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductPropertyUnitsUpdateManyArgs>(
      args: SelectSubset<T, ProductPropertyUnitsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductPropertyUnits.
     * @param {ProductPropertyUnitsUpsertArgs} args - Arguments to update or create a ProductPropertyUnits.
     * @example
     * // Update or create a ProductPropertyUnits
     * const productPropertyUnits = await prisma.productPropertyUnits.upsert({
     *   create: {
     *     // ... data to create a ProductPropertyUnits
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductPropertyUnits we want to update
     *   }
     * })
    **/
    upsert<T extends ProductPropertyUnitsUpsertArgs>(
      args: SelectSubset<T, ProductPropertyUnitsUpsertArgs>
    ): CheckSelect<T, Prisma__ProductPropertyUnitsClient<ProductPropertyUnits>, Prisma__ProductPropertyUnitsClient<ProductPropertyUnitsGetPayload<T>>>

    /**
     * Count the number of ProductPropertyUnits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductPropertyUnitsCountArgs} args - Arguments to filter ProductPropertyUnits to count.
     * @example
     * // Count the number of ProductPropertyUnits
     * const count = await prisma.productPropertyUnits.count({
     *   where: {
     *     // ... the filter for the ProductPropertyUnits we want to count
     *   }
     * })
    **/
    count<T extends ProductPropertyUnitsCountArgs>(
      args?: Subset<T, ProductPropertyUnitsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductPropertyUnitsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductPropertyUnits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductPropertyUnitsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductPropertyUnitsAggregateArgs>(args: Subset<T, ProductPropertyUnitsAggregateArgs>): PrismaPromise<GetProductPropertyUnitsAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductPropertyUnits.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProductPropertyUnitsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Products<T extends ProductsArgs = {}>(args?: Subset<T, ProductsArgs>): CheckSelect<T, Prisma__ProductsClient<Products | null >, Prisma__ProductsClient<ProductsGetPayload<T> | null >>;

    PropertyUnits<T extends PropertyUnitsArgs = {}>(args?: Subset<T, PropertyUnitsArgs>): CheckSelect<T, Prisma__PropertyUnitsClient<PropertyUnits | null >, Prisma__PropertyUnitsClient<PropertyUnitsGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * ProductPropertyUnits findUnique
   */
  export type ProductPropertyUnitsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the ProductPropertyUnits
    **/
    select?: ProductPropertyUnitsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProductPropertyUnitsInclude | null
    /**
     * Throw an Error if a ProductPropertyUnits can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ProductPropertyUnits to fetch.
    **/
    where: ProductPropertyUnitsWhereUniqueInput
  }


  /**
   * ProductPropertyUnits findFirst
   */
  export type ProductPropertyUnitsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the ProductPropertyUnits
    **/
    select?: ProductPropertyUnitsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProductPropertyUnitsInclude | null
    /**
     * Throw an Error if a ProductPropertyUnits can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ProductPropertyUnits to fetch.
    **/
    where?: ProductPropertyUnitsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductPropertyUnits to fetch.
    **/
    orderBy?: Enumerable<ProductPropertyUnitsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductPropertyUnits.
    **/
    cursor?: ProductPropertyUnitsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductPropertyUnits from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductPropertyUnits.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductPropertyUnits.
    **/
    distinct?: Enumerable<ProductPropertyUnitsScalarFieldEnum>
  }


  /**
   * ProductPropertyUnits findMany
   */
  export type ProductPropertyUnitsFindManyArgs = {
    /**
     * Select specific fields to fetch from the ProductPropertyUnits
    **/
    select?: ProductPropertyUnitsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProductPropertyUnitsInclude | null
    /**
     * Filter, which ProductPropertyUnits to fetch.
    **/
    where?: ProductPropertyUnitsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductPropertyUnits to fetch.
    **/
    orderBy?: Enumerable<ProductPropertyUnitsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductPropertyUnits.
    **/
    cursor?: ProductPropertyUnitsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductPropertyUnits from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductPropertyUnits.
    **/
    skip?: number
    distinct?: Enumerable<ProductPropertyUnitsScalarFieldEnum>
  }


  /**
   * ProductPropertyUnits create
   */
  export type ProductPropertyUnitsCreateArgs = {
    /**
     * Select specific fields to fetch from the ProductPropertyUnits
    **/
    select?: ProductPropertyUnitsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProductPropertyUnitsInclude | null
    /**
     * The data needed to create a ProductPropertyUnits.
    **/
    data: XOR<ProductPropertyUnitsCreateInput, ProductPropertyUnitsUncheckedCreateInput>
  }


  /**
   * ProductPropertyUnits update
   */
  export type ProductPropertyUnitsUpdateArgs = {
    /**
     * Select specific fields to fetch from the ProductPropertyUnits
    **/
    select?: ProductPropertyUnitsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProductPropertyUnitsInclude | null
    /**
     * The data needed to update a ProductPropertyUnits.
    **/
    data: XOR<ProductPropertyUnitsUpdateInput, ProductPropertyUnitsUncheckedUpdateInput>
    /**
     * Choose, which ProductPropertyUnits to update.
    **/
    where: ProductPropertyUnitsWhereUniqueInput
  }


  /**
   * ProductPropertyUnits updateMany
   */
  export type ProductPropertyUnitsUpdateManyArgs = {
    data: XOR<ProductPropertyUnitsUpdateManyMutationInput, ProductPropertyUnitsUncheckedUpdateManyInput>
    where?: ProductPropertyUnitsWhereInput
  }


  /**
   * ProductPropertyUnits upsert
   */
  export type ProductPropertyUnitsUpsertArgs = {
    /**
     * Select specific fields to fetch from the ProductPropertyUnits
    **/
    select?: ProductPropertyUnitsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProductPropertyUnitsInclude | null
    /**
     * The filter to search for the ProductPropertyUnits to update in case it exists.
    **/
    where: ProductPropertyUnitsWhereUniqueInput
    /**
     * In case the ProductPropertyUnits found by the `where` argument doesn't exist, create a new ProductPropertyUnits with this data.
    **/
    create: XOR<ProductPropertyUnitsCreateInput, ProductPropertyUnitsUncheckedCreateInput>
    /**
     * In case the ProductPropertyUnits was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<ProductPropertyUnitsUpdateInput, ProductPropertyUnitsUncheckedUpdateInput>
  }


  /**
   * ProductPropertyUnits delete
   */
  export type ProductPropertyUnitsDeleteArgs = {
    /**
     * Select specific fields to fetch from the ProductPropertyUnits
    **/
    select?: ProductPropertyUnitsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProductPropertyUnitsInclude | null
    /**
     * Filter which ProductPropertyUnits to delete.
    **/
    where: ProductPropertyUnitsWhereUniqueInput
  }


  /**
   * ProductPropertyUnits deleteMany
   */
  export type ProductPropertyUnitsDeleteManyArgs = {
    where?: ProductPropertyUnitsWhereInput
  }


  /**
   * ProductPropertyUnits without action
   */
  export type ProductPropertyUnitsArgs = {
    /**
     * Select specific fields to fetch from the ProductPropertyUnits
    **/
    select?: ProductPropertyUnitsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProductPropertyUnitsInclude | null
  }



  /**
   * Model Products
   */


  export type AggregateProducts = {
    count: ProductsCountAggregateOutputType | null
    avg: ProductsAvgAggregateOutputType | null
    sum: ProductsSumAggregateOutputType | null
    min: ProductsMinAggregateOutputType | null
    max: ProductsMaxAggregateOutputType | null
  }

  export type ProductsAvgAggregateOutputType = {
    id: number
    parent_id: number | null
    created_by: number | null
    updated_by: number | null
  }

  export type ProductsSumAggregateOutputType = {
    id: number
    parent_id: number | null
    created_by: number | null
    updated_by: number | null
  }

  export type ProductsMinAggregateOutputType = {
    id: number
    parent_id: number | null
    name: string | null
    slug: string | null
    created_at: Date | null
    updated_at: Date | null
    created_by: number | null
    updated_by: number | null
  }

  export type ProductsMaxAggregateOutputType = {
    id: number
    parent_id: number | null
    name: string | null
    slug: string | null
    created_at: Date | null
    updated_at: Date | null
    created_by: number | null
    updated_by: number | null
  }

  export type ProductsCountAggregateOutputType = {
    id: number
    parent_id: number | null
    name: number | null
    slug: number | null
    created_at: number | null
    updated_at: number | null
    created_by: number | null
    updated_by: number | null
    _all: number
  }


  export type ProductsAvgAggregateInputType = {
    id?: true
    parent_id?: true
    created_by?: true
    updated_by?: true
  }

  export type ProductsSumAggregateInputType = {
    id?: true
    parent_id?: true
    created_by?: true
    updated_by?: true
  }

  export type ProductsMinAggregateInputType = {
    id?: true
    parent_id?: true
    name?: true
    slug?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type ProductsMaxAggregateInputType = {
    id?: true
    parent_id?: true
    name?: true
    slug?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type ProductsCountAggregateInputType = {
    id?: true
    parent_id?: true
    name?: true
    slug?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
    _all?: true
  }

  export type ProductsAggregateArgs = {
    /**
     * Filter which Products to aggregate.
    **/
    where?: ProductsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
    **/
    orderBy?: Enumerable<ProductsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: ProductsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    count?: true | ProductsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: ProductsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: ProductsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: ProductsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: ProductsMaxAggregateInputType
  }

  export type GetProductsAggregateType<T extends ProductsAggregateArgs> = {
    [P in keyof T & keyof AggregateProducts]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProducts[P]>
      : GetScalarType<T[P], AggregateProducts[P]>
  }



  export type ProductsSelect = {
    id?: boolean
    parent_id?: boolean
    name?: boolean
    slug?: boolean
    created_at?: boolean
    updated_at?: boolean
    created_by?: boolean
    updated_by?: boolean
    Products?: boolean | ProductsArgs
    ProductAttributeUnits?: boolean | ProductAttributeUnitsFindManyArgs
    ProductPropertyUnits?: boolean | ProductPropertyUnitsFindManyArgs
    other_Products?: boolean | ProductsFindManyArgs
    PropertyUnitProductCategoryProducts?: boolean | PropertyUnitProductCategoryProductsFindManyArgs
  }

  export type ProductsInclude = {
    Products?: boolean | ProductsArgs
    ProductAttributeUnits?: boolean | ProductAttributeUnitsFindManyArgs
    ProductPropertyUnits?: boolean | ProductPropertyUnitsFindManyArgs
    other_Products?: boolean | ProductsFindManyArgs
    PropertyUnitProductCategoryProducts?: boolean | PropertyUnitProductCategoryProductsFindManyArgs
  }

  export type ProductsGetPayload<
    S extends boolean | null | undefined | ProductsArgs,
    U = keyof S
      > = S extends true
        ? Products
    : S extends undefined
    ? never
    : S extends ProductsArgs | ProductsFindManyArgs
    ?'include' extends U
    ? Products  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'Products'
        ? ProductsGetPayload<S['include'][P]> | null :
        P extends 'ProductAttributeUnits'
        ? Array < ProductAttributeUnitsGetPayload<S['include'][P]>>  :
        P extends 'ProductPropertyUnits'
        ? Array < ProductPropertyUnitsGetPayload<S['include'][P]>>  :
        P extends 'other_Products'
        ? Array < ProductsGetPayload<S['include'][P]>>  :
        P extends 'PropertyUnitProductCategoryProducts'
        ? Array < PropertyUnitProductCategoryProductsGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Products ?Products [P]
  : 
          P extends 'Products'
        ? ProductsGetPayload<S['select'][P]> | null :
        P extends 'ProductAttributeUnits'
        ? Array < ProductAttributeUnitsGetPayload<S['select'][P]>>  :
        P extends 'ProductPropertyUnits'
        ? Array < ProductPropertyUnitsGetPayload<S['select'][P]>>  :
        P extends 'other_Products'
        ? Array < ProductsGetPayload<S['select'][P]>>  :
        P extends 'PropertyUnitProductCategoryProducts'
        ? Array < PropertyUnitProductCategoryProductsGetPayload<S['select'][P]>>  : never
  } 
    : Products
  : Products


  type ProductsCountArgs = Merge<
    Omit<ProductsFindManyArgs, 'select' | 'include'> & {
      select?: ProductsCountAggregateInputType | true
    }
  >

  export interface ProductsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Products that matches the filter.
     * @param {ProductsFindUniqueArgs} args - Arguments to find a Products
     * @example
     * // Get one Products
     * const products = await prisma.products.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProductsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Products'> extends True ? CheckSelect<T, Prisma__ProductsClient<Products>, Prisma__ProductsClient<ProductsGetPayload<T>>> : CheckSelect<T, Prisma__ProductsClient<Products | null >, Prisma__ProductsClient<ProductsGetPayload<T> | null >>

    /**
     * Find the first Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsFindFirstArgs} args - Arguments to find a Products
     * @example
     * // Get one Products
     * const products = await prisma.products.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProductsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Products'> extends True ? CheckSelect<T, Prisma__ProductsClient<Products>, Prisma__ProductsClient<ProductsGetPayload<T>>> : CheckSelect<T, Prisma__ProductsClient<Products | null >, Prisma__ProductsClient<ProductsGetPayload<T> | null >>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.products.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.products.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productsWithIdOnly = await prisma.products.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductsFindManyArgs>(
      args?: SelectSubset<T, ProductsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Products>>, PrismaPromise<Array<ProductsGetPayload<T>>>>

    /**
     * Create a Products.
     * @param {ProductsCreateArgs} args - Arguments to create a Products.
     * @example
     * // Create one Products
     * const Products = await prisma.products.create({
     *   data: {
     *     // ... data to create a Products
     *   }
     * })
     * 
    **/
    create<T extends ProductsCreateArgs>(
      args: SelectSubset<T, ProductsCreateArgs>
    ): CheckSelect<T, Prisma__ProductsClient<Products>, Prisma__ProductsClient<ProductsGetPayload<T>>>

    /**
     * Delete a Products.
     * @param {ProductsDeleteArgs} args - Arguments to delete one Products.
     * @example
     * // Delete one Products
     * const Products = await prisma.products.delete({
     *   where: {
     *     // ... filter to delete one Products
     *   }
     * })
     * 
    **/
    delete<T extends ProductsDeleteArgs>(
      args: SelectSubset<T, ProductsDeleteArgs>
    ): CheckSelect<T, Prisma__ProductsClient<Products>, Prisma__ProductsClient<ProductsGetPayload<T>>>

    /**
     * Update one Products.
     * @param {ProductsUpdateArgs} args - Arguments to update one Products.
     * @example
     * // Update one Products
     * const products = await prisma.products.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductsUpdateArgs>(
      args: SelectSubset<T, ProductsUpdateArgs>
    ): CheckSelect<T, Prisma__ProductsClient<Products>, Prisma__ProductsClient<ProductsGetPayload<T>>>

    /**
     * Delete zero or more Products.
     * @param {ProductsDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.products.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductsDeleteManyArgs>(
      args?: SelectSubset<T, ProductsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const products = await prisma.products.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductsUpdateManyArgs>(
      args: SelectSubset<T, ProductsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Products.
     * @param {ProductsUpsertArgs} args - Arguments to update or create a Products.
     * @example
     * // Update or create a Products
     * const products = await prisma.products.upsert({
     *   create: {
     *     // ... data to create a Products
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Products we want to update
     *   }
     * })
    **/
    upsert<T extends ProductsUpsertArgs>(
      args: SelectSubset<T, ProductsUpsertArgs>
    ): CheckSelect<T, Prisma__ProductsClient<Products>, Prisma__ProductsClient<ProductsGetPayload<T>>>

    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.products.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductsCountArgs>(
      args?: Subset<T, ProductsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductsAggregateArgs>(args: Subset<T, ProductsAggregateArgs>): PrismaPromise<GetProductsAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for Products.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProductsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Products<T extends ProductsArgs = {}>(args?: Subset<T, ProductsArgs>): CheckSelect<T, Prisma__ProductsClient<Products | null >, Prisma__ProductsClient<ProductsGetPayload<T> | null >>;

    ProductAttributeUnits<T extends ProductAttributeUnitsFindManyArgs = {}>(args?: Subset<T, ProductAttributeUnitsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ProductAttributeUnits>>, PrismaPromise<Array<ProductAttributeUnitsGetPayload<T>>>>;

    ProductPropertyUnits<T extends ProductPropertyUnitsFindManyArgs = {}>(args?: Subset<T, ProductPropertyUnitsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ProductPropertyUnits>>, PrismaPromise<Array<ProductPropertyUnitsGetPayload<T>>>>;

    other_Products<T extends ProductsFindManyArgs = {}>(args?: Subset<T, ProductsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Products>>, PrismaPromise<Array<ProductsGetPayload<T>>>>;

    PropertyUnitProductCategoryProducts<T extends PropertyUnitProductCategoryProductsFindManyArgs = {}>(args?: Subset<T, PropertyUnitProductCategoryProductsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<PropertyUnitProductCategoryProducts>>, PrismaPromise<Array<PropertyUnitProductCategoryProductsGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Products findUnique
   */
  export type ProductsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Products
    **/
    select?: ProductsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProductsInclude | null
    /**
     * Throw an Error if a Products can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Products to fetch.
    **/
    where: ProductsWhereUniqueInput
  }


  /**
   * Products findFirst
   */
  export type ProductsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Products
    **/
    select?: ProductsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProductsInclude | null
    /**
     * Throw an Error if a Products can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Products to fetch.
    **/
    where?: ProductsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
    **/
    orderBy?: Enumerable<ProductsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
    **/
    cursor?: ProductsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
    **/
    distinct?: Enumerable<ProductsScalarFieldEnum>
  }


  /**
   * Products findMany
   */
  export type ProductsFindManyArgs = {
    /**
     * Select specific fields to fetch from the Products
    **/
    select?: ProductsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProductsInclude | null
    /**
     * Filter, which Products to fetch.
    **/
    where?: ProductsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
    **/
    orderBy?: Enumerable<ProductsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
    **/
    cursor?: ProductsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
    **/
    skip?: number
    distinct?: Enumerable<ProductsScalarFieldEnum>
  }


  /**
   * Products create
   */
  export type ProductsCreateArgs = {
    /**
     * Select specific fields to fetch from the Products
    **/
    select?: ProductsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProductsInclude | null
    /**
     * The data needed to create a Products.
    **/
    data: XOR<ProductsCreateInput, ProductsUncheckedCreateInput>
  }


  /**
   * Products update
   */
  export type ProductsUpdateArgs = {
    /**
     * Select specific fields to fetch from the Products
    **/
    select?: ProductsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProductsInclude | null
    /**
     * The data needed to update a Products.
    **/
    data: XOR<ProductsUpdateInput, ProductsUncheckedUpdateInput>
    /**
     * Choose, which Products to update.
    **/
    where: ProductsWhereUniqueInput
  }


  /**
   * Products updateMany
   */
  export type ProductsUpdateManyArgs = {
    data: XOR<ProductsUpdateManyMutationInput, ProductsUncheckedUpdateManyInput>
    where?: ProductsWhereInput
  }


  /**
   * Products upsert
   */
  export type ProductsUpsertArgs = {
    /**
     * Select specific fields to fetch from the Products
    **/
    select?: ProductsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProductsInclude | null
    /**
     * The filter to search for the Products to update in case it exists.
    **/
    where: ProductsWhereUniqueInput
    /**
     * In case the Products found by the `where` argument doesn't exist, create a new Products with this data.
    **/
    create: XOR<ProductsCreateInput, ProductsUncheckedCreateInput>
    /**
     * In case the Products was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<ProductsUpdateInput, ProductsUncheckedUpdateInput>
  }


  /**
   * Products delete
   */
  export type ProductsDeleteArgs = {
    /**
     * Select specific fields to fetch from the Products
    **/
    select?: ProductsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProductsInclude | null
    /**
     * Filter which Products to delete.
    **/
    where: ProductsWhereUniqueInput
  }


  /**
   * Products deleteMany
   */
  export type ProductsDeleteManyArgs = {
    where?: ProductsWhereInput
  }


  /**
   * Products without action
   */
  export type ProductsArgs = {
    /**
     * Select specific fields to fetch from the Products
    **/
    select?: ProductsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProductsInclude | null
  }



  /**
   * Model ProjectProposals
   */


  export type AggregateProjectProposals = {
    count: ProjectProposalsCountAggregateOutputType | null
    avg: ProjectProposalsAvgAggregateOutputType | null
    sum: ProjectProposalsSumAggregateOutputType | null
    min: ProjectProposalsMinAggregateOutputType | null
    max: ProjectProposalsMaxAggregateOutputType | null
  }

  export type ProjectProposalsAvgAggregateOutputType = {
    id: number
    project_id: number
    created_by: number | null
    updated_by: number | null
  }

  export type ProjectProposalsSumAggregateOutputType = {
    id: number
    project_id: number
    created_by: number | null
    updated_by: number | null
  }

  export type ProjectProposalsMinAggregateOutputType = {
    id: number
    name: string | null
    project_id: number
    proposal_status: string | null
    created_at: Date | null
    updated_at: Date | null
    created_by: number | null
    updated_by: number | null
  }

  export type ProjectProposalsMaxAggregateOutputType = {
    id: number
    name: string | null
    project_id: number
    proposal_status: string | null
    created_at: Date | null
    updated_at: Date | null
    created_by: number | null
    updated_by: number | null
  }

  export type ProjectProposalsCountAggregateOutputType = {
    id: number
    name: number | null
    project_id: number
    proposal_status: number | null
    created_at: number | null
    updated_at: number | null
    created_by: number | null
    updated_by: number | null
    _all: number
  }


  export type ProjectProposalsAvgAggregateInputType = {
    id?: true
    project_id?: true
    created_by?: true
    updated_by?: true
  }

  export type ProjectProposalsSumAggregateInputType = {
    id?: true
    project_id?: true
    created_by?: true
    updated_by?: true
  }

  export type ProjectProposalsMinAggregateInputType = {
    id?: true
    name?: true
    project_id?: true
    proposal_status?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type ProjectProposalsMaxAggregateInputType = {
    id?: true
    name?: true
    project_id?: true
    proposal_status?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type ProjectProposalsCountAggregateInputType = {
    id?: true
    name?: true
    project_id?: true
    proposal_status?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
    _all?: true
  }

  export type ProjectProposalsAggregateArgs = {
    /**
     * Filter which ProjectProposals to aggregate.
    **/
    where?: ProjectProposalsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectProposals to fetch.
    **/
    orderBy?: Enumerable<ProjectProposalsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: ProjectProposalsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectProposals from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectProposals.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectProposals
    **/
    count?: true | ProjectProposalsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: ProjectProposalsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: ProjectProposalsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: ProjectProposalsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: ProjectProposalsMaxAggregateInputType
  }

  export type GetProjectProposalsAggregateType<T extends ProjectProposalsAggregateArgs> = {
    [P in keyof T & keyof AggregateProjectProposals]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectProposals[P]>
      : GetScalarType<T[P], AggregateProjectProposals[P]>
  }



  export type ProjectProposalsSelect = {
    id?: boolean
    name?: boolean
    project_id?: boolean
    proposal_status?: boolean
    created_at?: boolean
    updated_at?: boolean
    created_by?: boolean
    updated_by?: boolean
    Projects?: boolean | ProjectsArgs
    AreaOfWorks?: boolean | AreaOfWorksFindManyArgs
    ScopeOfWorkPropertyUnits?: boolean | ScopeOfWorkPropertyUnitsFindManyArgs
    ScopeOfWorks?: boolean | ScopeOfWorksFindManyArgs
  }

  export type ProjectProposalsInclude = {
    Projects?: boolean | ProjectsArgs
    AreaOfWorks?: boolean | AreaOfWorksFindManyArgs
    ScopeOfWorkPropertyUnits?: boolean | ScopeOfWorkPropertyUnitsFindManyArgs
    ScopeOfWorks?: boolean | ScopeOfWorksFindManyArgs
  }

  export type ProjectProposalsGetPayload<
    S extends boolean | null | undefined | ProjectProposalsArgs,
    U = keyof S
      > = S extends true
        ? ProjectProposals
    : S extends undefined
    ? never
    : S extends ProjectProposalsArgs | ProjectProposalsFindManyArgs
    ?'include' extends U
    ? ProjectProposals  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'Projects'
        ? ProjectsGetPayload<S['include'][P]> :
        P extends 'AreaOfWorks'
        ? Array < AreaOfWorksGetPayload<S['include'][P]>>  :
        P extends 'ScopeOfWorkPropertyUnits'
        ? Array < ScopeOfWorkPropertyUnitsGetPayload<S['include'][P]>>  :
        P extends 'ScopeOfWorks'
        ? Array < ScopeOfWorksGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof ProjectProposals ?ProjectProposals [P]
  : 
          P extends 'Projects'
        ? ProjectsGetPayload<S['select'][P]> :
        P extends 'AreaOfWorks'
        ? Array < AreaOfWorksGetPayload<S['select'][P]>>  :
        P extends 'ScopeOfWorkPropertyUnits'
        ? Array < ScopeOfWorkPropertyUnitsGetPayload<S['select'][P]>>  :
        P extends 'ScopeOfWorks'
        ? Array < ScopeOfWorksGetPayload<S['select'][P]>>  : never
  } 
    : ProjectProposals
  : ProjectProposals


  type ProjectProposalsCountArgs = Merge<
    Omit<ProjectProposalsFindManyArgs, 'select' | 'include'> & {
      select?: ProjectProposalsCountAggregateInputType | true
    }
  >

  export interface ProjectProposalsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one ProjectProposals that matches the filter.
     * @param {ProjectProposalsFindUniqueArgs} args - Arguments to find a ProjectProposals
     * @example
     * // Get one ProjectProposals
     * const projectProposals = await prisma.projectProposals.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProjectProposalsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProjectProposalsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ProjectProposals'> extends True ? CheckSelect<T, Prisma__ProjectProposalsClient<ProjectProposals>, Prisma__ProjectProposalsClient<ProjectProposalsGetPayload<T>>> : CheckSelect<T, Prisma__ProjectProposalsClient<ProjectProposals | null >, Prisma__ProjectProposalsClient<ProjectProposalsGetPayload<T> | null >>

    /**
     * Find the first ProjectProposals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectProposalsFindFirstArgs} args - Arguments to find a ProjectProposals
     * @example
     * // Get one ProjectProposals
     * const projectProposals = await prisma.projectProposals.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProjectProposalsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProjectProposalsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ProjectProposals'> extends True ? CheckSelect<T, Prisma__ProjectProposalsClient<ProjectProposals>, Prisma__ProjectProposalsClient<ProjectProposalsGetPayload<T>>> : CheckSelect<T, Prisma__ProjectProposalsClient<ProjectProposals | null >, Prisma__ProjectProposalsClient<ProjectProposalsGetPayload<T> | null >>

    /**
     * Find zero or more ProjectProposals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectProposalsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectProposals
     * const projectProposals = await prisma.projectProposals.findMany()
     * 
     * // Get first 10 ProjectProposals
     * const projectProposals = await prisma.projectProposals.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectProposalsWithIdOnly = await prisma.projectProposals.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProjectProposalsFindManyArgs>(
      args?: SelectSubset<T, ProjectProposalsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ProjectProposals>>, PrismaPromise<Array<ProjectProposalsGetPayload<T>>>>

    /**
     * Create a ProjectProposals.
     * @param {ProjectProposalsCreateArgs} args - Arguments to create a ProjectProposals.
     * @example
     * // Create one ProjectProposals
     * const ProjectProposals = await prisma.projectProposals.create({
     *   data: {
     *     // ... data to create a ProjectProposals
     *   }
     * })
     * 
    **/
    create<T extends ProjectProposalsCreateArgs>(
      args: SelectSubset<T, ProjectProposalsCreateArgs>
    ): CheckSelect<T, Prisma__ProjectProposalsClient<ProjectProposals>, Prisma__ProjectProposalsClient<ProjectProposalsGetPayload<T>>>

    /**
     * Delete a ProjectProposals.
     * @param {ProjectProposalsDeleteArgs} args - Arguments to delete one ProjectProposals.
     * @example
     * // Delete one ProjectProposals
     * const ProjectProposals = await prisma.projectProposals.delete({
     *   where: {
     *     // ... filter to delete one ProjectProposals
     *   }
     * })
     * 
    **/
    delete<T extends ProjectProposalsDeleteArgs>(
      args: SelectSubset<T, ProjectProposalsDeleteArgs>
    ): CheckSelect<T, Prisma__ProjectProposalsClient<ProjectProposals>, Prisma__ProjectProposalsClient<ProjectProposalsGetPayload<T>>>

    /**
     * Update one ProjectProposals.
     * @param {ProjectProposalsUpdateArgs} args - Arguments to update one ProjectProposals.
     * @example
     * // Update one ProjectProposals
     * const projectProposals = await prisma.projectProposals.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProjectProposalsUpdateArgs>(
      args: SelectSubset<T, ProjectProposalsUpdateArgs>
    ): CheckSelect<T, Prisma__ProjectProposalsClient<ProjectProposals>, Prisma__ProjectProposalsClient<ProjectProposalsGetPayload<T>>>

    /**
     * Delete zero or more ProjectProposals.
     * @param {ProjectProposalsDeleteManyArgs} args - Arguments to filter ProjectProposals to delete.
     * @example
     * // Delete a few ProjectProposals
     * const { count } = await prisma.projectProposals.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProjectProposalsDeleteManyArgs>(
      args?: SelectSubset<T, ProjectProposalsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectProposals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectProposalsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectProposals
     * const projectProposals = await prisma.projectProposals.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProjectProposalsUpdateManyArgs>(
      args: SelectSubset<T, ProjectProposalsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ProjectProposals.
     * @param {ProjectProposalsUpsertArgs} args - Arguments to update or create a ProjectProposals.
     * @example
     * // Update or create a ProjectProposals
     * const projectProposals = await prisma.projectProposals.upsert({
     *   create: {
     *     // ... data to create a ProjectProposals
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectProposals we want to update
     *   }
     * })
    **/
    upsert<T extends ProjectProposalsUpsertArgs>(
      args: SelectSubset<T, ProjectProposalsUpsertArgs>
    ): CheckSelect<T, Prisma__ProjectProposalsClient<ProjectProposals>, Prisma__ProjectProposalsClient<ProjectProposalsGetPayload<T>>>

    /**
     * Count the number of ProjectProposals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectProposalsCountArgs} args - Arguments to filter ProjectProposals to count.
     * @example
     * // Count the number of ProjectProposals
     * const count = await prisma.projectProposals.count({
     *   where: {
     *     // ... the filter for the ProjectProposals we want to count
     *   }
     * })
    **/
    count<T extends ProjectProposalsCountArgs>(
      args?: Subset<T, ProjectProposalsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectProposalsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectProposals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectProposalsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectProposalsAggregateArgs>(args: Subset<T, ProjectProposalsAggregateArgs>): PrismaPromise<GetProjectProposalsAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectProposals.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProjectProposalsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Projects<T extends ProjectsArgs = {}>(args?: Subset<T, ProjectsArgs>): CheckSelect<T, Prisma__ProjectsClient<Projects | null >, Prisma__ProjectsClient<ProjectsGetPayload<T> | null >>;

    AreaOfWorks<T extends AreaOfWorksFindManyArgs = {}>(args?: Subset<T, AreaOfWorksFindManyArgs>): CheckSelect<T, PrismaPromise<Array<AreaOfWorks>>, PrismaPromise<Array<AreaOfWorksGetPayload<T>>>>;

    ScopeOfWorkPropertyUnits<T extends ScopeOfWorkPropertyUnitsFindManyArgs = {}>(args?: Subset<T, ScopeOfWorkPropertyUnitsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ScopeOfWorkPropertyUnits>>, PrismaPromise<Array<ScopeOfWorkPropertyUnitsGetPayload<T>>>>;

    ScopeOfWorks<T extends ScopeOfWorksFindManyArgs = {}>(args?: Subset<T, ScopeOfWorksFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ScopeOfWorks>>, PrismaPromise<Array<ScopeOfWorksGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * ProjectProposals findUnique
   */
  export type ProjectProposalsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the ProjectProposals
    **/
    select?: ProjectProposalsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProjectProposalsInclude | null
    /**
     * Throw an Error if a ProjectProposals can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ProjectProposals to fetch.
    **/
    where: ProjectProposalsWhereUniqueInput
  }


  /**
   * ProjectProposals findFirst
   */
  export type ProjectProposalsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the ProjectProposals
    **/
    select?: ProjectProposalsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProjectProposalsInclude | null
    /**
     * Throw an Error if a ProjectProposals can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ProjectProposals to fetch.
    **/
    where?: ProjectProposalsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectProposals to fetch.
    **/
    orderBy?: Enumerable<ProjectProposalsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectProposals.
    **/
    cursor?: ProjectProposalsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectProposals from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectProposals.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectProposals.
    **/
    distinct?: Enumerable<ProjectProposalsScalarFieldEnum>
  }


  /**
   * ProjectProposals findMany
   */
  export type ProjectProposalsFindManyArgs = {
    /**
     * Select specific fields to fetch from the ProjectProposals
    **/
    select?: ProjectProposalsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProjectProposalsInclude | null
    /**
     * Filter, which ProjectProposals to fetch.
    **/
    where?: ProjectProposalsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectProposals to fetch.
    **/
    orderBy?: Enumerable<ProjectProposalsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectProposals.
    **/
    cursor?: ProjectProposalsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectProposals from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectProposals.
    **/
    skip?: number
    distinct?: Enumerable<ProjectProposalsScalarFieldEnum>
  }


  /**
   * ProjectProposals create
   */
  export type ProjectProposalsCreateArgs = {
    /**
     * Select specific fields to fetch from the ProjectProposals
    **/
    select?: ProjectProposalsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProjectProposalsInclude | null
    /**
     * The data needed to create a ProjectProposals.
    **/
    data: XOR<ProjectProposalsCreateInput, ProjectProposalsUncheckedCreateInput>
  }


  /**
   * ProjectProposals update
   */
  export type ProjectProposalsUpdateArgs = {
    /**
     * Select specific fields to fetch from the ProjectProposals
    **/
    select?: ProjectProposalsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProjectProposalsInclude | null
    /**
     * The data needed to update a ProjectProposals.
    **/
    data: XOR<ProjectProposalsUpdateInput, ProjectProposalsUncheckedUpdateInput>
    /**
     * Choose, which ProjectProposals to update.
    **/
    where: ProjectProposalsWhereUniqueInput
  }


  /**
   * ProjectProposals updateMany
   */
  export type ProjectProposalsUpdateManyArgs = {
    data: XOR<ProjectProposalsUpdateManyMutationInput, ProjectProposalsUncheckedUpdateManyInput>
    where?: ProjectProposalsWhereInput
  }


  /**
   * ProjectProposals upsert
   */
  export type ProjectProposalsUpsertArgs = {
    /**
     * Select specific fields to fetch from the ProjectProposals
    **/
    select?: ProjectProposalsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProjectProposalsInclude | null
    /**
     * The filter to search for the ProjectProposals to update in case it exists.
    **/
    where: ProjectProposalsWhereUniqueInput
    /**
     * In case the ProjectProposals found by the `where` argument doesn't exist, create a new ProjectProposals with this data.
    **/
    create: XOR<ProjectProposalsCreateInput, ProjectProposalsUncheckedCreateInput>
    /**
     * In case the ProjectProposals was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<ProjectProposalsUpdateInput, ProjectProposalsUncheckedUpdateInput>
  }


  /**
   * ProjectProposals delete
   */
  export type ProjectProposalsDeleteArgs = {
    /**
     * Select specific fields to fetch from the ProjectProposals
    **/
    select?: ProjectProposalsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProjectProposalsInclude | null
    /**
     * Filter which ProjectProposals to delete.
    **/
    where: ProjectProposalsWhereUniqueInput
  }


  /**
   * ProjectProposals deleteMany
   */
  export type ProjectProposalsDeleteManyArgs = {
    where?: ProjectProposalsWhereInput
  }


  /**
   * ProjectProposals without action
   */
  export type ProjectProposalsArgs = {
    /**
     * Select specific fields to fetch from the ProjectProposals
    **/
    select?: ProjectProposalsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProjectProposalsInclude | null
  }



  /**
   * Model Projects
   */


  export type AggregateProjects = {
    count: ProjectsCountAggregateOutputType | null
    avg: ProjectsAvgAggregateOutputType | null
    sum: ProjectsSumAggregateOutputType | null
    min: ProjectsMinAggregateOutputType | null
    max: ProjectsMaxAggregateOutputType | null
  }

  export type ProjectsAvgAggregateOutputType = {
    id: number
    property_address_id: number
    created_by: number | null
    updated_by: number | null
  }

  export type ProjectsSumAggregateOutputType = {
    id: number
    property_address_id: number
    created_by: number | null
    updated_by: number | null
  }

  export type ProjectsMinAggregateOutputType = {
    id: number
    name: string | null
    property_address_id: number
    created_at: Date | null
    updated_at: Date | null
    created_by: number | null
    updated_by: number | null
    start_date: Date | null
  }

  export type ProjectsMaxAggregateOutputType = {
    id: number
    name: string | null
    property_address_id: number
    created_at: Date | null
    updated_at: Date | null
    created_by: number | null
    updated_by: number | null
    start_date: Date | null
  }

  export type ProjectsCountAggregateOutputType = {
    id: number
    name: number | null
    property_address_id: number
    created_at: number | null
    updated_at: number | null
    created_by: number | null
    updated_by: number | null
    start_date: number | null
    _all: number
  }


  export type ProjectsAvgAggregateInputType = {
    id?: true
    property_address_id?: true
    created_by?: true
    updated_by?: true
  }

  export type ProjectsSumAggregateInputType = {
    id?: true
    property_address_id?: true
    created_by?: true
    updated_by?: true
  }

  export type ProjectsMinAggregateInputType = {
    id?: true
    name?: true
    property_address_id?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
    start_date?: true
  }

  export type ProjectsMaxAggregateInputType = {
    id?: true
    name?: true
    property_address_id?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
    start_date?: true
  }

  export type ProjectsCountAggregateInputType = {
    id?: true
    name?: true
    property_address_id?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
    start_date?: true
    _all?: true
  }

  export type ProjectsAggregateArgs = {
    /**
     * Filter which Projects to aggregate.
    **/
    where?: ProjectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
    **/
    orderBy?: Enumerable<ProjectsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: ProjectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Projects
    **/
    count?: true | ProjectsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: ProjectsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: ProjectsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: ProjectsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: ProjectsMaxAggregateInputType
  }

  export type GetProjectsAggregateType<T extends ProjectsAggregateArgs> = {
    [P in keyof T & keyof AggregateProjects]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjects[P]>
      : GetScalarType<T[P], AggregateProjects[P]>
  }



  export type ProjectsSelect = {
    id?: boolean
    name?: boolean
    property_address_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    created_by?: boolean
    updated_by?: boolean
    start_date?: boolean
    Property_Addresses?: boolean | Property_AddressesArgs
    ProjectProposals?: boolean | ProjectProposalsFindManyArgs
    ProjectTypeAssociations?: boolean | ProjectTypeAssociationsFindManyArgs
  }

  export type ProjectsInclude = {
    Property_Addresses?: boolean | Property_AddressesArgs
    ProjectProposals?: boolean | ProjectProposalsFindManyArgs
    ProjectTypeAssociations?: boolean | ProjectTypeAssociationsFindManyArgs
  }

  export type ProjectsGetPayload<
    S extends boolean | null | undefined | ProjectsArgs,
    U = keyof S
      > = S extends true
        ? Projects
    : S extends undefined
    ? never
    : S extends ProjectsArgs | ProjectsFindManyArgs
    ?'include' extends U
    ? Projects  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'Property_Addresses'
        ? Property_AddressesGetPayload<S['include'][P]> :
        P extends 'ProjectProposals'
        ? Array < ProjectProposalsGetPayload<S['include'][P]>>  :
        P extends 'ProjectTypeAssociations'
        ? Array < ProjectTypeAssociationsGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Projects ?Projects [P]
  : 
          P extends 'Property_Addresses'
        ? Property_AddressesGetPayload<S['select'][P]> :
        P extends 'ProjectProposals'
        ? Array < ProjectProposalsGetPayload<S['select'][P]>>  :
        P extends 'ProjectTypeAssociations'
        ? Array < ProjectTypeAssociationsGetPayload<S['select'][P]>>  : never
  } 
    : Projects
  : Projects


  type ProjectsCountArgs = Merge<
    Omit<ProjectsFindManyArgs, 'select' | 'include'> & {
      select?: ProjectsCountAggregateInputType | true
    }
  >

  export interface ProjectsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Projects that matches the filter.
     * @param {ProjectsFindUniqueArgs} args - Arguments to find a Projects
     * @example
     * // Get one Projects
     * const projects = await prisma.projects.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProjectsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProjectsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Projects'> extends True ? CheckSelect<T, Prisma__ProjectsClient<Projects>, Prisma__ProjectsClient<ProjectsGetPayload<T>>> : CheckSelect<T, Prisma__ProjectsClient<Projects | null >, Prisma__ProjectsClient<ProjectsGetPayload<T> | null >>

    /**
     * Find the first Projects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectsFindFirstArgs} args - Arguments to find a Projects
     * @example
     * // Get one Projects
     * const projects = await prisma.projects.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProjectsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProjectsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Projects'> extends True ? CheckSelect<T, Prisma__ProjectsClient<Projects>, Prisma__ProjectsClient<ProjectsGetPayload<T>>> : CheckSelect<T, Prisma__ProjectsClient<Projects | null >, Prisma__ProjectsClient<ProjectsGetPayload<T> | null >>

    /**
     * Find zero or more Projects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projects
     * const projects = await prisma.projects.findMany()
     * 
     * // Get first 10 Projects
     * const projects = await prisma.projects.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectsWithIdOnly = await prisma.projects.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProjectsFindManyArgs>(
      args?: SelectSubset<T, ProjectsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Projects>>, PrismaPromise<Array<ProjectsGetPayload<T>>>>

    /**
     * Create a Projects.
     * @param {ProjectsCreateArgs} args - Arguments to create a Projects.
     * @example
     * // Create one Projects
     * const Projects = await prisma.projects.create({
     *   data: {
     *     // ... data to create a Projects
     *   }
     * })
     * 
    **/
    create<T extends ProjectsCreateArgs>(
      args: SelectSubset<T, ProjectsCreateArgs>
    ): CheckSelect<T, Prisma__ProjectsClient<Projects>, Prisma__ProjectsClient<ProjectsGetPayload<T>>>

    /**
     * Delete a Projects.
     * @param {ProjectsDeleteArgs} args - Arguments to delete one Projects.
     * @example
     * // Delete one Projects
     * const Projects = await prisma.projects.delete({
     *   where: {
     *     // ... filter to delete one Projects
     *   }
     * })
     * 
    **/
    delete<T extends ProjectsDeleteArgs>(
      args: SelectSubset<T, ProjectsDeleteArgs>
    ): CheckSelect<T, Prisma__ProjectsClient<Projects>, Prisma__ProjectsClient<ProjectsGetPayload<T>>>

    /**
     * Update one Projects.
     * @param {ProjectsUpdateArgs} args - Arguments to update one Projects.
     * @example
     * // Update one Projects
     * const projects = await prisma.projects.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProjectsUpdateArgs>(
      args: SelectSubset<T, ProjectsUpdateArgs>
    ): CheckSelect<T, Prisma__ProjectsClient<Projects>, Prisma__ProjectsClient<ProjectsGetPayload<T>>>

    /**
     * Delete zero or more Projects.
     * @param {ProjectsDeleteManyArgs} args - Arguments to filter Projects to delete.
     * @example
     * // Delete a few Projects
     * const { count } = await prisma.projects.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProjectsDeleteManyArgs>(
      args?: SelectSubset<T, ProjectsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projects
     * const projects = await prisma.projects.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProjectsUpdateManyArgs>(
      args: SelectSubset<T, ProjectsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Projects.
     * @param {ProjectsUpsertArgs} args - Arguments to update or create a Projects.
     * @example
     * // Update or create a Projects
     * const projects = await prisma.projects.upsert({
     *   create: {
     *     // ... data to create a Projects
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Projects we want to update
     *   }
     * })
    **/
    upsert<T extends ProjectsUpsertArgs>(
      args: SelectSubset<T, ProjectsUpsertArgs>
    ): CheckSelect<T, Prisma__ProjectsClient<Projects>, Prisma__ProjectsClient<ProjectsGetPayload<T>>>

    /**
     * Count the number of Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectsCountArgs} args - Arguments to filter Projects to count.
     * @example
     * // Count the number of Projects
     * const count = await prisma.projects.count({
     *   where: {
     *     // ... the filter for the Projects we want to count
     *   }
     * })
    **/
    count<T extends ProjectsCountArgs>(
      args?: Subset<T, ProjectsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectsAggregateArgs>(args: Subset<T, ProjectsAggregateArgs>): PrismaPromise<GetProjectsAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for Projects.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProjectsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Property_Addresses<T extends Property_AddressesArgs = {}>(args?: Subset<T, Property_AddressesArgs>): CheckSelect<T, Prisma__Property_AddressesClient<Property_Addresses | null >, Prisma__Property_AddressesClient<Property_AddressesGetPayload<T> | null >>;

    ProjectProposals<T extends ProjectProposalsFindManyArgs = {}>(args?: Subset<T, ProjectProposalsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ProjectProposals>>, PrismaPromise<Array<ProjectProposalsGetPayload<T>>>>;

    ProjectTypeAssociations<T extends ProjectTypeAssociationsFindManyArgs = {}>(args?: Subset<T, ProjectTypeAssociationsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ProjectTypeAssociations>>, PrismaPromise<Array<ProjectTypeAssociationsGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Projects findUnique
   */
  export type ProjectsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Projects
    **/
    select?: ProjectsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProjectsInclude | null
    /**
     * Throw an Error if a Projects can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Projects to fetch.
    **/
    where: ProjectsWhereUniqueInput
  }


  /**
   * Projects findFirst
   */
  export type ProjectsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Projects
    **/
    select?: ProjectsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProjectsInclude | null
    /**
     * Throw an Error if a Projects can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Projects to fetch.
    **/
    where?: ProjectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
    **/
    orderBy?: Enumerable<ProjectsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
    **/
    cursor?: ProjectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
    **/
    distinct?: Enumerable<ProjectsScalarFieldEnum>
  }


  /**
   * Projects findMany
   */
  export type ProjectsFindManyArgs = {
    /**
     * Select specific fields to fetch from the Projects
    **/
    select?: ProjectsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProjectsInclude | null
    /**
     * Filter, which Projects to fetch.
    **/
    where?: ProjectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
    **/
    orderBy?: Enumerable<ProjectsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Projects.
    **/
    cursor?: ProjectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
    **/
    skip?: number
    distinct?: Enumerable<ProjectsScalarFieldEnum>
  }


  /**
   * Projects create
   */
  export type ProjectsCreateArgs = {
    /**
     * Select specific fields to fetch from the Projects
    **/
    select?: ProjectsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProjectsInclude | null
    /**
     * The data needed to create a Projects.
    **/
    data: XOR<ProjectsCreateInput, ProjectsUncheckedCreateInput>
  }


  /**
   * Projects update
   */
  export type ProjectsUpdateArgs = {
    /**
     * Select specific fields to fetch from the Projects
    **/
    select?: ProjectsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProjectsInclude | null
    /**
     * The data needed to update a Projects.
    **/
    data: XOR<ProjectsUpdateInput, ProjectsUncheckedUpdateInput>
    /**
     * Choose, which Projects to update.
    **/
    where: ProjectsWhereUniqueInput
  }


  /**
   * Projects updateMany
   */
  export type ProjectsUpdateManyArgs = {
    data: XOR<ProjectsUpdateManyMutationInput, ProjectsUncheckedUpdateManyInput>
    where?: ProjectsWhereInput
  }


  /**
   * Projects upsert
   */
  export type ProjectsUpsertArgs = {
    /**
     * Select specific fields to fetch from the Projects
    **/
    select?: ProjectsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProjectsInclude | null
    /**
     * The filter to search for the Projects to update in case it exists.
    **/
    where: ProjectsWhereUniqueInput
    /**
     * In case the Projects found by the `where` argument doesn't exist, create a new Projects with this data.
    **/
    create: XOR<ProjectsCreateInput, ProjectsUncheckedCreateInput>
    /**
     * In case the Projects was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<ProjectsUpdateInput, ProjectsUncheckedUpdateInput>
  }


  /**
   * Projects delete
   */
  export type ProjectsDeleteArgs = {
    /**
     * Select specific fields to fetch from the Projects
    **/
    select?: ProjectsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProjectsInclude | null
    /**
     * Filter which Projects to delete.
    **/
    where: ProjectsWhereUniqueInput
  }


  /**
   * Projects deleteMany
   */
  export type ProjectsDeleteManyArgs = {
    where?: ProjectsWhereInput
  }


  /**
   * Projects without action
   */
  export type ProjectsArgs = {
    /**
     * Select specific fields to fetch from the Projects
    **/
    select?: ProjectsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProjectsInclude | null
  }



  /**
   * Model ProjectTypeAssociations
   */


  export type AggregateProjectTypeAssociations = {
    count: ProjectTypeAssociationsCountAggregateOutputType | null
    avg: ProjectTypeAssociationsAvgAggregateOutputType | null
    sum: ProjectTypeAssociationsSumAggregateOutputType | null
    min: ProjectTypeAssociationsMinAggregateOutputType | null
    max: ProjectTypeAssociationsMaxAggregateOutputType | null
  }

  export type ProjectTypeAssociationsAvgAggregateOutputType = {
    id: number
    project_id: number
    project_type_id: number
    created_by: number | null
    updated_by: number | null
  }

  export type ProjectTypeAssociationsSumAggregateOutputType = {
    id: number
    project_id: number
    project_type_id: number
    created_by: number | null
    updated_by: number | null
  }

  export type ProjectTypeAssociationsMinAggregateOutputType = {
    id: number
    project_id: number
    project_type_id: number
    created_at: Date | null
    updated_at: Date | null
    created_by: number | null
    updated_by: number | null
  }

  export type ProjectTypeAssociationsMaxAggregateOutputType = {
    id: number
    project_id: number
    project_type_id: number
    created_at: Date | null
    updated_at: Date | null
    created_by: number | null
    updated_by: number | null
  }

  export type ProjectTypeAssociationsCountAggregateOutputType = {
    id: number
    project_id: number
    project_type_id: number
    created_at: number | null
    updated_at: number | null
    created_by: number | null
    updated_by: number | null
    _all: number
  }


  export type ProjectTypeAssociationsAvgAggregateInputType = {
    id?: true
    project_id?: true
    project_type_id?: true
    created_by?: true
    updated_by?: true
  }

  export type ProjectTypeAssociationsSumAggregateInputType = {
    id?: true
    project_id?: true
    project_type_id?: true
    created_by?: true
    updated_by?: true
  }

  export type ProjectTypeAssociationsMinAggregateInputType = {
    id?: true
    project_id?: true
    project_type_id?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type ProjectTypeAssociationsMaxAggregateInputType = {
    id?: true
    project_id?: true
    project_type_id?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type ProjectTypeAssociationsCountAggregateInputType = {
    id?: true
    project_id?: true
    project_type_id?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
    _all?: true
  }

  export type ProjectTypeAssociationsAggregateArgs = {
    /**
     * Filter which ProjectTypeAssociations to aggregate.
    **/
    where?: ProjectTypeAssociationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectTypeAssociations to fetch.
    **/
    orderBy?: Enumerable<ProjectTypeAssociationsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: ProjectTypeAssociationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectTypeAssociations from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectTypeAssociations.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectTypeAssociations
    **/
    count?: true | ProjectTypeAssociationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: ProjectTypeAssociationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: ProjectTypeAssociationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: ProjectTypeAssociationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: ProjectTypeAssociationsMaxAggregateInputType
  }

  export type GetProjectTypeAssociationsAggregateType<T extends ProjectTypeAssociationsAggregateArgs> = {
    [P in keyof T & keyof AggregateProjectTypeAssociations]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectTypeAssociations[P]>
      : GetScalarType<T[P], AggregateProjectTypeAssociations[P]>
  }



  export type ProjectTypeAssociationsSelect = {
    id?: boolean
    project_id?: boolean
    project_type_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    created_by?: boolean
    updated_by?: boolean
    Projects?: boolean | ProjectsArgs
    ProjectTypes?: boolean | ProjectTypesArgs
  }

  export type ProjectTypeAssociationsInclude = {
    Projects?: boolean | ProjectsArgs
    ProjectTypes?: boolean | ProjectTypesArgs
  }

  export type ProjectTypeAssociationsGetPayload<
    S extends boolean | null | undefined | ProjectTypeAssociationsArgs,
    U = keyof S
      > = S extends true
        ? ProjectTypeAssociations
    : S extends undefined
    ? never
    : S extends ProjectTypeAssociationsArgs | ProjectTypeAssociationsFindManyArgs
    ?'include' extends U
    ? ProjectTypeAssociations  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'Projects'
        ? ProjectsGetPayload<S['include'][P]> :
        P extends 'ProjectTypes'
        ? ProjectTypesGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof ProjectTypeAssociations ?ProjectTypeAssociations [P]
  : 
          P extends 'Projects'
        ? ProjectsGetPayload<S['select'][P]> :
        P extends 'ProjectTypes'
        ? ProjectTypesGetPayload<S['select'][P]> : never
  } 
    : ProjectTypeAssociations
  : ProjectTypeAssociations


  type ProjectTypeAssociationsCountArgs = Merge<
    Omit<ProjectTypeAssociationsFindManyArgs, 'select' | 'include'> & {
      select?: ProjectTypeAssociationsCountAggregateInputType | true
    }
  >

  export interface ProjectTypeAssociationsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one ProjectTypeAssociations that matches the filter.
     * @param {ProjectTypeAssociationsFindUniqueArgs} args - Arguments to find a ProjectTypeAssociations
     * @example
     * // Get one ProjectTypeAssociations
     * const projectTypeAssociations = await prisma.projectTypeAssociations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProjectTypeAssociationsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProjectTypeAssociationsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ProjectTypeAssociations'> extends True ? CheckSelect<T, Prisma__ProjectTypeAssociationsClient<ProjectTypeAssociations>, Prisma__ProjectTypeAssociationsClient<ProjectTypeAssociationsGetPayload<T>>> : CheckSelect<T, Prisma__ProjectTypeAssociationsClient<ProjectTypeAssociations | null >, Prisma__ProjectTypeAssociationsClient<ProjectTypeAssociationsGetPayload<T> | null >>

    /**
     * Find the first ProjectTypeAssociations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTypeAssociationsFindFirstArgs} args - Arguments to find a ProjectTypeAssociations
     * @example
     * // Get one ProjectTypeAssociations
     * const projectTypeAssociations = await prisma.projectTypeAssociations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProjectTypeAssociationsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProjectTypeAssociationsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ProjectTypeAssociations'> extends True ? CheckSelect<T, Prisma__ProjectTypeAssociationsClient<ProjectTypeAssociations>, Prisma__ProjectTypeAssociationsClient<ProjectTypeAssociationsGetPayload<T>>> : CheckSelect<T, Prisma__ProjectTypeAssociationsClient<ProjectTypeAssociations | null >, Prisma__ProjectTypeAssociationsClient<ProjectTypeAssociationsGetPayload<T> | null >>

    /**
     * Find zero or more ProjectTypeAssociations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTypeAssociationsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectTypeAssociations
     * const projectTypeAssociations = await prisma.projectTypeAssociations.findMany()
     * 
     * // Get first 10 ProjectTypeAssociations
     * const projectTypeAssociations = await prisma.projectTypeAssociations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectTypeAssociationsWithIdOnly = await prisma.projectTypeAssociations.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProjectTypeAssociationsFindManyArgs>(
      args?: SelectSubset<T, ProjectTypeAssociationsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ProjectTypeAssociations>>, PrismaPromise<Array<ProjectTypeAssociationsGetPayload<T>>>>

    /**
     * Create a ProjectTypeAssociations.
     * @param {ProjectTypeAssociationsCreateArgs} args - Arguments to create a ProjectTypeAssociations.
     * @example
     * // Create one ProjectTypeAssociations
     * const ProjectTypeAssociations = await prisma.projectTypeAssociations.create({
     *   data: {
     *     // ... data to create a ProjectTypeAssociations
     *   }
     * })
     * 
    **/
    create<T extends ProjectTypeAssociationsCreateArgs>(
      args: SelectSubset<T, ProjectTypeAssociationsCreateArgs>
    ): CheckSelect<T, Prisma__ProjectTypeAssociationsClient<ProjectTypeAssociations>, Prisma__ProjectTypeAssociationsClient<ProjectTypeAssociationsGetPayload<T>>>

    /**
     * Delete a ProjectTypeAssociations.
     * @param {ProjectTypeAssociationsDeleteArgs} args - Arguments to delete one ProjectTypeAssociations.
     * @example
     * // Delete one ProjectTypeAssociations
     * const ProjectTypeAssociations = await prisma.projectTypeAssociations.delete({
     *   where: {
     *     // ... filter to delete one ProjectTypeAssociations
     *   }
     * })
     * 
    **/
    delete<T extends ProjectTypeAssociationsDeleteArgs>(
      args: SelectSubset<T, ProjectTypeAssociationsDeleteArgs>
    ): CheckSelect<T, Prisma__ProjectTypeAssociationsClient<ProjectTypeAssociations>, Prisma__ProjectTypeAssociationsClient<ProjectTypeAssociationsGetPayload<T>>>

    /**
     * Update one ProjectTypeAssociations.
     * @param {ProjectTypeAssociationsUpdateArgs} args - Arguments to update one ProjectTypeAssociations.
     * @example
     * // Update one ProjectTypeAssociations
     * const projectTypeAssociations = await prisma.projectTypeAssociations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProjectTypeAssociationsUpdateArgs>(
      args: SelectSubset<T, ProjectTypeAssociationsUpdateArgs>
    ): CheckSelect<T, Prisma__ProjectTypeAssociationsClient<ProjectTypeAssociations>, Prisma__ProjectTypeAssociationsClient<ProjectTypeAssociationsGetPayload<T>>>

    /**
     * Delete zero or more ProjectTypeAssociations.
     * @param {ProjectTypeAssociationsDeleteManyArgs} args - Arguments to filter ProjectTypeAssociations to delete.
     * @example
     * // Delete a few ProjectTypeAssociations
     * const { count } = await prisma.projectTypeAssociations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProjectTypeAssociationsDeleteManyArgs>(
      args?: SelectSubset<T, ProjectTypeAssociationsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectTypeAssociations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTypeAssociationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectTypeAssociations
     * const projectTypeAssociations = await prisma.projectTypeAssociations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProjectTypeAssociationsUpdateManyArgs>(
      args: SelectSubset<T, ProjectTypeAssociationsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ProjectTypeAssociations.
     * @param {ProjectTypeAssociationsUpsertArgs} args - Arguments to update or create a ProjectTypeAssociations.
     * @example
     * // Update or create a ProjectTypeAssociations
     * const projectTypeAssociations = await prisma.projectTypeAssociations.upsert({
     *   create: {
     *     // ... data to create a ProjectTypeAssociations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectTypeAssociations we want to update
     *   }
     * })
    **/
    upsert<T extends ProjectTypeAssociationsUpsertArgs>(
      args: SelectSubset<T, ProjectTypeAssociationsUpsertArgs>
    ): CheckSelect<T, Prisma__ProjectTypeAssociationsClient<ProjectTypeAssociations>, Prisma__ProjectTypeAssociationsClient<ProjectTypeAssociationsGetPayload<T>>>

    /**
     * Count the number of ProjectTypeAssociations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTypeAssociationsCountArgs} args - Arguments to filter ProjectTypeAssociations to count.
     * @example
     * // Count the number of ProjectTypeAssociations
     * const count = await prisma.projectTypeAssociations.count({
     *   where: {
     *     // ... the filter for the ProjectTypeAssociations we want to count
     *   }
     * })
    **/
    count<T extends ProjectTypeAssociationsCountArgs>(
      args?: Subset<T, ProjectTypeAssociationsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectTypeAssociationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectTypeAssociations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTypeAssociationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectTypeAssociationsAggregateArgs>(args: Subset<T, ProjectTypeAssociationsAggregateArgs>): PrismaPromise<GetProjectTypeAssociationsAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectTypeAssociations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProjectTypeAssociationsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Projects<T extends ProjectsArgs = {}>(args?: Subset<T, ProjectsArgs>): CheckSelect<T, Prisma__ProjectsClient<Projects | null >, Prisma__ProjectsClient<ProjectsGetPayload<T> | null >>;

    ProjectTypes<T extends ProjectTypesArgs = {}>(args?: Subset<T, ProjectTypesArgs>): CheckSelect<T, Prisma__ProjectTypesClient<ProjectTypes | null >, Prisma__ProjectTypesClient<ProjectTypesGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * ProjectTypeAssociations findUnique
   */
  export type ProjectTypeAssociationsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the ProjectTypeAssociations
    **/
    select?: ProjectTypeAssociationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProjectTypeAssociationsInclude | null
    /**
     * Throw an Error if a ProjectTypeAssociations can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ProjectTypeAssociations to fetch.
    **/
    where: ProjectTypeAssociationsWhereUniqueInput
  }


  /**
   * ProjectTypeAssociations findFirst
   */
  export type ProjectTypeAssociationsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the ProjectTypeAssociations
    **/
    select?: ProjectTypeAssociationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProjectTypeAssociationsInclude | null
    /**
     * Throw an Error if a ProjectTypeAssociations can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ProjectTypeAssociations to fetch.
    **/
    where?: ProjectTypeAssociationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectTypeAssociations to fetch.
    **/
    orderBy?: Enumerable<ProjectTypeAssociationsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectTypeAssociations.
    **/
    cursor?: ProjectTypeAssociationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectTypeAssociations from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectTypeAssociations.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectTypeAssociations.
    **/
    distinct?: Enumerable<ProjectTypeAssociationsScalarFieldEnum>
  }


  /**
   * ProjectTypeAssociations findMany
   */
  export type ProjectTypeAssociationsFindManyArgs = {
    /**
     * Select specific fields to fetch from the ProjectTypeAssociations
    **/
    select?: ProjectTypeAssociationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProjectTypeAssociationsInclude | null
    /**
     * Filter, which ProjectTypeAssociations to fetch.
    **/
    where?: ProjectTypeAssociationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectTypeAssociations to fetch.
    **/
    orderBy?: Enumerable<ProjectTypeAssociationsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectTypeAssociations.
    **/
    cursor?: ProjectTypeAssociationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectTypeAssociations from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectTypeAssociations.
    **/
    skip?: number
    distinct?: Enumerable<ProjectTypeAssociationsScalarFieldEnum>
  }


  /**
   * ProjectTypeAssociations create
   */
  export type ProjectTypeAssociationsCreateArgs = {
    /**
     * Select specific fields to fetch from the ProjectTypeAssociations
    **/
    select?: ProjectTypeAssociationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProjectTypeAssociationsInclude | null
    /**
     * The data needed to create a ProjectTypeAssociations.
    **/
    data: XOR<ProjectTypeAssociationsCreateInput, ProjectTypeAssociationsUncheckedCreateInput>
  }


  /**
   * ProjectTypeAssociations update
   */
  export type ProjectTypeAssociationsUpdateArgs = {
    /**
     * Select specific fields to fetch from the ProjectTypeAssociations
    **/
    select?: ProjectTypeAssociationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProjectTypeAssociationsInclude | null
    /**
     * The data needed to update a ProjectTypeAssociations.
    **/
    data: XOR<ProjectTypeAssociationsUpdateInput, ProjectTypeAssociationsUncheckedUpdateInput>
    /**
     * Choose, which ProjectTypeAssociations to update.
    **/
    where: ProjectTypeAssociationsWhereUniqueInput
  }


  /**
   * ProjectTypeAssociations updateMany
   */
  export type ProjectTypeAssociationsUpdateManyArgs = {
    data: XOR<ProjectTypeAssociationsUpdateManyMutationInput, ProjectTypeAssociationsUncheckedUpdateManyInput>
    where?: ProjectTypeAssociationsWhereInput
  }


  /**
   * ProjectTypeAssociations upsert
   */
  export type ProjectTypeAssociationsUpsertArgs = {
    /**
     * Select specific fields to fetch from the ProjectTypeAssociations
    **/
    select?: ProjectTypeAssociationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProjectTypeAssociationsInclude | null
    /**
     * The filter to search for the ProjectTypeAssociations to update in case it exists.
    **/
    where: ProjectTypeAssociationsWhereUniqueInput
    /**
     * In case the ProjectTypeAssociations found by the `where` argument doesn't exist, create a new ProjectTypeAssociations with this data.
    **/
    create: XOR<ProjectTypeAssociationsCreateInput, ProjectTypeAssociationsUncheckedCreateInput>
    /**
     * In case the ProjectTypeAssociations was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<ProjectTypeAssociationsUpdateInput, ProjectTypeAssociationsUncheckedUpdateInput>
  }


  /**
   * ProjectTypeAssociations delete
   */
  export type ProjectTypeAssociationsDeleteArgs = {
    /**
     * Select specific fields to fetch from the ProjectTypeAssociations
    **/
    select?: ProjectTypeAssociationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProjectTypeAssociationsInclude | null
    /**
     * Filter which ProjectTypeAssociations to delete.
    **/
    where: ProjectTypeAssociationsWhereUniqueInput
  }


  /**
   * ProjectTypeAssociations deleteMany
   */
  export type ProjectTypeAssociationsDeleteManyArgs = {
    where?: ProjectTypeAssociationsWhereInput
  }


  /**
   * ProjectTypeAssociations without action
   */
  export type ProjectTypeAssociationsArgs = {
    /**
     * Select specific fields to fetch from the ProjectTypeAssociations
    **/
    select?: ProjectTypeAssociationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProjectTypeAssociationsInclude | null
  }



  /**
   * Model ProjectTypes
   */


  export type AggregateProjectTypes = {
    count: ProjectTypesCountAggregateOutputType | null
    avg: ProjectTypesAvgAggregateOutputType | null
    sum: ProjectTypesSumAggregateOutputType | null
    min: ProjectTypesMinAggregateOutputType | null
    max: ProjectTypesMaxAggregateOutputType | null
  }

  export type ProjectTypesAvgAggregateOutputType = {
    id: number
    created_by: number | null
    updated_by: number | null
  }

  export type ProjectTypesSumAggregateOutputType = {
    id: number
    created_by: number | null
    updated_by: number | null
  }

  export type ProjectTypesMinAggregateOutputType = {
    id: number
    type: string | null
    slug: string | null
    created_at: Date | null
    updated_at: Date | null
    created_by: number | null
    updated_by: number | null
  }

  export type ProjectTypesMaxAggregateOutputType = {
    id: number
    type: string | null
    slug: string | null
    created_at: Date | null
    updated_at: Date | null
    created_by: number | null
    updated_by: number | null
  }

  export type ProjectTypesCountAggregateOutputType = {
    id: number
    type: number | null
    slug: number | null
    created_at: number | null
    updated_at: number | null
    created_by: number | null
    updated_by: number | null
    _all: number
  }


  export type ProjectTypesAvgAggregateInputType = {
    id?: true
    created_by?: true
    updated_by?: true
  }

  export type ProjectTypesSumAggregateInputType = {
    id?: true
    created_by?: true
    updated_by?: true
  }

  export type ProjectTypesMinAggregateInputType = {
    id?: true
    type?: true
    slug?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type ProjectTypesMaxAggregateInputType = {
    id?: true
    type?: true
    slug?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type ProjectTypesCountAggregateInputType = {
    id?: true
    type?: true
    slug?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
    _all?: true
  }

  export type ProjectTypesAggregateArgs = {
    /**
     * Filter which ProjectTypes to aggregate.
    **/
    where?: ProjectTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectTypes to fetch.
    **/
    orderBy?: Enumerable<ProjectTypesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: ProjectTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectTypes from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectTypes.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectTypes
    **/
    count?: true | ProjectTypesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: ProjectTypesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: ProjectTypesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: ProjectTypesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: ProjectTypesMaxAggregateInputType
  }

  export type GetProjectTypesAggregateType<T extends ProjectTypesAggregateArgs> = {
    [P in keyof T & keyof AggregateProjectTypes]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectTypes[P]>
      : GetScalarType<T[P], AggregateProjectTypes[P]>
  }



  export type ProjectTypesSelect = {
    id?: boolean
    type?: boolean
    slug?: boolean
    created_at?: boolean
    updated_at?: boolean
    created_by?: boolean
    updated_by?: boolean
    ProjectTypeAssociations?: boolean | ProjectTypeAssociationsFindManyArgs
  }

  export type ProjectTypesInclude = {
    ProjectTypeAssociations?: boolean | ProjectTypeAssociationsFindManyArgs
  }

  export type ProjectTypesGetPayload<
    S extends boolean | null | undefined | ProjectTypesArgs,
    U = keyof S
      > = S extends true
        ? ProjectTypes
    : S extends undefined
    ? never
    : S extends ProjectTypesArgs | ProjectTypesFindManyArgs
    ?'include' extends U
    ? ProjectTypes  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'ProjectTypeAssociations'
        ? Array < ProjectTypeAssociationsGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof ProjectTypes ?ProjectTypes [P]
  : 
          P extends 'ProjectTypeAssociations'
        ? Array < ProjectTypeAssociationsGetPayload<S['select'][P]>>  : never
  } 
    : ProjectTypes
  : ProjectTypes


  type ProjectTypesCountArgs = Merge<
    Omit<ProjectTypesFindManyArgs, 'select' | 'include'> & {
      select?: ProjectTypesCountAggregateInputType | true
    }
  >

  export interface ProjectTypesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one ProjectTypes that matches the filter.
     * @param {ProjectTypesFindUniqueArgs} args - Arguments to find a ProjectTypes
     * @example
     * // Get one ProjectTypes
     * const projectTypes = await prisma.projectTypes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProjectTypesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProjectTypesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ProjectTypes'> extends True ? CheckSelect<T, Prisma__ProjectTypesClient<ProjectTypes>, Prisma__ProjectTypesClient<ProjectTypesGetPayload<T>>> : CheckSelect<T, Prisma__ProjectTypesClient<ProjectTypes | null >, Prisma__ProjectTypesClient<ProjectTypesGetPayload<T> | null >>

    /**
     * Find the first ProjectTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTypesFindFirstArgs} args - Arguments to find a ProjectTypes
     * @example
     * // Get one ProjectTypes
     * const projectTypes = await prisma.projectTypes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProjectTypesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProjectTypesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ProjectTypes'> extends True ? CheckSelect<T, Prisma__ProjectTypesClient<ProjectTypes>, Prisma__ProjectTypesClient<ProjectTypesGetPayload<T>>> : CheckSelect<T, Prisma__ProjectTypesClient<ProjectTypes | null >, Prisma__ProjectTypesClient<ProjectTypesGetPayload<T> | null >>

    /**
     * Find zero or more ProjectTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTypesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectTypes
     * const projectTypes = await prisma.projectTypes.findMany()
     * 
     * // Get first 10 ProjectTypes
     * const projectTypes = await prisma.projectTypes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectTypesWithIdOnly = await prisma.projectTypes.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProjectTypesFindManyArgs>(
      args?: SelectSubset<T, ProjectTypesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ProjectTypes>>, PrismaPromise<Array<ProjectTypesGetPayload<T>>>>

    /**
     * Create a ProjectTypes.
     * @param {ProjectTypesCreateArgs} args - Arguments to create a ProjectTypes.
     * @example
     * // Create one ProjectTypes
     * const ProjectTypes = await prisma.projectTypes.create({
     *   data: {
     *     // ... data to create a ProjectTypes
     *   }
     * })
     * 
    **/
    create<T extends ProjectTypesCreateArgs>(
      args: SelectSubset<T, ProjectTypesCreateArgs>
    ): CheckSelect<T, Prisma__ProjectTypesClient<ProjectTypes>, Prisma__ProjectTypesClient<ProjectTypesGetPayload<T>>>

    /**
     * Delete a ProjectTypes.
     * @param {ProjectTypesDeleteArgs} args - Arguments to delete one ProjectTypes.
     * @example
     * // Delete one ProjectTypes
     * const ProjectTypes = await prisma.projectTypes.delete({
     *   where: {
     *     // ... filter to delete one ProjectTypes
     *   }
     * })
     * 
    **/
    delete<T extends ProjectTypesDeleteArgs>(
      args: SelectSubset<T, ProjectTypesDeleteArgs>
    ): CheckSelect<T, Prisma__ProjectTypesClient<ProjectTypes>, Prisma__ProjectTypesClient<ProjectTypesGetPayload<T>>>

    /**
     * Update one ProjectTypes.
     * @param {ProjectTypesUpdateArgs} args - Arguments to update one ProjectTypes.
     * @example
     * // Update one ProjectTypes
     * const projectTypes = await prisma.projectTypes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProjectTypesUpdateArgs>(
      args: SelectSubset<T, ProjectTypesUpdateArgs>
    ): CheckSelect<T, Prisma__ProjectTypesClient<ProjectTypes>, Prisma__ProjectTypesClient<ProjectTypesGetPayload<T>>>

    /**
     * Delete zero or more ProjectTypes.
     * @param {ProjectTypesDeleteManyArgs} args - Arguments to filter ProjectTypes to delete.
     * @example
     * // Delete a few ProjectTypes
     * const { count } = await prisma.projectTypes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProjectTypesDeleteManyArgs>(
      args?: SelectSubset<T, ProjectTypesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTypesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectTypes
     * const projectTypes = await prisma.projectTypes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProjectTypesUpdateManyArgs>(
      args: SelectSubset<T, ProjectTypesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ProjectTypes.
     * @param {ProjectTypesUpsertArgs} args - Arguments to update or create a ProjectTypes.
     * @example
     * // Update or create a ProjectTypes
     * const projectTypes = await prisma.projectTypes.upsert({
     *   create: {
     *     // ... data to create a ProjectTypes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectTypes we want to update
     *   }
     * })
    **/
    upsert<T extends ProjectTypesUpsertArgs>(
      args: SelectSubset<T, ProjectTypesUpsertArgs>
    ): CheckSelect<T, Prisma__ProjectTypesClient<ProjectTypes>, Prisma__ProjectTypesClient<ProjectTypesGetPayload<T>>>

    /**
     * Count the number of ProjectTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTypesCountArgs} args - Arguments to filter ProjectTypes to count.
     * @example
     * // Count the number of ProjectTypes
     * const count = await prisma.projectTypes.count({
     *   where: {
     *     // ... the filter for the ProjectTypes we want to count
     *   }
     * })
    **/
    count<T extends ProjectTypesCountArgs>(
      args?: Subset<T, ProjectTypesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectTypesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTypesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectTypesAggregateArgs>(args: Subset<T, ProjectTypesAggregateArgs>): PrismaPromise<GetProjectTypesAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectTypes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProjectTypesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    ProjectTypeAssociations<T extends ProjectTypeAssociationsFindManyArgs = {}>(args?: Subset<T, ProjectTypeAssociationsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ProjectTypeAssociations>>, PrismaPromise<Array<ProjectTypeAssociationsGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * ProjectTypes findUnique
   */
  export type ProjectTypesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the ProjectTypes
    **/
    select?: ProjectTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProjectTypesInclude | null
    /**
     * Throw an Error if a ProjectTypes can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ProjectTypes to fetch.
    **/
    where: ProjectTypesWhereUniqueInput
  }


  /**
   * ProjectTypes findFirst
   */
  export type ProjectTypesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the ProjectTypes
    **/
    select?: ProjectTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProjectTypesInclude | null
    /**
     * Throw an Error if a ProjectTypes can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ProjectTypes to fetch.
    **/
    where?: ProjectTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectTypes to fetch.
    **/
    orderBy?: Enumerable<ProjectTypesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectTypes.
    **/
    cursor?: ProjectTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectTypes from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectTypes.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectTypes.
    **/
    distinct?: Enumerable<ProjectTypesScalarFieldEnum>
  }


  /**
   * ProjectTypes findMany
   */
  export type ProjectTypesFindManyArgs = {
    /**
     * Select specific fields to fetch from the ProjectTypes
    **/
    select?: ProjectTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProjectTypesInclude | null
    /**
     * Filter, which ProjectTypes to fetch.
    **/
    where?: ProjectTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectTypes to fetch.
    **/
    orderBy?: Enumerable<ProjectTypesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectTypes.
    **/
    cursor?: ProjectTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectTypes from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectTypes.
    **/
    skip?: number
    distinct?: Enumerable<ProjectTypesScalarFieldEnum>
  }


  /**
   * ProjectTypes create
   */
  export type ProjectTypesCreateArgs = {
    /**
     * Select specific fields to fetch from the ProjectTypes
    **/
    select?: ProjectTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProjectTypesInclude | null
    /**
     * The data needed to create a ProjectTypes.
    **/
    data: XOR<ProjectTypesCreateInput, ProjectTypesUncheckedCreateInput>
  }


  /**
   * ProjectTypes update
   */
  export type ProjectTypesUpdateArgs = {
    /**
     * Select specific fields to fetch from the ProjectTypes
    **/
    select?: ProjectTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProjectTypesInclude | null
    /**
     * The data needed to update a ProjectTypes.
    **/
    data: XOR<ProjectTypesUpdateInput, ProjectTypesUncheckedUpdateInput>
    /**
     * Choose, which ProjectTypes to update.
    **/
    where: ProjectTypesWhereUniqueInput
  }


  /**
   * ProjectTypes updateMany
   */
  export type ProjectTypesUpdateManyArgs = {
    data: XOR<ProjectTypesUpdateManyMutationInput, ProjectTypesUncheckedUpdateManyInput>
    where?: ProjectTypesWhereInput
  }


  /**
   * ProjectTypes upsert
   */
  export type ProjectTypesUpsertArgs = {
    /**
     * Select specific fields to fetch from the ProjectTypes
    **/
    select?: ProjectTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProjectTypesInclude | null
    /**
     * The filter to search for the ProjectTypes to update in case it exists.
    **/
    where: ProjectTypesWhereUniqueInput
    /**
     * In case the ProjectTypes found by the `where` argument doesn't exist, create a new ProjectTypes with this data.
    **/
    create: XOR<ProjectTypesCreateInput, ProjectTypesUncheckedCreateInput>
    /**
     * In case the ProjectTypes was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<ProjectTypesUpdateInput, ProjectTypesUncheckedUpdateInput>
  }


  /**
   * ProjectTypes delete
   */
  export type ProjectTypesDeleteArgs = {
    /**
     * Select specific fields to fetch from the ProjectTypes
    **/
    select?: ProjectTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProjectTypesInclude | null
    /**
     * Filter which ProjectTypes to delete.
    **/
    where: ProjectTypesWhereUniqueInput
  }


  /**
   * ProjectTypes deleteMany
   */
  export type ProjectTypesDeleteManyArgs = {
    where?: ProjectTypesWhereInput
  }


  /**
   * ProjectTypes without action
   */
  export type ProjectTypesArgs = {
    /**
     * Select specific fields to fetch from the ProjectTypes
    **/
    select?: ProjectTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProjectTypesInclude | null
  }



  /**
   * Model PropertyLevels
   */


  export type AggregatePropertyLevels = {
    count: PropertyLevelsCountAggregateOutputType | null
    avg: PropertyLevelsAvgAggregateOutputType | null
    sum: PropertyLevelsSumAggregateOutputType | null
    min: PropertyLevelsMinAggregateOutputType | null
    max: PropertyLevelsMaxAggregateOutputType | null
  }

  export type PropertyLevelsAvgAggregateOutputType = {
    id: number
    created_by: number | null
    updated_by: number | null
  }

  export type PropertyLevelsSumAggregateOutputType = {
    id: number
    created_by: number | null
    updated_by: number | null
  }

  export type PropertyLevelsMinAggregateOutputType = {
    id: number
    name: string | null
    slug: string | null
    created_at: Date | null
    updated_at: Date | null
    created_by: number | null
    updated_by: number | null
  }

  export type PropertyLevelsMaxAggregateOutputType = {
    id: number
    name: string | null
    slug: string | null
    created_at: Date | null
    updated_at: Date | null
    created_by: number | null
    updated_by: number | null
  }

  export type PropertyLevelsCountAggregateOutputType = {
    id: number
    name: number | null
    slug: number | null
    created_at: number | null
    updated_at: number | null
    created_by: number | null
    updated_by: number | null
    _all: number
  }


  export type PropertyLevelsAvgAggregateInputType = {
    id?: true
    created_by?: true
    updated_by?: true
  }

  export type PropertyLevelsSumAggregateInputType = {
    id?: true
    created_by?: true
    updated_by?: true
  }

  export type PropertyLevelsMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type PropertyLevelsMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type PropertyLevelsCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
    _all?: true
  }

  export type PropertyLevelsAggregateArgs = {
    /**
     * Filter which PropertyLevels to aggregate.
    **/
    where?: PropertyLevelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyLevels to fetch.
    **/
    orderBy?: Enumerable<PropertyLevelsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: PropertyLevelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyLevels from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyLevels.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PropertyLevels
    **/
    count?: true | PropertyLevelsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: PropertyLevelsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: PropertyLevelsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: PropertyLevelsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: PropertyLevelsMaxAggregateInputType
  }

  export type GetPropertyLevelsAggregateType<T extends PropertyLevelsAggregateArgs> = {
    [P in keyof T & keyof AggregatePropertyLevels]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePropertyLevels[P]>
      : GetScalarType<T[P], AggregatePropertyLevels[P]>
  }



  export type PropertyLevelsSelect = {
    id?: boolean
    name?: boolean
    slug?: boolean
    created_at?: boolean
    updated_at?: boolean
    created_by?: boolean
    updated_by?: boolean
    UnitLocations?: boolean | UnitLocationsFindManyArgs
  }

  export type PropertyLevelsInclude = {
    UnitLocations?: boolean | UnitLocationsFindManyArgs
  }

  export type PropertyLevelsGetPayload<
    S extends boolean | null | undefined | PropertyLevelsArgs,
    U = keyof S
      > = S extends true
        ? PropertyLevels
    : S extends undefined
    ? never
    : S extends PropertyLevelsArgs | PropertyLevelsFindManyArgs
    ?'include' extends U
    ? PropertyLevels  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'UnitLocations'
        ? Array < UnitLocationsGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof PropertyLevels ?PropertyLevels [P]
  : 
          P extends 'UnitLocations'
        ? Array < UnitLocationsGetPayload<S['select'][P]>>  : never
  } 
    : PropertyLevels
  : PropertyLevels


  type PropertyLevelsCountArgs = Merge<
    Omit<PropertyLevelsFindManyArgs, 'select' | 'include'> & {
      select?: PropertyLevelsCountAggregateInputType | true
    }
  >

  export interface PropertyLevelsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one PropertyLevels that matches the filter.
     * @param {PropertyLevelsFindUniqueArgs} args - Arguments to find a PropertyLevels
     * @example
     * // Get one PropertyLevels
     * const propertyLevels = await prisma.propertyLevels.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PropertyLevelsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PropertyLevelsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PropertyLevels'> extends True ? CheckSelect<T, Prisma__PropertyLevelsClient<PropertyLevels>, Prisma__PropertyLevelsClient<PropertyLevelsGetPayload<T>>> : CheckSelect<T, Prisma__PropertyLevelsClient<PropertyLevels | null >, Prisma__PropertyLevelsClient<PropertyLevelsGetPayload<T> | null >>

    /**
     * Find the first PropertyLevels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyLevelsFindFirstArgs} args - Arguments to find a PropertyLevels
     * @example
     * // Get one PropertyLevels
     * const propertyLevels = await prisma.propertyLevels.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PropertyLevelsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PropertyLevelsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PropertyLevels'> extends True ? CheckSelect<T, Prisma__PropertyLevelsClient<PropertyLevels>, Prisma__PropertyLevelsClient<PropertyLevelsGetPayload<T>>> : CheckSelect<T, Prisma__PropertyLevelsClient<PropertyLevels | null >, Prisma__PropertyLevelsClient<PropertyLevelsGetPayload<T> | null >>

    /**
     * Find zero or more PropertyLevels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyLevelsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PropertyLevels
     * const propertyLevels = await prisma.propertyLevels.findMany()
     * 
     * // Get first 10 PropertyLevels
     * const propertyLevels = await prisma.propertyLevels.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertyLevelsWithIdOnly = await prisma.propertyLevels.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PropertyLevelsFindManyArgs>(
      args?: SelectSubset<T, PropertyLevelsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<PropertyLevels>>, PrismaPromise<Array<PropertyLevelsGetPayload<T>>>>

    /**
     * Create a PropertyLevels.
     * @param {PropertyLevelsCreateArgs} args - Arguments to create a PropertyLevels.
     * @example
     * // Create one PropertyLevels
     * const PropertyLevels = await prisma.propertyLevels.create({
     *   data: {
     *     // ... data to create a PropertyLevels
     *   }
     * })
     * 
    **/
    create<T extends PropertyLevelsCreateArgs>(
      args: SelectSubset<T, PropertyLevelsCreateArgs>
    ): CheckSelect<T, Prisma__PropertyLevelsClient<PropertyLevels>, Prisma__PropertyLevelsClient<PropertyLevelsGetPayload<T>>>

    /**
     * Delete a PropertyLevels.
     * @param {PropertyLevelsDeleteArgs} args - Arguments to delete one PropertyLevels.
     * @example
     * // Delete one PropertyLevels
     * const PropertyLevels = await prisma.propertyLevels.delete({
     *   where: {
     *     // ... filter to delete one PropertyLevels
     *   }
     * })
     * 
    **/
    delete<T extends PropertyLevelsDeleteArgs>(
      args: SelectSubset<T, PropertyLevelsDeleteArgs>
    ): CheckSelect<T, Prisma__PropertyLevelsClient<PropertyLevels>, Prisma__PropertyLevelsClient<PropertyLevelsGetPayload<T>>>

    /**
     * Update one PropertyLevels.
     * @param {PropertyLevelsUpdateArgs} args - Arguments to update one PropertyLevels.
     * @example
     * // Update one PropertyLevels
     * const propertyLevels = await prisma.propertyLevels.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PropertyLevelsUpdateArgs>(
      args: SelectSubset<T, PropertyLevelsUpdateArgs>
    ): CheckSelect<T, Prisma__PropertyLevelsClient<PropertyLevels>, Prisma__PropertyLevelsClient<PropertyLevelsGetPayload<T>>>

    /**
     * Delete zero or more PropertyLevels.
     * @param {PropertyLevelsDeleteManyArgs} args - Arguments to filter PropertyLevels to delete.
     * @example
     * // Delete a few PropertyLevels
     * const { count } = await prisma.propertyLevels.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PropertyLevelsDeleteManyArgs>(
      args?: SelectSubset<T, PropertyLevelsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyLevels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyLevelsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PropertyLevels
     * const propertyLevels = await prisma.propertyLevels.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PropertyLevelsUpdateManyArgs>(
      args: SelectSubset<T, PropertyLevelsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one PropertyLevels.
     * @param {PropertyLevelsUpsertArgs} args - Arguments to update or create a PropertyLevels.
     * @example
     * // Update or create a PropertyLevels
     * const propertyLevels = await prisma.propertyLevels.upsert({
     *   create: {
     *     // ... data to create a PropertyLevels
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PropertyLevels we want to update
     *   }
     * })
    **/
    upsert<T extends PropertyLevelsUpsertArgs>(
      args: SelectSubset<T, PropertyLevelsUpsertArgs>
    ): CheckSelect<T, Prisma__PropertyLevelsClient<PropertyLevels>, Prisma__PropertyLevelsClient<PropertyLevelsGetPayload<T>>>

    /**
     * Count the number of PropertyLevels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyLevelsCountArgs} args - Arguments to filter PropertyLevels to count.
     * @example
     * // Count the number of PropertyLevels
     * const count = await prisma.propertyLevels.count({
     *   where: {
     *     // ... the filter for the PropertyLevels we want to count
     *   }
     * })
    **/
    count<T extends PropertyLevelsCountArgs>(
      args?: Subset<T, PropertyLevelsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertyLevelsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PropertyLevels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyLevelsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertyLevelsAggregateArgs>(args: Subset<T, PropertyLevelsAggregateArgs>): PrismaPromise<GetPropertyLevelsAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for PropertyLevels.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PropertyLevelsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    UnitLocations<T extends UnitLocationsFindManyArgs = {}>(args?: Subset<T, UnitLocationsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<UnitLocations>>, PrismaPromise<Array<UnitLocationsGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * PropertyLevels findUnique
   */
  export type PropertyLevelsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the PropertyLevels
    **/
    select?: PropertyLevelsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PropertyLevelsInclude | null
    /**
     * Throw an Error if a PropertyLevels can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which PropertyLevels to fetch.
    **/
    where: PropertyLevelsWhereUniqueInput
  }


  /**
   * PropertyLevels findFirst
   */
  export type PropertyLevelsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the PropertyLevels
    **/
    select?: PropertyLevelsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PropertyLevelsInclude | null
    /**
     * Throw an Error if a PropertyLevels can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which PropertyLevels to fetch.
    **/
    where?: PropertyLevelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyLevels to fetch.
    **/
    orderBy?: Enumerable<PropertyLevelsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyLevels.
    **/
    cursor?: PropertyLevelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyLevels from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyLevels.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyLevels.
    **/
    distinct?: Enumerable<PropertyLevelsScalarFieldEnum>
  }


  /**
   * PropertyLevels findMany
   */
  export type PropertyLevelsFindManyArgs = {
    /**
     * Select specific fields to fetch from the PropertyLevels
    **/
    select?: PropertyLevelsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PropertyLevelsInclude | null
    /**
     * Filter, which PropertyLevels to fetch.
    **/
    where?: PropertyLevelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyLevels to fetch.
    **/
    orderBy?: Enumerable<PropertyLevelsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PropertyLevels.
    **/
    cursor?: PropertyLevelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyLevels from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyLevels.
    **/
    skip?: number
    distinct?: Enumerable<PropertyLevelsScalarFieldEnum>
  }


  /**
   * PropertyLevels create
   */
  export type PropertyLevelsCreateArgs = {
    /**
     * Select specific fields to fetch from the PropertyLevels
    **/
    select?: PropertyLevelsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PropertyLevelsInclude | null
    /**
     * The data needed to create a PropertyLevels.
    **/
    data: XOR<PropertyLevelsCreateInput, PropertyLevelsUncheckedCreateInput>
  }


  /**
   * PropertyLevels update
   */
  export type PropertyLevelsUpdateArgs = {
    /**
     * Select specific fields to fetch from the PropertyLevels
    **/
    select?: PropertyLevelsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PropertyLevelsInclude | null
    /**
     * The data needed to update a PropertyLevels.
    **/
    data: XOR<PropertyLevelsUpdateInput, PropertyLevelsUncheckedUpdateInput>
    /**
     * Choose, which PropertyLevels to update.
    **/
    where: PropertyLevelsWhereUniqueInput
  }


  /**
   * PropertyLevels updateMany
   */
  export type PropertyLevelsUpdateManyArgs = {
    data: XOR<PropertyLevelsUpdateManyMutationInput, PropertyLevelsUncheckedUpdateManyInput>
    where?: PropertyLevelsWhereInput
  }


  /**
   * PropertyLevels upsert
   */
  export type PropertyLevelsUpsertArgs = {
    /**
     * Select specific fields to fetch from the PropertyLevels
    **/
    select?: PropertyLevelsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PropertyLevelsInclude | null
    /**
     * The filter to search for the PropertyLevels to update in case it exists.
    **/
    where: PropertyLevelsWhereUniqueInput
    /**
     * In case the PropertyLevels found by the `where` argument doesn't exist, create a new PropertyLevels with this data.
    **/
    create: XOR<PropertyLevelsCreateInput, PropertyLevelsUncheckedCreateInput>
    /**
     * In case the PropertyLevels was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<PropertyLevelsUpdateInput, PropertyLevelsUncheckedUpdateInput>
  }


  /**
   * PropertyLevels delete
   */
  export type PropertyLevelsDeleteArgs = {
    /**
     * Select specific fields to fetch from the PropertyLevels
    **/
    select?: PropertyLevelsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PropertyLevelsInclude | null
    /**
     * Filter which PropertyLevels to delete.
    **/
    where: PropertyLevelsWhereUniqueInput
  }


  /**
   * PropertyLevels deleteMany
   */
  export type PropertyLevelsDeleteManyArgs = {
    where?: PropertyLevelsWhereInput
  }


  /**
   * PropertyLevels without action
   */
  export type PropertyLevelsArgs = {
    /**
     * Select specific fields to fetch from the PropertyLevels
    **/
    select?: PropertyLevelsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PropertyLevelsInclude | null
  }



  /**
   * Model PropertyOwners
   */


  export type AggregatePropertyOwners = {
    count: PropertyOwnersCountAggregateOutputType | null
    avg: PropertyOwnersAvgAggregateOutputType | null
    sum: PropertyOwnersSumAggregateOutputType | null
    min: PropertyOwnersMinAggregateOutputType | null
    max: PropertyOwnersMaxAggregateOutputType | null
  }

  export type PropertyOwnersAvgAggregateOutputType = {
    id: number
    user_id: number
    created_by: number | null
    updated_by: number | null
  }

  export type PropertyOwnersSumAggregateOutputType = {
    id: number
    user_id: number
    created_by: number | null
    updated_by: number | null
  }

  export type PropertyOwnersMinAggregateOutputType = {
    id: number
    user_id: number
    first_name: string | null
    last_name: string | null
    mobile: string | null
    created_at: Date | null
    updated_at: Date | null
    created_by: number | null
    updated_by: number | null
  }

  export type PropertyOwnersMaxAggregateOutputType = {
    id: number
    user_id: number
    first_name: string | null
    last_name: string | null
    mobile: string | null
    created_at: Date | null
    updated_at: Date | null
    created_by: number | null
    updated_by: number | null
  }

  export type PropertyOwnersCountAggregateOutputType = {
    id: number
    user_id: number
    first_name: number | null
    last_name: number | null
    mobile: number | null
    created_at: number | null
    updated_at: number | null
    created_by: number | null
    updated_by: number | null
    _all: number
  }


  export type PropertyOwnersAvgAggregateInputType = {
    id?: true
    user_id?: true
    created_by?: true
    updated_by?: true
  }

  export type PropertyOwnersSumAggregateInputType = {
    id?: true
    user_id?: true
    created_by?: true
    updated_by?: true
  }

  export type PropertyOwnersMinAggregateInputType = {
    id?: true
    user_id?: true
    first_name?: true
    last_name?: true
    mobile?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type PropertyOwnersMaxAggregateInputType = {
    id?: true
    user_id?: true
    first_name?: true
    last_name?: true
    mobile?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type PropertyOwnersCountAggregateInputType = {
    id?: true
    user_id?: true
    first_name?: true
    last_name?: true
    mobile?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
    _all?: true
  }

  export type PropertyOwnersAggregateArgs = {
    /**
     * Filter which PropertyOwners to aggregate.
    **/
    where?: PropertyOwnersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyOwners to fetch.
    **/
    orderBy?: Enumerable<PropertyOwnersOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: PropertyOwnersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyOwners from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyOwners.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PropertyOwners
    **/
    count?: true | PropertyOwnersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: PropertyOwnersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: PropertyOwnersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: PropertyOwnersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: PropertyOwnersMaxAggregateInputType
  }

  export type GetPropertyOwnersAggregateType<T extends PropertyOwnersAggregateArgs> = {
    [P in keyof T & keyof AggregatePropertyOwners]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePropertyOwners[P]>
      : GetScalarType<T[P], AggregatePropertyOwners[P]>
  }



  export type PropertyOwnersSelect = {
    id?: boolean
    user_id?: boolean
    first_name?: boolean
    last_name?: boolean
    mobile?: boolean
    created_at?: boolean
    updated_at?: boolean
    created_by?: boolean
    updated_by?: boolean
    Users?: boolean | UsersArgs
    Property_Addresses?: boolean | Property_AddressesFindManyArgs
  }

  export type PropertyOwnersInclude = {
    Users?: boolean | UsersArgs
    Property_Addresses?: boolean | Property_AddressesFindManyArgs
  }

  export type PropertyOwnersGetPayload<
    S extends boolean | null | undefined | PropertyOwnersArgs,
    U = keyof S
      > = S extends true
        ? PropertyOwners
    : S extends undefined
    ? never
    : S extends PropertyOwnersArgs | PropertyOwnersFindManyArgs
    ?'include' extends U
    ? PropertyOwners  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'Users'
        ? UsersGetPayload<S['include'][P]> :
        P extends 'Property_Addresses'
        ? Array < Property_AddressesGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof PropertyOwners ?PropertyOwners [P]
  : 
          P extends 'Users'
        ? UsersGetPayload<S['select'][P]> :
        P extends 'Property_Addresses'
        ? Array < Property_AddressesGetPayload<S['select'][P]>>  : never
  } 
    : PropertyOwners
  : PropertyOwners


  type PropertyOwnersCountArgs = Merge<
    Omit<PropertyOwnersFindManyArgs, 'select' | 'include'> & {
      select?: PropertyOwnersCountAggregateInputType | true
    }
  >

  export interface PropertyOwnersDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one PropertyOwners that matches the filter.
     * @param {PropertyOwnersFindUniqueArgs} args - Arguments to find a PropertyOwners
     * @example
     * // Get one PropertyOwners
     * const propertyOwners = await prisma.propertyOwners.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PropertyOwnersFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PropertyOwnersFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PropertyOwners'> extends True ? CheckSelect<T, Prisma__PropertyOwnersClient<PropertyOwners>, Prisma__PropertyOwnersClient<PropertyOwnersGetPayload<T>>> : CheckSelect<T, Prisma__PropertyOwnersClient<PropertyOwners | null >, Prisma__PropertyOwnersClient<PropertyOwnersGetPayload<T> | null >>

    /**
     * Find the first PropertyOwners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyOwnersFindFirstArgs} args - Arguments to find a PropertyOwners
     * @example
     * // Get one PropertyOwners
     * const propertyOwners = await prisma.propertyOwners.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PropertyOwnersFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PropertyOwnersFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PropertyOwners'> extends True ? CheckSelect<T, Prisma__PropertyOwnersClient<PropertyOwners>, Prisma__PropertyOwnersClient<PropertyOwnersGetPayload<T>>> : CheckSelect<T, Prisma__PropertyOwnersClient<PropertyOwners | null >, Prisma__PropertyOwnersClient<PropertyOwnersGetPayload<T> | null >>

    /**
     * Find zero or more PropertyOwners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyOwnersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PropertyOwners
     * const propertyOwners = await prisma.propertyOwners.findMany()
     * 
     * // Get first 10 PropertyOwners
     * const propertyOwners = await prisma.propertyOwners.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertyOwnersWithIdOnly = await prisma.propertyOwners.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PropertyOwnersFindManyArgs>(
      args?: SelectSubset<T, PropertyOwnersFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<PropertyOwners>>, PrismaPromise<Array<PropertyOwnersGetPayload<T>>>>

    /**
     * Create a PropertyOwners.
     * @param {PropertyOwnersCreateArgs} args - Arguments to create a PropertyOwners.
     * @example
     * // Create one PropertyOwners
     * const PropertyOwners = await prisma.propertyOwners.create({
     *   data: {
     *     // ... data to create a PropertyOwners
     *   }
     * })
     * 
    **/
    create<T extends PropertyOwnersCreateArgs>(
      args: SelectSubset<T, PropertyOwnersCreateArgs>
    ): CheckSelect<T, Prisma__PropertyOwnersClient<PropertyOwners>, Prisma__PropertyOwnersClient<PropertyOwnersGetPayload<T>>>

    /**
     * Delete a PropertyOwners.
     * @param {PropertyOwnersDeleteArgs} args - Arguments to delete one PropertyOwners.
     * @example
     * // Delete one PropertyOwners
     * const PropertyOwners = await prisma.propertyOwners.delete({
     *   where: {
     *     // ... filter to delete one PropertyOwners
     *   }
     * })
     * 
    **/
    delete<T extends PropertyOwnersDeleteArgs>(
      args: SelectSubset<T, PropertyOwnersDeleteArgs>
    ): CheckSelect<T, Prisma__PropertyOwnersClient<PropertyOwners>, Prisma__PropertyOwnersClient<PropertyOwnersGetPayload<T>>>

    /**
     * Update one PropertyOwners.
     * @param {PropertyOwnersUpdateArgs} args - Arguments to update one PropertyOwners.
     * @example
     * // Update one PropertyOwners
     * const propertyOwners = await prisma.propertyOwners.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PropertyOwnersUpdateArgs>(
      args: SelectSubset<T, PropertyOwnersUpdateArgs>
    ): CheckSelect<T, Prisma__PropertyOwnersClient<PropertyOwners>, Prisma__PropertyOwnersClient<PropertyOwnersGetPayload<T>>>

    /**
     * Delete zero or more PropertyOwners.
     * @param {PropertyOwnersDeleteManyArgs} args - Arguments to filter PropertyOwners to delete.
     * @example
     * // Delete a few PropertyOwners
     * const { count } = await prisma.propertyOwners.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PropertyOwnersDeleteManyArgs>(
      args?: SelectSubset<T, PropertyOwnersDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyOwners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyOwnersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PropertyOwners
     * const propertyOwners = await prisma.propertyOwners.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PropertyOwnersUpdateManyArgs>(
      args: SelectSubset<T, PropertyOwnersUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one PropertyOwners.
     * @param {PropertyOwnersUpsertArgs} args - Arguments to update or create a PropertyOwners.
     * @example
     * // Update or create a PropertyOwners
     * const propertyOwners = await prisma.propertyOwners.upsert({
     *   create: {
     *     // ... data to create a PropertyOwners
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PropertyOwners we want to update
     *   }
     * })
    **/
    upsert<T extends PropertyOwnersUpsertArgs>(
      args: SelectSubset<T, PropertyOwnersUpsertArgs>
    ): CheckSelect<T, Prisma__PropertyOwnersClient<PropertyOwners>, Prisma__PropertyOwnersClient<PropertyOwnersGetPayload<T>>>

    /**
     * Count the number of PropertyOwners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyOwnersCountArgs} args - Arguments to filter PropertyOwners to count.
     * @example
     * // Count the number of PropertyOwners
     * const count = await prisma.propertyOwners.count({
     *   where: {
     *     // ... the filter for the PropertyOwners we want to count
     *   }
     * })
    **/
    count<T extends PropertyOwnersCountArgs>(
      args?: Subset<T, PropertyOwnersCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertyOwnersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PropertyOwners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyOwnersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertyOwnersAggregateArgs>(args: Subset<T, PropertyOwnersAggregateArgs>): PrismaPromise<GetPropertyOwnersAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for PropertyOwners.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PropertyOwnersClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Users<T extends UsersArgs = {}>(args?: Subset<T, UsersArgs>): CheckSelect<T, Prisma__UsersClient<Users | null >, Prisma__UsersClient<UsersGetPayload<T> | null >>;

    Property_Addresses<T extends Property_AddressesFindManyArgs = {}>(args?: Subset<T, Property_AddressesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Property_Addresses>>, PrismaPromise<Array<Property_AddressesGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * PropertyOwners findUnique
   */
  export type PropertyOwnersFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the PropertyOwners
    **/
    select?: PropertyOwnersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PropertyOwnersInclude | null
    /**
     * Throw an Error if a PropertyOwners can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which PropertyOwners to fetch.
    **/
    where: PropertyOwnersWhereUniqueInput
  }


  /**
   * PropertyOwners findFirst
   */
  export type PropertyOwnersFindFirstArgs = {
    /**
     * Select specific fields to fetch from the PropertyOwners
    **/
    select?: PropertyOwnersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PropertyOwnersInclude | null
    /**
     * Throw an Error if a PropertyOwners can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which PropertyOwners to fetch.
    **/
    where?: PropertyOwnersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyOwners to fetch.
    **/
    orderBy?: Enumerable<PropertyOwnersOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyOwners.
    **/
    cursor?: PropertyOwnersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyOwners from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyOwners.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyOwners.
    **/
    distinct?: Enumerable<PropertyOwnersScalarFieldEnum>
  }


  /**
   * PropertyOwners findMany
   */
  export type PropertyOwnersFindManyArgs = {
    /**
     * Select specific fields to fetch from the PropertyOwners
    **/
    select?: PropertyOwnersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PropertyOwnersInclude | null
    /**
     * Filter, which PropertyOwners to fetch.
    **/
    where?: PropertyOwnersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyOwners to fetch.
    **/
    orderBy?: Enumerable<PropertyOwnersOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PropertyOwners.
    **/
    cursor?: PropertyOwnersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyOwners from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyOwners.
    **/
    skip?: number
    distinct?: Enumerable<PropertyOwnersScalarFieldEnum>
  }


  /**
   * PropertyOwners create
   */
  export type PropertyOwnersCreateArgs = {
    /**
     * Select specific fields to fetch from the PropertyOwners
    **/
    select?: PropertyOwnersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PropertyOwnersInclude | null
    /**
     * The data needed to create a PropertyOwners.
    **/
    data: XOR<PropertyOwnersCreateInput, PropertyOwnersUncheckedCreateInput>
  }


  /**
   * PropertyOwners update
   */
  export type PropertyOwnersUpdateArgs = {
    /**
     * Select specific fields to fetch from the PropertyOwners
    **/
    select?: PropertyOwnersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PropertyOwnersInclude | null
    /**
     * The data needed to update a PropertyOwners.
    **/
    data: XOR<PropertyOwnersUpdateInput, PropertyOwnersUncheckedUpdateInput>
    /**
     * Choose, which PropertyOwners to update.
    **/
    where: PropertyOwnersWhereUniqueInput
  }


  /**
   * PropertyOwners updateMany
   */
  export type PropertyOwnersUpdateManyArgs = {
    data: XOR<PropertyOwnersUpdateManyMutationInput, PropertyOwnersUncheckedUpdateManyInput>
    where?: PropertyOwnersWhereInput
  }


  /**
   * PropertyOwners upsert
   */
  export type PropertyOwnersUpsertArgs = {
    /**
     * Select specific fields to fetch from the PropertyOwners
    **/
    select?: PropertyOwnersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PropertyOwnersInclude | null
    /**
     * The filter to search for the PropertyOwners to update in case it exists.
    **/
    where: PropertyOwnersWhereUniqueInput
    /**
     * In case the PropertyOwners found by the `where` argument doesn't exist, create a new PropertyOwners with this data.
    **/
    create: XOR<PropertyOwnersCreateInput, PropertyOwnersUncheckedCreateInput>
    /**
     * In case the PropertyOwners was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<PropertyOwnersUpdateInput, PropertyOwnersUncheckedUpdateInput>
  }


  /**
   * PropertyOwners delete
   */
  export type PropertyOwnersDeleteArgs = {
    /**
     * Select specific fields to fetch from the PropertyOwners
    **/
    select?: PropertyOwnersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PropertyOwnersInclude | null
    /**
     * Filter which PropertyOwners to delete.
    **/
    where: PropertyOwnersWhereUniqueInput
  }


  /**
   * PropertyOwners deleteMany
   */
  export type PropertyOwnersDeleteManyArgs = {
    where?: PropertyOwnersWhereInput
  }


  /**
   * PropertyOwners without action
   */
  export type PropertyOwnersArgs = {
    /**
     * Select specific fields to fetch from the PropertyOwners
    **/
    select?: PropertyOwnersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PropertyOwnersInclude | null
  }



  /**
   * Model PropertySubTypes
   */


  export type AggregatePropertySubTypes = {
    count: PropertySubTypesCountAggregateOutputType | null
    avg: PropertySubTypesAvgAggregateOutputType | null
    sum: PropertySubTypesSumAggregateOutputType | null
    min: PropertySubTypesMinAggregateOutputType | null
    max: PropertySubTypesMaxAggregateOutputType | null
  }

  export type PropertySubTypesAvgAggregateOutputType = {
    id: number
    property_type_id: number
    created_by: number | null
    updated_by: number | null
  }

  export type PropertySubTypesSumAggregateOutputType = {
    id: number
    property_type_id: number
    created_by: number | null
    updated_by: number | null
  }

  export type PropertySubTypesMinAggregateOutputType = {
    id: number
    property_type_id: number
    name: string | null
    slug: string | null
    created_at: Date | null
    updated_at: Date | null
    created_by: number | null
    updated_by: number | null
  }

  export type PropertySubTypesMaxAggregateOutputType = {
    id: number
    property_type_id: number
    name: string | null
    slug: string | null
    created_at: Date | null
    updated_at: Date | null
    created_by: number | null
    updated_by: number | null
  }

  export type PropertySubTypesCountAggregateOutputType = {
    id: number
    property_type_id: number
    name: number | null
    slug: number | null
    created_at: number | null
    updated_at: number | null
    created_by: number | null
    updated_by: number | null
    _all: number
  }


  export type PropertySubTypesAvgAggregateInputType = {
    id?: true
    property_type_id?: true
    created_by?: true
    updated_by?: true
  }

  export type PropertySubTypesSumAggregateInputType = {
    id?: true
    property_type_id?: true
    created_by?: true
    updated_by?: true
  }

  export type PropertySubTypesMinAggregateInputType = {
    id?: true
    property_type_id?: true
    name?: true
    slug?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type PropertySubTypesMaxAggregateInputType = {
    id?: true
    property_type_id?: true
    name?: true
    slug?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type PropertySubTypesCountAggregateInputType = {
    id?: true
    property_type_id?: true
    name?: true
    slug?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
    _all?: true
  }

  export type PropertySubTypesAggregateArgs = {
    /**
     * Filter which PropertySubTypes to aggregate.
    **/
    where?: PropertySubTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertySubTypes to fetch.
    **/
    orderBy?: Enumerable<PropertySubTypesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: PropertySubTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertySubTypes from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertySubTypes.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PropertySubTypes
    **/
    count?: true | PropertySubTypesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: PropertySubTypesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: PropertySubTypesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: PropertySubTypesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: PropertySubTypesMaxAggregateInputType
  }

  export type GetPropertySubTypesAggregateType<T extends PropertySubTypesAggregateArgs> = {
    [P in keyof T & keyof AggregatePropertySubTypes]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePropertySubTypes[P]>
      : GetScalarType<T[P], AggregatePropertySubTypes[P]>
  }



  export type PropertySubTypesSelect = {
    id?: boolean
    property_type_id?: boolean
    name?: boolean
    slug?: boolean
    created_at?: boolean
    updated_at?: boolean
    created_by?: boolean
    updated_by?: boolean
    Property_Types?: boolean | Property_TypesArgs
    Property_Addresses?: boolean | Property_AddressesFindManyArgs
    UnitLocations?: boolean | UnitLocationsFindManyArgs
  }

  export type PropertySubTypesInclude = {
    Property_Types?: boolean | Property_TypesArgs
    Property_Addresses?: boolean | Property_AddressesFindManyArgs
    UnitLocations?: boolean | UnitLocationsFindManyArgs
  }

  export type PropertySubTypesGetPayload<
    S extends boolean | null | undefined | PropertySubTypesArgs,
    U = keyof S
      > = S extends true
        ? PropertySubTypes
    : S extends undefined
    ? never
    : S extends PropertySubTypesArgs | PropertySubTypesFindManyArgs
    ?'include' extends U
    ? PropertySubTypes  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'Property_Types'
        ? Property_TypesGetPayload<S['include'][P]> :
        P extends 'Property_Addresses'
        ? Array < Property_AddressesGetPayload<S['include'][P]>>  :
        P extends 'UnitLocations'
        ? Array < UnitLocationsGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof PropertySubTypes ?PropertySubTypes [P]
  : 
          P extends 'Property_Types'
        ? Property_TypesGetPayload<S['select'][P]> :
        P extends 'Property_Addresses'
        ? Array < Property_AddressesGetPayload<S['select'][P]>>  :
        P extends 'UnitLocations'
        ? Array < UnitLocationsGetPayload<S['select'][P]>>  : never
  } 
    : PropertySubTypes
  : PropertySubTypes


  type PropertySubTypesCountArgs = Merge<
    Omit<PropertySubTypesFindManyArgs, 'select' | 'include'> & {
      select?: PropertySubTypesCountAggregateInputType | true
    }
  >

  export interface PropertySubTypesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one PropertySubTypes that matches the filter.
     * @param {PropertySubTypesFindUniqueArgs} args - Arguments to find a PropertySubTypes
     * @example
     * // Get one PropertySubTypes
     * const propertySubTypes = await prisma.propertySubTypes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PropertySubTypesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PropertySubTypesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PropertySubTypes'> extends True ? CheckSelect<T, Prisma__PropertySubTypesClient<PropertySubTypes>, Prisma__PropertySubTypesClient<PropertySubTypesGetPayload<T>>> : CheckSelect<T, Prisma__PropertySubTypesClient<PropertySubTypes | null >, Prisma__PropertySubTypesClient<PropertySubTypesGetPayload<T> | null >>

    /**
     * Find the first PropertySubTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertySubTypesFindFirstArgs} args - Arguments to find a PropertySubTypes
     * @example
     * // Get one PropertySubTypes
     * const propertySubTypes = await prisma.propertySubTypes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PropertySubTypesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PropertySubTypesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PropertySubTypes'> extends True ? CheckSelect<T, Prisma__PropertySubTypesClient<PropertySubTypes>, Prisma__PropertySubTypesClient<PropertySubTypesGetPayload<T>>> : CheckSelect<T, Prisma__PropertySubTypesClient<PropertySubTypes | null >, Prisma__PropertySubTypesClient<PropertySubTypesGetPayload<T> | null >>

    /**
     * Find zero or more PropertySubTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertySubTypesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PropertySubTypes
     * const propertySubTypes = await prisma.propertySubTypes.findMany()
     * 
     * // Get first 10 PropertySubTypes
     * const propertySubTypes = await prisma.propertySubTypes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertySubTypesWithIdOnly = await prisma.propertySubTypes.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PropertySubTypesFindManyArgs>(
      args?: SelectSubset<T, PropertySubTypesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<PropertySubTypes>>, PrismaPromise<Array<PropertySubTypesGetPayload<T>>>>

    /**
     * Create a PropertySubTypes.
     * @param {PropertySubTypesCreateArgs} args - Arguments to create a PropertySubTypes.
     * @example
     * // Create one PropertySubTypes
     * const PropertySubTypes = await prisma.propertySubTypes.create({
     *   data: {
     *     // ... data to create a PropertySubTypes
     *   }
     * })
     * 
    **/
    create<T extends PropertySubTypesCreateArgs>(
      args: SelectSubset<T, PropertySubTypesCreateArgs>
    ): CheckSelect<T, Prisma__PropertySubTypesClient<PropertySubTypes>, Prisma__PropertySubTypesClient<PropertySubTypesGetPayload<T>>>

    /**
     * Delete a PropertySubTypes.
     * @param {PropertySubTypesDeleteArgs} args - Arguments to delete one PropertySubTypes.
     * @example
     * // Delete one PropertySubTypes
     * const PropertySubTypes = await prisma.propertySubTypes.delete({
     *   where: {
     *     // ... filter to delete one PropertySubTypes
     *   }
     * })
     * 
    **/
    delete<T extends PropertySubTypesDeleteArgs>(
      args: SelectSubset<T, PropertySubTypesDeleteArgs>
    ): CheckSelect<T, Prisma__PropertySubTypesClient<PropertySubTypes>, Prisma__PropertySubTypesClient<PropertySubTypesGetPayload<T>>>

    /**
     * Update one PropertySubTypes.
     * @param {PropertySubTypesUpdateArgs} args - Arguments to update one PropertySubTypes.
     * @example
     * // Update one PropertySubTypes
     * const propertySubTypes = await prisma.propertySubTypes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PropertySubTypesUpdateArgs>(
      args: SelectSubset<T, PropertySubTypesUpdateArgs>
    ): CheckSelect<T, Prisma__PropertySubTypesClient<PropertySubTypes>, Prisma__PropertySubTypesClient<PropertySubTypesGetPayload<T>>>

    /**
     * Delete zero or more PropertySubTypes.
     * @param {PropertySubTypesDeleteManyArgs} args - Arguments to filter PropertySubTypes to delete.
     * @example
     * // Delete a few PropertySubTypes
     * const { count } = await prisma.propertySubTypes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PropertySubTypesDeleteManyArgs>(
      args?: SelectSubset<T, PropertySubTypesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertySubTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertySubTypesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PropertySubTypes
     * const propertySubTypes = await prisma.propertySubTypes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PropertySubTypesUpdateManyArgs>(
      args: SelectSubset<T, PropertySubTypesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one PropertySubTypes.
     * @param {PropertySubTypesUpsertArgs} args - Arguments to update or create a PropertySubTypes.
     * @example
     * // Update or create a PropertySubTypes
     * const propertySubTypes = await prisma.propertySubTypes.upsert({
     *   create: {
     *     // ... data to create a PropertySubTypes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PropertySubTypes we want to update
     *   }
     * })
    **/
    upsert<T extends PropertySubTypesUpsertArgs>(
      args: SelectSubset<T, PropertySubTypesUpsertArgs>
    ): CheckSelect<T, Prisma__PropertySubTypesClient<PropertySubTypes>, Prisma__PropertySubTypesClient<PropertySubTypesGetPayload<T>>>

    /**
     * Count the number of PropertySubTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertySubTypesCountArgs} args - Arguments to filter PropertySubTypes to count.
     * @example
     * // Count the number of PropertySubTypes
     * const count = await prisma.propertySubTypes.count({
     *   where: {
     *     // ... the filter for the PropertySubTypes we want to count
     *   }
     * })
    **/
    count<T extends PropertySubTypesCountArgs>(
      args?: Subset<T, PropertySubTypesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertySubTypesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PropertySubTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertySubTypesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertySubTypesAggregateArgs>(args: Subset<T, PropertySubTypesAggregateArgs>): PrismaPromise<GetPropertySubTypesAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for PropertySubTypes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PropertySubTypesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Property_Types<T extends Property_TypesArgs = {}>(args?: Subset<T, Property_TypesArgs>): CheckSelect<T, Prisma__Property_TypesClient<Property_Types | null >, Prisma__Property_TypesClient<Property_TypesGetPayload<T> | null >>;

    Property_Addresses<T extends Property_AddressesFindManyArgs = {}>(args?: Subset<T, Property_AddressesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Property_Addresses>>, PrismaPromise<Array<Property_AddressesGetPayload<T>>>>;

    UnitLocations<T extends UnitLocationsFindManyArgs = {}>(args?: Subset<T, UnitLocationsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<UnitLocations>>, PrismaPromise<Array<UnitLocationsGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * PropertySubTypes findUnique
   */
  export type PropertySubTypesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the PropertySubTypes
    **/
    select?: PropertySubTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PropertySubTypesInclude | null
    /**
     * Throw an Error if a PropertySubTypes can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which PropertySubTypes to fetch.
    **/
    where: PropertySubTypesWhereUniqueInput
  }


  /**
   * PropertySubTypes findFirst
   */
  export type PropertySubTypesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the PropertySubTypes
    **/
    select?: PropertySubTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PropertySubTypesInclude | null
    /**
     * Throw an Error if a PropertySubTypes can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which PropertySubTypes to fetch.
    **/
    where?: PropertySubTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertySubTypes to fetch.
    **/
    orderBy?: Enumerable<PropertySubTypesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertySubTypes.
    **/
    cursor?: PropertySubTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertySubTypes from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertySubTypes.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertySubTypes.
    **/
    distinct?: Enumerable<PropertySubTypesScalarFieldEnum>
  }


  /**
   * PropertySubTypes findMany
   */
  export type PropertySubTypesFindManyArgs = {
    /**
     * Select specific fields to fetch from the PropertySubTypes
    **/
    select?: PropertySubTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PropertySubTypesInclude | null
    /**
     * Filter, which PropertySubTypes to fetch.
    **/
    where?: PropertySubTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertySubTypes to fetch.
    **/
    orderBy?: Enumerable<PropertySubTypesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PropertySubTypes.
    **/
    cursor?: PropertySubTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertySubTypes from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertySubTypes.
    **/
    skip?: number
    distinct?: Enumerable<PropertySubTypesScalarFieldEnum>
  }


  /**
   * PropertySubTypes create
   */
  export type PropertySubTypesCreateArgs = {
    /**
     * Select specific fields to fetch from the PropertySubTypes
    **/
    select?: PropertySubTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PropertySubTypesInclude | null
    /**
     * The data needed to create a PropertySubTypes.
    **/
    data: XOR<PropertySubTypesCreateInput, PropertySubTypesUncheckedCreateInput>
  }


  /**
   * PropertySubTypes update
   */
  export type PropertySubTypesUpdateArgs = {
    /**
     * Select specific fields to fetch from the PropertySubTypes
    **/
    select?: PropertySubTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PropertySubTypesInclude | null
    /**
     * The data needed to update a PropertySubTypes.
    **/
    data: XOR<PropertySubTypesUpdateInput, PropertySubTypesUncheckedUpdateInput>
    /**
     * Choose, which PropertySubTypes to update.
    **/
    where: PropertySubTypesWhereUniqueInput
  }


  /**
   * PropertySubTypes updateMany
   */
  export type PropertySubTypesUpdateManyArgs = {
    data: XOR<PropertySubTypesUpdateManyMutationInput, PropertySubTypesUncheckedUpdateManyInput>
    where?: PropertySubTypesWhereInput
  }


  /**
   * PropertySubTypes upsert
   */
  export type PropertySubTypesUpsertArgs = {
    /**
     * Select specific fields to fetch from the PropertySubTypes
    **/
    select?: PropertySubTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PropertySubTypesInclude | null
    /**
     * The filter to search for the PropertySubTypes to update in case it exists.
    **/
    where: PropertySubTypesWhereUniqueInput
    /**
     * In case the PropertySubTypes found by the `where` argument doesn't exist, create a new PropertySubTypes with this data.
    **/
    create: XOR<PropertySubTypesCreateInput, PropertySubTypesUncheckedCreateInput>
    /**
     * In case the PropertySubTypes was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<PropertySubTypesUpdateInput, PropertySubTypesUncheckedUpdateInput>
  }


  /**
   * PropertySubTypes delete
   */
  export type PropertySubTypesDeleteArgs = {
    /**
     * Select specific fields to fetch from the PropertySubTypes
    **/
    select?: PropertySubTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PropertySubTypesInclude | null
    /**
     * Filter which PropertySubTypes to delete.
    **/
    where: PropertySubTypesWhereUniqueInput
  }


  /**
   * PropertySubTypes deleteMany
   */
  export type PropertySubTypesDeleteManyArgs = {
    where?: PropertySubTypesWhereInput
  }


  /**
   * PropertySubTypes without action
   */
  export type PropertySubTypesArgs = {
    /**
     * Select specific fields to fetch from the PropertySubTypes
    **/
    select?: PropertySubTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PropertySubTypesInclude | null
  }



  /**
   * Model PropertyUnitAttributes
   */


  export type AggregatePropertyUnitAttributes = {
    count: PropertyUnitAttributesCountAggregateOutputType | null
    avg: PropertyUnitAttributesAvgAggregateOutputType | null
    sum: PropertyUnitAttributesSumAggregateOutputType | null
    min: PropertyUnitAttributesMinAggregateOutputType | null
    max: PropertyUnitAttributesMaxAggregateOutputType | null
  }

  export type PropertyUnitAttributesAvgAggregateOutputType = {
    id: number
    property_unit_id: number
    attribute_id: number
    attribute_unit_id: number
    display_order: number | null
    created_by: number | null
    updated_by: number | null
  }

  export type PropertyUnitAttributesSumAggregateOutputType = {
    id: number
    property_unit_id: number
    attribute_id: number
    attribute_unit_id: number
    display_order: number | null
    created_by: number | null
    updated_by: number | null
  }

  export type PropertyUnitAttributesMinAggregateOutputType = {
    id: number
    property_unit_id: number
    attribute_id: number
    attribute_unit_id: number
    html_element_type: string | null
    display_order: number | null
    created_at: Date | null
    updated_at: Date | null
    created_by: number | null
    updated_by: number | null
  }

  export type PropertyUnitAttributesMaxAggregateOutputType = {
    id: number
    property_unit_id: number
    attribute_id: number
    attribute_unit_id: number
    html_element_type: string | null
    display_order: number | null
    created_at: Date | null
    updated_at: Date | null
    created_by: number | null
    updated_by: number | null
  }

  export type PropertyUnitAttributesCountAggregateOutputType = {
    id: number
    property_unit_id: number
    attribute_id: number
    attribute_unit_id: number
    html_element_type: number | null
    display_order: number | null
    created_at: number | null
    updated_at: number | null
    created_by: number | null
    updated_by: number | null
    _all: number
  }


  export type PropertyUnitAttributesAvgAggregateInputType = {
    id?: true
    property_unit_id?: true
    attribute_id?: true
    attribute_unit_id?: true
    display_order?: true
    created_by?: true
    updated_by?: true
  }

  export type PropertyUnitAttributesSumAggregateInputType = {
    id?: true
    property_unit_id?: true
    attribute_id?: true
    attribute_unit_id?: true
    display_order?: true
    created_by?: true
    updated_by?: true
  }

  export type PropertyUnitAttributesMinAggregateInputType = {
    id?: true
    property_unit_id?: true
    attribute_id?: true
    attribute_unit_id?: true
    html_element_type?: true
    display_order?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type PropertyUnitAttributesMaxAggregateInputType = {
    id?: true
    property_unit_id?: true
    attribute_id?: true
    attribute_unit_id?: true
    html_element_type?: true
    display_order?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type PropertyUnitAttributesCountAggregateInputType = {
    id?: true
    property_unit_id?: true
    attribute_id?: true
    attribute_unit_id?: true
    html_element_type?: true
    display_order?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
    _all?: true
  }

  export type PropertyUnitAttributesAggregateArgs = {
    /**
     * Filter which PropertyUnitAttributes to aggregate.
    **/
    where?: PropertyUnitAttributesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyUnitAttributes to fetch.
    **/
    orderBy?: Enumerable<PropertyUnitAttributesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: PropertyUnitAttributesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyUnitAttributes from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyUnitAttributes.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PropertyUnitAttributes
    **/
    count?: true | PropertyUnitAttributesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: PropertyUnitAttributesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: PropertyUnitAttributesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: PropertyUnitAttributesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: PropertyUnitAttributesMaxAggregateInputType
  }

  export type GetPropertyUnitAttributesAggregateType<T extends PropertyUnitAttributesAggregateArgs> = {
    [P in keyof T & keyof AggregatePropertyUnitAttributes]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePropertyUnitAttributes[P]>
      : GetScalarType<T[P], AggregatePropertyUnitAttributes[P]>
  }



  export type PropertyUnitAttributesSelect = {
    id?: boolean
    property_unit_id?: boolean
    attribute_id?: boolean
    attribute_unit_id?: boolean
    html_element_type?: boolean
    display_order?: boolean
    created_at?: boolean
    updated_at?: boolean
    created_by?: boolean
    updated_by?: boolean
    Attributes?: boolean | AttributesArgs
    AttributeUnits?: boolean | AttributeUnitsArgs
    PropertyUnits?: boolean | PropertyUnitsArgs
    ScopeOfWorkPropertyUnits?: boolean | ScopeOfWorkPropertyUnitsFindManyArgs
  }

  export type PropertyUnitAttributesInclude = {
    Attributes?: boolean | AttributesArgs
    AttributeUnits?: boolean | AttributeUnitsArgs
    PropertyUnits?: boolean | PropertyUnitsArgs
    ScopeOfWorkPropertyUnits?: boolean | ScopeOfWorkPropertyUnitsFindManyArgs
  }

  export type PropertyUnitAttributesGetPayload<
    S extends boolean | null | undefined | PropertyUnitAttributesArgs,
    U = keyof S
      > = S extends true
        ? PropertyUnitAttributes
    : S extends undefined
    ? never
    : S extends PropertyUnitAttributesArgs | PropertyUnitAttributesFindManyArgs
    ?'include' extends U
    ? PropertyUnitAttributes  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'Attributes'
        ? AttributesGetPayload<S['include'][P]> :
        P extends 'AttributeUnits'
        ? AttributeUnitsGetPayload<S['include'][P]> :
        P extends 'PropertyUnits'
        ? PropertyUnitsGetPayload<S['include'][P]> :
        P extends 'ScopeOfWorkPropertyUnits'
        ? Array < ScopeOfWorkPropertyUnitsGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof PropertyUnitAttributes ?PropertyUnitAttributes [P]
  : 
          P extends 'Attributes'
        ? AttributesGetPayload<S['select'][P]> :
        P extends 'AttributeUnits'
        ? AttributeUnitsGetPayload<S['select'][P]> :
        P extends 'PropertyUnits'
        ? PropertyUnitsGetPayload<S['select'][P]> :
        P extends 'ScopeOfWorkPropertyUnits'
        ? Array < ScopeOfWorkPropertyUnitsGetPayload<S['select'][P]>>  : never
  } 
    : PropertyUnitAttributes
  : PropertyUnitAttributes


  type PropertyUnitAttributesCountArgs = Merge<
    Omit<PropertyUnitAttributesFindManyArgs, 'select' | 'include'> & {
      select?: PropertyUnitAttributesCountAggregateInputType | true
    }
  >

  export interface PropertyUnitAttributesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one PropertyUnitAttributes that matches the filter.
     * @param {PropertyUnitAttributesFindUniqueArgs} args - Arguments to find a PropertyUnitAttributes
     * @example
     * // Get one PropertyUnitAttributes
     * const propertyUnitAttributes = await prisma.propertyUnitAttributes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PropertyUnitAttributesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PropertyUnitAttributesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PropertyUnitAttributes'> extends True ? CheckSelect<T, Prisma__PropertyUnitAttributesClient<PropertyUnitAttributes>, Prisma__PropertyUnitAttributesClient<PropertyUnitAttributesGetPayload<T>>> : CheckSelect<T, Prisma__PropertyUnitAttributesClient<PropertyUnitAttributes | null >, Prisma__PropertyUnitAttributesClient<PropertyUnitAttributesGetPayload<T> | null >>

    /**
     * Find the first PropertyUnitAttributes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyUnitAttributesFindFirstArgs} args - Arguments to find a PropertyUnitAttributes
     * @example
     * // Get one PropertyUnitAttributes
     * const propertyUnitAttributes = await prisma.propertyUnitAttributes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PropertyUnitAttributesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PropertyUnitAttributesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PropertyUnitAttributes'> extends True ? CheckSelect<T, Prisma__PropertyUnitAttributesClient<PropertyUnitAttributes>, Prisma__PropertyUnitAttributesClient<PropertyUnitAttributesGetPayload<T>>> : CheckSelect<T, Prisma__PropertyUnitAttributesClient<PropertyUnitAttributes | null >, Prisma__PropertyUnitAttributesClient<PropertyUnitAttributesGetPayload<T> | null >>

    /**
     * Find zero or more PropertyUnitAttributes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyUnitAttributesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PropertyUnitAttributes
     * const propertyUnitAttributes = await prisma.propertyUnitAttributes.findMany()
     * 
     * // Get first 10 PropertyUnitAttributes
     * const propertyUnitAttributes = await prisma.propertyUnitAttributes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertyUnitAttributesWithIdOnly = await prisma.propertyUnitAttributes.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PropertyUnitAttributesFindManyArgs>(
      args?: SelectSubset<T, PropertyUnitAttributesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<PropertyUnitAttributes>>, PrismaPromise<Array<PropertyUnitAttributesGetPayload<T>>>>

    /**
     * Create a PropertyUnitAttributes.
     * @param {PropertyUnitAttributesCreateArgs} args - Arguments to create a PropertyUnitAttributes.
     * @example
     * // Create one PropertyUnitAttributes
     * const PropertyUnitAttributes = await prisma.propertyUnitAttributes.create({
     *   data: {
     *     // ... data to create a PropertyUnitAttributes
     *   }
     * })
     * 
    **/
    create<T extends PropertyUnitAttributesCreateArgs>(
      args: SelectSubset<T, PropertyUnitAttributesCreateArgs>
    ): CheckSelect<T, Prisma__PropertyUnitAttributesClient<PropertyUnitAttributes>, Prisma__PropertyUnitAttributesClient<PropertyUnitAttributesGetPayload<T>>>

    /**
     * Delete a PropertyUnitAttributes.
     * @param {PropertyUnitAttributesDeleteArgs} args - Arguments to delete one PropertyUnitAttributes.
     * @example
     * // Delete one PropertyUnitAttributes
     * const PropertyUnitAttributes = await prisma.propertyUnitAttributes.delete({
     *   where: {
     *     // ... filter to delete one PropertyUnitAttributes
     *   }
     * })
     * 
    **/
    delete<T extends PropertyUnitAttributesDeleteArgs>(
      args: SelectSubset<T, PropertyUnitAttributesDeleteArgs>
    ): CheckSelect<T, Prisma__PropertyUnitAttributesClient<PropertyUnitAttributes>, Prisma__PropertyUnitAttributesClient<PropertyUnitAttributesGetPayload<T>>>

    /**
     * Update one PropertyUnitAttributes.
     * @param {PropertyUnitAttributesUpdateArgs} args - Arguments to update one PropertyUnitAttributes.
     * @example
     * // Update one PropertyUnitAttributes
     * const propertyUnitAttributes = await prisma.propertyUnitAttributes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PropertyUnitAttributesUpdateArgs>(
      args: SelectSubset<T, PropertyUnitAttributesUpdateArgs>
    ): CheckSelect<T, Prisma__PropertyUnitAttributesClient<PropertyUnitAttributes>, Prisma__PropertyUnitAttributesClient<PropertyUnitAttributesGetPayload<T>>>

    /**
     * Delete zero or more PropertyUnitAttributes.
     * @param {PropertyUnitAttributesDeleteManyArgs} args - Arguments to filter PropertyUnitAttributes to delete.
     * @example
     * // Delete a few PropertyUnitAttributes
     * const { count } = await prisma.propertyUnitAttributes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PropertyUnitAttributesDeleteManyArgs>(
      args?: SelectSubset<T, PropertyUnitAttributesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyUnitAttributes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyUnitAttributesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PropertyUnitAttributes
     * const propertyUnitAttributes = await prisma.propertyUnitAttributes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PropertyUnitAttributesUpdateManyArgs>(
      args: SelectSubset<T, PropertyUnitAttributesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one PropertyUnitAttributes.
     * @param {PropertyUnitAttributesUpsertArgs} args - Arguments to update or create a PropertyUnitAttributes.
     * @example
     * // Update or create a PropertyUnitAttributes
     * const propertyUnitAttributes = await prisma.propertyUnitAttributes.upsert({
     *   create: {
     *     // ... data to create a PropertyUnitAttributes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PropertyUnitAttributes we want to update
     *   }
     * })
    **/
    upsert<T extends PropertyUnitAttributesUpsertArgs>(
      args: SelectSubset<T, PropertyUnitAttributesUpsertArgs>
    ): CheckSelect<T, Prisma__PropertyUnitAttributesClient<PropertyUnitAttributes>, Prisma__PropertyUnitAttributesClient<PropertyUnitAttributesGetPayload<T>>>

    /**
     * Count the number of PropertyUnitAttributes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyUnitAttributesCountArgs} args - Arguments to filter PropertyUnitAttributes to count.
     * @example
     * // Count the number of PropertyUnitAttributes
     * const count = await prisma.propertyUnitAttributes.count({
     *   where: {
     *     // ... the filter for the PropertyUnitAttributes we want to count
     *   }
     * })
    **/
    count<T extends PropertyUnitAttributesCountArgs>(
      args?: Subset<T, PropertyUnitAttributesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertyUnitAttributesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PropertyUnitAttributes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyUnitAttributesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertyUnitAttributesAggregateArgs>(args: Subset<T, PropertyUnitAttributesAggregateArgs>): PrismaPromise<GetPropertyUnitAttributesAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for PropertyUnitAttributes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PropertyUnitAttributesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Attributes<T extends AttributesArgs = {}>(args?: Subset<T, AttributesArgs>): CheckSelect<T, Prisma__AttributesClient<Attributes | null >, Prisma__AttributesClient<AttributesGetPayload<T> | null >>;

    AttributeUnits<T extends AttributeUnitsArgs = {}>(args?: Subset<T, AttributeUnitsArgs>): CheckSelect<T, Prisma__AttributeUnitsClient<AttributeUnits | null >, Prisma__AttributeUnitsClient<AttributeUnitsGetPayload<T> | null >>;

    PropertyUnits<T extends PropertyUnitsArgs = {}>(args?: Subset<T, PropertyUnitsArgs>): CheckSelect<T, Prisma__PropertyUnitsClient<PropertyUnits | null >, Prisma__PropertyUnitsClient<PropertyUnitsGetPayload<T> | null >>;

    ScopeOfWorkPropertyUnits<T extends ScopeOfWorkPropertyUnitsFindManyArgs = {}>(args?: Subset<T, ScopeOfWorkPropertyUnitsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ScopeOfWorkPropertyUnits>>, PrismaPromise<Array<ScopeOfWorkPropertyUnitsGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * PropertyUnitAttributes findUnique
   */
  export type PropertyUnitAttributesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the PropertyUnitAttributes
    **/
    select?: PropertyUnitAttributesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PropertyUnitAttributesInclude | null
    /**
     * Throw an Error if a PropertyUnitAttributes can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which PropertyUnitAttributes to fetch.
    **/
    where: PropertyUnitAttributesWhereUniqueInput
  }


  /**
   * PropertyUnitAttributes findFirst
   */
  export type PropertyUnitAttributesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the PropertyUnitAttributes
    **/
    select?: PropertyUnitAttributesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PropertyUnitAttributesInclude | null
    /**
     * Throw an Error if a PropertyUnitAttributes can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which PropertyUnitAttributes to fetch.
    **/
    where?: PropertyUnitAttributesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyUnitAttributes to fetch.
    **/
    orderBy?: Enumerable<PropertyUnitAttributesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyUnitAttributes.
    **/
    cursor?: PropertyUnitAttributesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyUnitAttributes from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyUnitAttributes.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyUnitAttributes.
    **/
    distinct?: Enumerable<PropertyUnitAttributesScalarFieldEnum>
  }


  /**
   * PropertyUnitAttributes findMany
   */
  export type PropertyUnitAttributesFindManyArgs = {
    /**
     * Select specific fields to fetch from the PropertyUnitAttributes
    **/
    select?: PropertyUnitAttributesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PropertyUnitAttributesInclude | null
    /**
     * Filter, which PropertyUnitAttributes to fetch.
    **/
    where?: PropertyUnitAttributesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyUnitAttributes to fetch.
    **/
    orderBy?: Enumerable<PropertyUnitAttributesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PropertyUnitAttributes.
    **/
    cursor?: PropertyUnitAttributesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyUnitAttributes from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyUnitAttributes.
    **/
    skip?: number
    distinct?: Enumerable<PropertyUnitAttributesScalarFieldEnum>
  }


  /**
   * PropertyUnitAttributes create
   */
  export type PropertyUnitAttributesCreateArgs = {
    /**
     * Select specific fields to fetch from the PropertyUnitAttributes
    **/
    select?: PropertyUnitAttributesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PropertyUnitAttributesInclude | null
    /**
     * The data needed to create a PropertyUnitAttributes.
    **/
    data: XOR<PropertyUnitAttributesCreateInput, PropertyUnitAttributesUncheckedCreateInput>
  }


  /**
   * PropertyUnitAttributes update
   */
  export type PropertyUnitAttributesUpdateArgs = {
    /**
     * Select specific fields to fetch from the PropertyUnitAttributes
    **/
    select?: PropertyUnitAttributesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PropertyUnitAttributesInclude | null
    /**
     * The data needed to update a PropertyUnitAttributes.
    **/
    data: XOR<PropertyUnitAttributesUpdateInput, PropertyUnitAttributesUncheckedUpdateInput>
    /**
     * Choose, which PropertyUnitAttributes to update.
    **/
    where: PropertyUnitAttributesWhereUniqueInput
  }


  /**
   * PropertyUnitAttributes updateMany
   */
  export type PropertyUnitAttributesUpdateManyArgs = {
    data: XOR<PropertyUnitAttributesUpdateManyMutationInput, PropertyUnitAttributesUncheckedUpdateManyInput>
    where?: PropertyUnitAttributesWhereInput
  }


  /**
   * PropertyUnitAttributes upsert
   */
  export type PropertyUnitAttributesUpsertArgs = {
    /**
     * Select specific fields to fetch from the PropertyUnitAttributes
    **/
    select?: PropertyUnitAttributesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PropertyUnitAttributesInclude | null
    /**
     * The filter to search for the PropertyUnitAttributes to update in case it exists.
    **/
    where: PropertyUnitAttributesWhereUniqueInput
    /**
     * In case the PropertyUnitAttributes found by the `where` argument doesn't exist, create a new PropertyUnitAttributes with this data.
    **/
    create: XOR<PropertyUnitAttributesCreateInput, PropertyUnitAttributesUncheckedCreateInput>
    /**
     * In case the PropertyUnitAttributes was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<PropertyUnitAttributesUpdateInput, PropertyUnitAttributesUncheckedUpdateInput>
  }


  /**
   * PropertyUnitAttributes delete
   */
  export type PropertyUnitAttributesDeleteArgs = {
    /**
     * Select specific fields to fetch from the PropertyUnitAttributes
    **/
    select?: PropertyUnitAttributesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PropertyUnitAttributesInclude | null
    /**
     * Filter which PropertyUnitAttributes to delete.
    **/
    where: PropertyUnitAttributesWhereUniqueInput
  }


  /**
   * PropertyUnitAttributes deleteMany
   */
  export type PropertyUnitAttributesDeleteManyArgs = {
    where?: PropertyUnitAttributesWhereInput
  }


  /**
   * PropertyUnitAttributes without action
   */
  export type PropertyUnitAttributesArgs = {
    /**
     * Select specific fields to fetch from the PropertyUnitAttributes
    **/
    select?: PropertyUnitAttributesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PropertyUnitAttributesInclude | null
  }



  /**
   * Model PropertyUnitProductCategories
   */


  export type AggregatePropertyUnitProductCategories = {
    count: PropertyUnitProductCategoriesCountAggregateOutputType | null
    avg: PropertyUnitProductCategoriesAvgAggregateOutputType | null
    sum: PropertyUnitProductCategoriesSumAggregateOutputType | null
    min: PropertyUnitProductCategoriesMinAggregateOutputType | null
    max: PropertyUnitProductCategoriesMaxAggregateOutputType | null
  }

  export type PropertyUnitProductCategoriesAvgAggregateOutputType = {
    id: number
    property_unit_id: number
    product_category_id: number
    created_by: number | null
    updated_by: number | null
  }

  export type PropertyUnitProductCategoriesSumAggregateOutputType = {
    id: number
    property_unit_id: number
    product_category_id: number
    created_by: number | null
    updated_by: number | null
  }

  export type PropertyUnitProductCategoriesMinAggregateOutputType = {
    id: number
    property_unit_id: number
    product_category_id: number
    created_at: Date | null
    updated_at: Date | null
    created_by: number | null
    updated_by: number | null
  }

  export type PropertyUnitProductCategoriesMaxAggregateOutputType = {
    id: number
    property_unit_id: number
    product_category_id: number
    created_at: Date | null
    updated_at: Date | null
    created_by: number | null
    updated_by: number | null
  }

  export type PropertyUnitProductCategoriesCountAggregateOutputType = {
    id: number
    property_unit_id: number
    product_category_id: number
    created_at: number | null
    updated_at: number | null
    created_by: number | null
    updated_by: number | null
    _all: number
  }


  export type PropertyUnitProductCategoriesAvgAggregateInputType = {
    id?: true
    property_unit_id?: true
    product_category_id?: true
    created_by?: true
    updated_by?: true
  }

  export type PropertyUnitProductCategoriesSumAggregateInputType = {
    id?: true
    property_unit_id?: true
    product_category_id?: true
    created_by?: true
    updated_by?: true
  }

  export type PropertyUnitProductCategoriesMinAggregateInputType = {
    id?: true
    property_unit_id?: true
    product_category_id?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type PropertyUnitProductCategoriesMaxAggregateInputType = {
    id?: true
    property_unit_id?: true
    product_category_id?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type PropertyUnitProductCategoriesCountAggregateInputType = {
    id?: true
    property_unit_id?: true
    product_category_id?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
    _all?: true
  }

  export type PropertyUnitProductCategoriesAggregateArgs = {
    /**
     * Filter which PropertyUnitProductCategories to aggregate.
    **/
    where?: PropertyUnitProductCategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyUnitProductCategories to fetch.
    **/
    orderBy?: Enumerable<PropertyUnitProductCategoriesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: PropertyUnitProductCategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyUnitProductCategories from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyUnitProductCategories.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PropertyUnitProductCategories
    **/
    count?: true | PropertyUnitProductCategoriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: PropertyUnitProductCategoriesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: PropertyUnitProductCategoriesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: PropertyUnitProductCategoriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: PropertyUnitProductCategoriesMaxAggregateInputType
  }

  export type GetPropertyUnitProductCategoriesAggregateType<T extends PropertyUnitProductCategoriesAggregateArgs> = {
    [P in keyof T & keyof AggregatePropertyUnitProductCategories]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePropertyUnitProductCategories[P]>
      : GetScalarType<T[P], AggregatePropertyUnitProductCategories[P]>
  }



  export type PropertyUnitProductCategoriesSelect = {
    id?: boolean
    property_unit_id?: boolean
    product_category_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    created_by?: boolean
    updated_by?: boolean
    ProductCategories?: boolean | ProductCategoriesArgs
    PropertyUnits?: boolean | PropertyUnitsArgs
    PropertyUnitProductCategoryProducts?: boolean | PropertyUnitProductCategoryProductsFindManyArgs
  }

  export type PropertyUnitProductCategoriesInclude = {
    ProductCategories?: boolean | ProductCategoriesArgs
    PropertyUnits?: boolean | PropertyUnitsArgs
    PropertyUnitProductCategoryProducts?: boolean | PropertyUnitProductCategoryProductsFindManyArgs
  }

  export type PropertyUnitProductCategoriesGetPayload<
    S extends boolean | null | undefined | PropertyUnitProductCategoriesArgs,
    U = keyof S
      > = S extends true
        ? PropertyUnitProductCategories
    : S extends undefined
    ? never
    : S extends PropertyUnitProductCategoriesArgs | PropertyUnitProductCategoriesFindManyArgs
    ?'include' extends U
    ? PropertyUnitProductCategories  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'ProductCategories'
        ? ProductCategoriesGetPayload<S['include'][P]> :
        P extends 'PropertyUnits'
        ? PropertyUnitsGetPayload<S['include'][P]> :
        P extends 'PropertyUnitProductCategoryProducts'
        ? Array < PropertyUnitProductCategoryProductsGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof PropertyUnitProductCategories ?PropertyUnitProductCategories [P]
  : 
          P extends 'ProductCategories'
        ? ProductCategoriesGetPayload<S['select'][P]> :
        P extends 'PropertyUnits'
        ? PropertyUnitsGetPayload<S['select'][P]> :
        P extends 'PropertyUnitProductCategoryProducts'
        ? Array < PropertyUnitProductCategoryProductsGetPayload<S['select'][P]>>  : never
  } 
    : PropertyUnitProductCategories
  : PropertyUnitProductCategories


  type PropertyUnitProductCategoriesCountArgs = Merge<
    Omit<PropertyUnitProductCategoriesFindManyArgs, 'select' | 'include'> & {
      select?: PropertyUnitProductCategoriesCountAggregateInputType | true
    }
  >

  export interface PropertyUnitProductCategoriesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one PropertyUnitProductCategories that matches the filter.
     * @param {PropertyUnitProductCategoriesFindUniqueArgs} args - Arguments to find a PropertyUnitProductCategories
     * @example
     * // Get one PropertyUnitProductCategories
     * const propertyUnitProductCategories = await prisma.propertyUnitProductCategories.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PropertyUnitProductCategoriesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PropertyUnitProductCategoriesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PropertyUnitProductCategories'> extends True ? CheckSelect<T, Prisma__PropertyUnitProductCategoriesClient<PropertyUnitProductCategories>, Prisma__PropertyUnitProductCategoriesClient<PropertyUnitProductCategoriesGetPayload<T>>> : CheckSelect<T, Prisma__PropertyUnitProductCategoriesClient<PropertyUnitProductCategories | null >, Prisma__PropertyUnitProductCategoriesClient<PropertyUnitProductCategoriesGetPayload<T> | null >>

    /**
     * Find the first PropertyUnitProductCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyUnitProductCategoriesFindFirstArgs} args - Arguments to find a PropertyUnitProductCategories
     * @example
     * // Get one PropertyUnitProductCategories
     * const propertyUnitProductCategories = await prisma.propertyUnitProductCategories.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PropertyUnitProductCategoriesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PropertyUnitProductCategoriesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PropertyUnitProductCategories'> extends True ? CheckSelect<T, Prisma__PropertyUnitProductCategoriesClient<PropertyUnitProductCategories>, Prisma__PropertyUnitProductCategoriesClient<PropertyUnitProductCategoriesGetPayload<T>>> : CheckSelect<T, Prisma__PropertyUnitProductCategoriesClient<PropertyUnitProductCategories | null >, Prisma__PropertyUnitProductCategoriesClient<PropertyUnitProductCategoriesGetPayload<T> | null >>

    /**
     * Find zero or more PropertyUnitProductCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyUnitProductCategoriesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PropertyUnitProductCategories
     * const propertyUnitProductCategories = await prisma.propertyUnitProductCategories.findMany()
     * 
     * // Get first 10 PropertyUnitProductCategories
     * const propertyUnitProductCategories = await prisma.propertyUnitProductCategories.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertyUnitProductCategoriesWithIdOnly = await prisma.propertyUnitProductCategories.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PropertyUnitProductCategoriesFindManyArgs>(
      args?: SelectSubset<T, PropertyUnitProductCategoriesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<PropertyUnitProductCategories>>, PrismaPromise<Array<PropertyUnitProductCategoriesGetPayload<T>>>>

    /**
     * Create a PropertyUnitProductCategories.
     * @param {PropertyUnitProductCategoriesCreateArgs} args - Arguments to create a PropertyUnitProductCategories.
     * @example
     * // Create one PropertyUnitProductCategories
     * const PropertyUnitProductCategories = await prisma.propertyUnitProductCategories.create({
     *   data: {
     *     // ... data to create a PropertyUnitProductCategories
     *   }
     * })
     * 
    **/
    create<T extends PropertyUnitProductCategoriesCreateArgs>(
      args: SelectSubset<T, PropertyUnitProductCategoriesCreateArgs>
    ): CheckSelect<T, Prisma__PropertyUnitProductCategoriesClient<PropertyUnitProductCategories>, Prisma__PropertyUnitProductCategoriesClient<PropertyUnitProductCategoriesGetPayload<T>>>

    /**
     * Delete a PropertyUnitProductCategories.
     * @param {PropertyUnitProductCategoriesDeleteArgs} args - Arguments to delete one PropertyUnitProductCategories.
     * @example
     * // Delete one PropertyUnitProductCategories
     * const PropertyUnitProductCategories = await prisma.propertyUnitProductCategories.delete({
     *   where: {
     *     // ... filter to delete one PropertyUnitProductCategories
     *   }
     * })
     * 
    **/
    delete<T extends PropertyUnitProductCategoriesDeleteArgs>(
      args: SelectSubset<T, PropertyUnitProductCategoriesDeleteArgs>
    ): CheckSelect<T, Prisma__PropertyUnitProductCategoriesClient<PropertyUnitProductCategories>, Prisma__PropertyUnitProductCategoriesClient<PropertyUnitProductCategoriesGetPayload<T>>>

    /**
     * Update one PropertyUnitProductCategories.
     * @param {PropertyUnitProductCategoriesUpdateArgs} args - Arguments to update one PropertyUnitProductCategories.
     * @example
     * // Update one PropertyUnitProductCategories
     * const propertyUnitProductCategories = await prisma.propertyUnitProductCategories.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PropertyUnitProductCategoriesUpdateArgs>(
      args: SelectSubset<T, PropertyUnitProductCategoriesUpdateArgs>
    ): CheckSelect<T, Prisma__PropertyUnitProductCategoriesClient<PropertyUnitProductCategories>, Prisma__PropertyUnitProductCategoriesClient<PropertyUnitProductCategoriesGetPayload<T>>>

    /**
     * Delete zero or more PropertyUnitProductCategories.
     * @param {PropertyUnitProductCategoriesDeleteManyArgs} args - Arguments to filter PropertyUnitProductCategories to delete.
     * @example
     * // Delete a few PropertyUnitProductCategories
     * const { count } = await prisma.propertyUnitProductCategories.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PropertyUnitProductCategoriesDeleteManyArgs>(
      args?: SelectSubset<T, PropertyUnitProductCategoriesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyUnitProductCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyUnitProductCategoriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PropertyUnitProductCategories
     * const propertyUnitProductCategories = await prisma.propertyUnitProductCategories.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PropertyUnitProductCategoriesUpdateManyArgs>(
      args: SelectSubset<T, PropertyUnitProductCategoriesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one PropertyUnitProductCategories.
     * @param {PropertyUnitProductCategoriesUpsertArgs} args - Arguments to update or create a PropertyUnitProductCategories.
     * @example
     * // Update or create a PropertyUnitProductCategories
     * const propertyUnitProductCategories = await prisma.propertyUnitProductCategories.upsert({
     *   create: {
     *     // ... data to create a PropertyUnitProductCategories
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PropertyUnitProductCategories we want to update
     *   }
     * })
    **/
    upsert<T extends PropertyUnitProductCategoriesUpsertArgs>(
      args: SelectSubset<T, PropertyUnitProductCategoriesUpsertArgs>
    ): CheckSelect<T, Prisma__PropertyUnitProductCategoriesClient<PropertyUnitProductCategories>, Prisma__PropertyUnitProductCategoriesClient<PropertyUnitProductCategoriesGetPayload<T>>>

    /**
     * Count the number of PropertyUnitProductCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyUnitProductCategoriesCountArgs} args - Arguments to filter PropertyUnitProductCategories to count.
     * @example
     * // Count the number of PropertyUnitProductCategories
     * const count = await prisma.propertyUnitProductCategories.count({
     *   where: {
     *     // ... the filter for the PropertyUnitProductCategories we want to count
     *   }
     * })
    **/
    count<T extends PropertyUnitProductCategoriesCountArgs>(
      args?: Subset<T, PropertyUnitProductCategoriesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertyUnitProductCategoriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PropertyUnitProductCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyUnitProductCategoriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertyUnitProductCategoriesAggregateArgs>(args: Subset<T, PropertyUnitProductCategoriesAggregateArgs>): PrismaPromise<GetPropertyUnitProductCategoriesAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for PropertyUnitProductCategories.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PropertyUnitProductCategoriesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    ProductCategories<T extends ProductCategoriesArgs = {}>(args?: Subset<T, ProductCategoriesArgs>): CheckSelect<T, Prisma__ProductCategoriesClient<ProductCategories | null >, Prisma__ProductCategoriesClient<ProductCategoriesGetPayload<T> | null >>;

    PropertyUnits<T extends PropertyUnitsArgs = {}>(args?: Subset<T, PropertyUnitsArgs>): CheckSelect<T, Prisma__PropertyUnitsClient<PropertyUnits | null >, Prisma__PropertyUnitsClient<PropertyUnitsGetPayload<T> | null >>;

    PropertyUnitProductCategoryProducts<T extends PropertyUnitProductCategoryProductsFindManyArgs = {}>(args?: Subset<T, PropertyUnitProductCategoryProductsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<PropertyUnitProductCategoryProducts>>, PrismaPromise<Array<PropertyUnitProductCategoryProductsGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * PropertyUnitProductCategories findUnique
   */
  export type PropertyUnitProductCategoriesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the PropertyUnitProductCategories
    **/
    select?: PropertyUnitProductCategoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PropertyUnitProductCategoriesInclude | null
    /**
     * Throw an Error if a PropertyUnitProductCategories can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which PropertyUnitProductCategories to fetch.
    **/
    where: PropertyUnitProductCategoriesWhereUniqueInput
  }


  /**
   * PropertyUnitProductCategories findFirst
   */
  export type PropertyUnitProductCategoriesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the PropertyUnitProductCategories
    **/
    select?: PropertyUnitProductCategoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PropertyUnitProductCategoriesInclude | null
    /**
     * Throw an Error if a PropertyUnitProductCategories can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which PropertyUnitProductCategories to fetch.
    **/
    where?: PropertyUnitProductCategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyUnitProductCategories to fetch.
    **/
    orderBy?: Enumerable<PropertyUnitProductCategoriesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyUnitProductCategories.
    **/
    cursor?: PropertyUnitProductCategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyUnitProductCategories from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyUnitProductCategories.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyUnitProductCategories.
    **/
    distinct?: Enumerable<PropertyUnitProductCategoriesScalarFieldEnum>
  }


  /**
   * PropertyUnitProductCategories findMany
   */
  export type PropertyUnitProductCategoriesFindManyArgs = {
    /**
     * Select specific fields to fetch from the PropertyUnitProductCategories
    **/
    select?: PropertyUnitProductCategoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PropertyUnitProductCategoriesInclude | null
    /**
     * Filter, which PropertyUnitProductCategories to fetch.
    **/
    where?: PropertyUnitProductCategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyUnitProductCategories to fetch.
    **/
    orderBy?: Enumerable<PropertyUnitProductCategoriesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PropertyUnitProductCategories.
    **/
    cursor?: PropertyUnitProductCategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyUnitProductCategories from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyUnitProductCategories.
    **/
    skip?: number
    distinct?: Enumerable<PropertyUnitProductCategoriesScalarFieldEnum>
  }


  /**
   * PropertyUnitProductCategories create
   */
  export type PropertyUnitProductCategoriesCreateArgs = {
    /**
     * Select specific fields to fetch from the PropertyUnitProductCategories
    **/
    select?: PropertyUnitProductCategoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PropertyUnitProductCategoriesInclude | null
    /**
     * The data needed to create a PropertyUnitProductCategories.
    **/
    data: XOR<PropertyUnitProductCategoriesCreateInput, PropertyUnitProductCategoriesUncheckedCreateInput>
  }


  /**
   * PropertyUnitProductCategories update
   */
  export type PropertyUnitProductCategoriesUpdateArgs = {
    /**
     * Select specific fields to fetch from the PropertyUnitProductCategories
    **/
    select?: PropertyUnitProductCategoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PropertyUnitProductCategoriesInclude | null
    /**
     * The data needed to update a PropertyUnitProductCategories.
    **/
    data: XOR<PropertyUnitProductCategoriesUpdateInput, PropertyUnitProductCategoriesUncheckedUpdateInput>
    /**
     * Choose, which PropertyUnitProductCategories to update.
    **/
    where: PropertyUnitProductCategoriesWhereUniqueInput
  }


  /**
   * PropertyUnitProductCategories updateMany
   */
  export type PropertyUnitProductCategoriesUpdateManyArgs = {
    data: XOR<PropertyUnitProductCategoriesUpdateManyMutationInput, PropertyUnitProductCategoriesUncheckedUpdateManyInput>
    where?: PropertyUnitProductCategoriesWhereInput
  }


  /**
   * PropertyUnitProductCategories upsert
   */
  export type PropertyUnitProductCategoriesUpsertArgs = {
    /**
     * Select specific fields to fetch from the PropertyUnitProductCategories
    **/
    select?: PropertyUnitProductCategoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PropertyUnitProductCategoriesInclude | null
    /**
     * The filter to search for the PropertyUnitProductCategories to update in case it exists.
    **/
    where: PropertyUnitProductCategoriesWhereUniqueInput
    /**
     * In case the PropertyUnitProductCategories found by the `where` argument doesn't exist, create a new PropertyUnitProductCategories with this data.
    **/
    create: XOR<PropertyUnitProductCategoriesCreateInput, PropertyUnitProductCategoriesUncheckedCreateInput>
    /**
     * In case the PropertyUnitProductCategories was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<PropertyUnitProductCategoriesUpdateInput, PropertyUnitProductCategoriesUncheckedUpdateInput>
  }


  /**
   * PropertyUnitProductCategories delete
   */
  export type PropertyUnitProductCategoriesDeleteArgs = {
    /**
     * Select specific fields to fetch from the PropertyUnitProductCategories
    **/
    select?: PropertyUnitProductCategoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PropertyUnitProductCategoriesInclude | null
    /**
     * Filter which PropertyUnitProductCategories to delete.
    **/
    where: PropertyUnitProductCategoriesWhereUniqueInput
  }


  /**
   * PropertyUnitProductCategories deleteMany
   */
  export type PropertyUnitProductCategoriesDeleteManyArgs = {
    where?: PropertyUnitProductCategoriesWhereInput
  }


  /**
   * PropertyUnitProductCategories without action
   */
  export type PropertyUnitProductCategoriesArgs = {
    /**
     * Select specific fields to fetch from the PropertyUnitProductCategories
    **/
    select?: PropertyUnitProductCategoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PropertyUnitProductCategoriesInclude | null
  }



  /**
   * Model PropertyUnitProductCategoryProducts
   */


  export type AggregatePropertyUnitProductCategoryProducts = {
    count: PropertyUnitProductCategoryProductsCountAggregateOutputType | null
    avg: PropertyUnitProductCategoryProductsAvgAggregateOutputType | null
    sum: PropertyUnitProductCategoryProductsSumAggregateOutputType | null
    min: PropertyUnitProductCategoryProductsMinAggregateOutputType | null
    max: PropertyUnitProductCategoryProductsMaxAggregateOutputType | null
  }

  export type PropertyUnitProductCategoryProductsAvgAggregateOutputType = {
    id: number
    property_unit_product_category_id: number
    product_id: number
    display_order: number | null
    created_by: number | null
    updated_by: number | null
  }

  export type PropertyUnitProductCategoryProductsSumAggregateOutputType = {
    id: number
    property_unit_product_category_id: number
    product_id: number
    display_order: number | null
    created_by: number | null
    updated_by: number | null
  }

  export type PropertyUnitProductCategoryProductsMinAggregateOutputType = {
    id: number
    property_unit_product_category_id: number
    product_id: number
    display_order: number | null
    created_at: Date | null
    updated_at: Date | null
    created_by: number | null
    updated_by: number | null
  }

  export type PropertyUnitProductCategoryProductsMaxAggregateOutputType = {
    id: number
    property_unit_product_category_id: number
    product_id: number
    display_order: number | null
    created_at: Date | null
    updated_at: Date | null
    created_by: number | null
    updated_by: number | null
  }

  export type PropertyUnitProductCategoryProductsCountAggregateOutputType = {
    id: number
    property_unit_product_category_id: number
    product_id: number
    display_order: number | null
    created_at: number | null
    updated_at: number | null
    created_by: number | null
    updated_by: number | null
    _all: number
  }


  export type PropertyUnitProductCategoryProductsAvgAggregateInputType = {
    id?: true
    property_unit_product_category_id?: true
    product_id?: true
    display_order?: true
    created_by?: true
    updated_by?: true
  }

  export type PropertyUnitProductCategoryProductsSumAggregateInputType = {
    id?: true
    property_unit_product_category_id?: true
    product_id?: true
    display_order?: true
    created_by?: true
    updated_by?: true
  }

  export type PropertyUnitProductCategoryProductsMinAggregateInputType = {
    id?: true
    property_unit_product_category_id?: true
    product_id?: true
    display_order?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type PropertyUnitProductCategoryProductsMaxAggregateInputType = {
    id?: true
    property_unit_product_category_id?: true
    product_id?: true
    display_order?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type PropertyUnitProductCategoryProductsCountAggregateInputType = {
    id?: true
    property_unit_product_category_id?: true
    product_id?: true
    display_order?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
    _all?: true
  }

  export type PropertyUnitProductCategoryProductsAggregateArgs = {
    /**
     * Filter which PropertyUnitProductCategoryProducts to aggregate.
    **/
    where?: PropertyUnitProductCategoryProductsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyUnitProductCategoryProducts to fetch.
    **/
    orderBy?: Enumerable<PropertyUnitProductCategoryProductsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: PropertyUnitProductCategoryProductsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyUnitProductCategoryProducts from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyUnitProductCategoryProducts.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PropertyUnitProductCategoryProducts
    **/
    count?: true | PropertyUnitProductCategoryProductsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: PropertyUnitProductCategoryProductsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: PropertyUnitProductCategoryProductsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: PropertyUnitProductCategoryProductsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: PropertyUnitProductCategoryProductsMaxAggregateInputType
  }

  export type GetPropertyUnitProductCategoryProductsAggregateType<T extends PropertyUnitProductCategoryProductsAggregateArgs> = {
    [P in keyof T & keyof AggregatePropertyUnitProductCategoryProducts]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePropertyUnitProductCategoryProducts[P]>
      : GetScalarType<T[P], AggregatePropertyUnitProductCategoryProducts[P]>
  }



  export type PropertyUnitProductCategoryProductsSelect = {
    id?: boolean
    property_unit_product_category_id?: boolean
    product_id?: boolean
    display_order?: boolean
    created_at?: boolean
    updated_at?: boolean
    created_by?: boolean
    updated_by?: boolean
    Products?: boolean | ProductsArgs
    PropertyUnitProductCategories?: boolean | PropertyUnitProductCategoriesArgs
  }

  export type PropertyUnitProductCategoryProductsInclude = {
    Products?: boolean | ProductsArgs
    PropertyUnitProductCategories?: boolean | PropertyUnitProductCategoriesArgs
  }

  export type PropertyUnitProductCategoryProductsGetPayload<
    S extends boolean | null | undefined | PropertyUnitProductCategoryProductsArgs,
    U = keyof S
      > = S extends true
        ? PropertyUnitProductCategoryProducts
    : S extends undefined
    ? never
    : S extends PropertyUnitProductCategoryProductsArgs | PropertyUnitProductCategoryProductsFindManyArgs
    ?'include' extends U
    ? PropertyUnitProductCategoryProducts  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'Products'
        ? ProductsGetPayload<S['include'][P]> :
        P extends 'PropertyUnitProductCategories'
        ? PropertyUnitProductCategoriesGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof PropertyUnitProductCategoryProducts ?PropertyUnitProductCategoryProducts [P]
  : 
          P extends 'Products'
        ? ProductsGetPayload<S['select'][P]> :
        P extends 'PropertyUnitProductCategories'
        ? PropertyUnitProductCategoriesGetPayload<S['select'][P]> : never
  } 
    : PropertyUnitProductCategoryProducts
  : PropertyUnitProductCategoryProducts


  type PropertyUnitProductCategoryProductsCountArgs = Merge<
    Omit<PropertyUnitProductCategoryProductsFindManyArgs, 'select' | 'include'> & {
      select?: PropertyUnitProductCategoryProductsCountAggregateInputType | true
    }
  >

  export interface PropertyUnitProductCategoryProductsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one PropertyUnitProductCategoryProducts that matches the filter.
     * @param {PropertyUnitProductCategoryProductsFindUniqueArgs} args - Arguments to find a PropertyUnitProductCategoryProducts
     * @example
     * // Get one PropertyUnitProductCategoryProducts
     * const propertyUnitProductCategoryProducts = await prisma.propertyUnitProductCategoryProducts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PropertyUnitProductCategoryProductsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PropertyUnitProductCategoryProductsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PropertyUnitProductCategoryProducts'> extends True ? CheckSelect<T, Prisma__PropertyUnitProductCategoryProductsClient<PropertyUnitProductCategoryProducts>, Prisma__PropertyUnitProductCategoryProductsClient<PropertyUnitProductCategoryProductsGetPayload<T>>> : CheckSelect<T, Prisma__PropertyUnitProductCategoryProductsClient<PropertyUnitProductCategoryProducts | null >, Prisma__PropertyUnitProductCategoryProductsClient<PropertyUnitProductCategoryProductsGetPayload<T> | null >>

    /**
     * Find the first PropertyUnitProductCategoryProducts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyUnitProductCategoryProductsFindFirstArgs} args - Arguments to find a PropertyUnitProductCategoryProducts
     * @example
     * // Get one PropertyUnitProductCategoryProducts
     * const propertyUnitProductCategoryProducts = await prisma.propertyUnitProductCategoryProducts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PropertyUnitProductCategoryProductsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PropertyUnitProductCategoryProductsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PropertyUnitProductCategoryProducts'> extends True ? CheckSelect<T, Prisma__PropertyUnitProductCategoryProductsClient<PropertyUnitProductCategoryProducts>, Prisma__PropertyUnitProductCategoryProductsClient<PropertyUnitProductCategoryProductsGetPayload<T>>> : CheckSelect<T, Prisma__PropertyUnitProductCategoryProductsClient<PropertyUnitProductCategoryProducts | null >, Prisma__PropertyUnitProductCategoryProductsClient<PropertyUnitProductCategoryProductsGetPayload<T> | null >>

    /**
     * Find zero or more PropertyUnitProductCategoryProducts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyUnitProductCategoryProductsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PropertyUnitProductCategoryProducts
     * const propertyUnitProductCategoryProducts = await prisma.propertyUnitProductCategoryProducts.findMany()
     * 
     * // Get first 10 PropertyUnitProductCategoryProducts
     * const propertyUnitProductCategoryProducts = await prisma.propertyUnitProductCategoryProducts.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertyUnitProductCategoryProductsWithIdOnly = await prisma.propertyUnitProductCategoryProducts.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PropertyUnitProductCategoryProductsFindManyArgs>(
      args?: SelectSubset<T, PropertyUnitProductCategoryProductsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<PropertyUnitProductCategoryProducts>>, PrismaPromise<Array<PropertyUnitProductCategoryProductsGetPayload<T>>>>

    /**
     * Create a PropertyUnitProductCategoryProducts.
     * @param {PropertyUnitProductCategoryProductsCreateArgs} args - Arguments to create a PropertyUnitProductCategoryProducts.
     * @example
     * // Create one PropertyUnitProductCategoryProducts
     * const PropertyUnitProductCategoryProducts = await prisma.propertyUnitProductCategoryProducts.create({
     *   data: {
     *     // ... data to create a PropertyUnitProductCategoryProducts
     *   }
     * })
     * 
    **/
    create<T extends PropertyUnitProductCategoryProductsCreateArgs>(
      args: SelectSubset<T, PropertyUnitProductCategoryProductsCreateArgs>
    ): CheckSelect<T, Prisma__PropertyUnitProductCategoryProductsClient<PropertyUnitProductCategoryProducts>, Prisma__PropertyUnitProductCategoryProductsClient<PropertyUnitProductCategoryProductsGetPayload<T>>>

    /**
     * Delete a PropertyUnitProductCategoryProducts.
     * @param {PropertyUnitProductCategoryProductsDeleteArgs} args - Arguments to delete one PropertyUnitProductCategoryProducts.
     * @example
     * // Delete one PropertyUnitProductCategoryProducts
     * const PropertyUnitProductCategoryProducts = await prisma.propertyUnitProductCategoryProducts.delete({
     *   where: {
     *     // ... filter to delete one PropertyUnitProductCategoryProducts
     *   }
     * })
     * 
    **/
    delete<T extends PropertyUnitProductCategoryProductsDeleteArgs>(
      args: SelectSubset<T, PropertyUnitProductCategoryProductsDeleteArgs>
    ): CheckSelect<T, Prisma__PropertyUnitProductCategoryProductsClient<PropertyUnitProductCategoryProducts>, Prisma__PropertyUnitProductCategoryProductsClient<PropertyUnitProductCategoryProductsGetPayload<T>>>

    /**
     * Update one PropertyUnitProductCategoryProducts.
     * @param {PropertyUnitProductCategoryProductsUpdateArgs} args - Arguments to update one PropertyUnitProductCategoryProducts.
     * @example
     * // Update one PropertyUnitProductCategoryProducts
     * const propertyUnitProductCategoryProducts = await prisma.propertyUnitProductCategoryProducts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PropertyUnitProductCategoryProductsUpdateArgs>(
      args: SelectSubset<T, PropertyUnitProductCategoryProductsUpdateArgs>
    ): CheckSelect<T, Prisma__PropertyUnitProductCategoryProductsClient<PropertyUnitProductCategoryProducts>, Prisma__PropertyUnitProductCategoryProductsClient<PropertyUnitProductCategoryProductsGetPayload<T>>>

    /**
     * Delete zero or more PropertyUnitProductCategoryProducts.
     * @param {PropertyUnitProductCategoryProductsDeleteManyArgs} args - Arguments to filter PropertyUnitProductCategoryProducts to delete.
     * @example
     * // Delete a few PropertyUnitProductCategoryProducts
     * const { count } = await prisma.propertyUnitProductCategoryProducts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PropertyUnitProductCategoryProductsDeleteManyArgs>(
      args?: SelectSubset<T, PropertyUnitProductCategoryProductsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyUnitProductCategoryProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyUnitProductCategoryProductsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PropertyUnitProductCategoryProducts
     * const propertyUnitProductCategoryProducts = await prisma.propertyUnitProductCategoryProducts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PropertyUnitProductCategoryProductsUpdateManyArgs>(
      args: SelectSubset<T, PropertyUnitProductCategoryProductsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one PropertyUnitProductCategoryProducts.
     * @param {PropertyUnitProductCategoryProductsUpsertArgs} args - Arguments to update or create a PropertyUnitProductCategoryProducts.
     * @example
     * // Update or create a PropertyUnitProductCategoryProducts
     * const propertyUnitProductCategoryProducts = await prisma.propertyUnitProductCategoryProducts.upsert({
     *   create: {
     *     // ... data to create a PropertyUnitProductCategoryProducts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PropertyUnitProductCategoryProducts we want to update
     *   }
     * })
    **/
    upsert<T extends PropertyUnitProductCategoryProductsUpsertArgs>(
      args: SelectSubset<T, PropertyUnitProductCategoryProductsUpsertArgs>
    ): CheckSelect<T, Prisma__PropertyUnitProductCategoryProductsClient<PropertyUnitProductCategoryProducts>, Prisma__PropertyUnitProductCategoryProductsClient<PropertyUnitProductCategoryProductsGetPayload<T>>>

    /**
     * Count the number of PropertyUnitProductCategoryProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyUnitProductCategoryProductsCountArgs} args - Arguments to filter PropertyUnitProductCategoryProducts to count.
     * @example
     * // Count the number of PropertyUnitProductCategoryProducts
     * const count = await prisma.propertyUnitProductCategoryProducts.count({
     *   where: {
     *     // ... the filter for the PropertyUnitProductCategoryProducts we want to count
     *   }
     * })
    **/
    count<T extends PropertyUnitProductCategoryProductsCountArgs>(
      args?: Subset<T, PropertyUnitProductCategoryProductsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertyUnitProductCategoryProductsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PropertyUnitProductCategoryProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyUnitProductCategoryProductsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertyUnitProductCategoryProductsAggregateArgs>(args: Subset<T, PropertyUnitProductCategoryProductsAggregateArgs>): PrismaPromise<GetPropertyUnitProductCategoryProductsAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for PropertyUnitProductCategoryProducts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PropertyUnitProductCategoryProductsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Products<T extends ProductsArgs = {}>(args?: Subset<T, ProductsArgs>): CheckSelect<T, Prisma__ProductsClient<Products | null >, Prisma__ProductsClient<ProductsGetPayload<T> | null >>;

    PropertyUnitProductCategories<T extends PropertyUnitProductCategoriesArgs = {}>(args?: Subset<T, PropertyUnitProductCategoriesArgs>): CheckSelect<T, Prisma__PropertyUnitProductCategoriesClient<PropertyUnitProductCategories | null >, Prisma__PropertyUnitProductCategoriesClient<PropertyUnitProductCategoriesGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * PropertyUnitProductCategoryProducts findUnique
   */
  export type PropertyUnitProductCategoryProductsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the PropertyUnitProductCategoryProducts
    **/
    select?: PropertyUnitProductCategoryProductsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PropertyUnitProductCategoryProductsInclude | null
    /**
     * Throw an Error if a PropertyUnitProductCategoryProducts can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which PropertyUnitProductCategoryProducts to fetch.
    **/
    where: PropertyUnitProductCategoryProductsWhereUniqueInput
  }


  /**
   * PropertyUnitProductCategoryProducts findFirst
   */
  export type PropertyUnitProductCategoryProductsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the PropertyUnitProductCategoryProducts
    **/
    select?: PropertyUnitProductCategoryProductsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PropertyUnitProductCategoryProductsInclude | null
    /**
     * Throw an Error if a PropertyUnitProductCategoryProducts can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which PropertyUnitProductCategoryProducts to fetch.
    **/
    where?: PropertyUnitProductCategoryProductsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyUnitProductCategoryProducts to fetch.
    **/
    orderBy?: Enumerable<PropertyUnitProductCategoryProductsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyUnitProductCategoryProducts.
    **/
    cursor?: PropertyUnitProductCategoryProductsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyUnitProductCategoryProducts from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyUnitProductCategoryProducts.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyUnitProductCategoryProducts.
    **/
    distinct?: Enumerable<PropertyUnitProductCategoryProductsScalarFieldEnum>
  }


  /**
   * PropertyUnitProductCategoryProducts findMany
   */
  export type PropertyUnitProductCategoryProductsFindManyArgs = {
    /**
     * Select specific fields to fetch from the PropertyUnitProductCategoryProducts
    **/
    select?: PropertyUnitProductCategoryProductsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PropertyUnitProductCategoryProductsInclude | null
    /**
     * Filter, which PropertyUnitProductCategoryProducts to fetch.
    **/
    where?: PropertyUnitProductCategoryProductsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyUnitProductCategoryProducts to fetch.
    **/
    orderBy?: Enumerable<PropertyUnitProductCategoryProductsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PropertyUnitProductCategoryProducts.
    **/
    cursor?: PropertyUnitProductCategoryProductsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyUnitProductCategoryProducts from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyUnitProductCategoryProducts.
    **/
    skip?: number
    distinct?: Enumerable<PropertyUnitProductCategoryProductsScalarFieldEnum>
  }


  /**
   * PropertyUnitProductCategoryProducts create
   */
  export type PropertyUnitProductCategoryProductsCreateArgs = {
    /**
     * Select specific fields to fetch from the PropertyUnitProductCategoryProducts
    **/
    select?: PropertyUnitProductCategoryProductsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PropertyUnitProductCategoryProductsInclude | null
    /**
     * The data needed to create a PropertyUnitProductCategoryProducts.
    **/
    data: XOR<PropertyUnitProductCategoryProductsCreateInput, PropertyUnitProductCategoryProductsUncheckedCreateInput>
  }


  /**
   * PropertyUnitProductCategoryProducts update
   */
  export type PropertyUnitProductCategoryProductsUpdateArgs = {
    /**
     * Select specific fields to fetch from the PropertyUnitProductCategoryProducts
    **/
    select?: PropertyUnitProductCategoryProductsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PropertyUnitProductCategoryProductsInclude | null
    /**
     * The data needed to update a PropertyUnitProductCategoryProducts.
    **/
    data: XOR<PropertyUnitProductCategoryProductsUpdateInput, PropertyUnitProductCategoryProductsUncheckedUpdateInput>
    /**
     * Choose, which PropertyUnitProductCategoryProducts to update.
    **/
    where: PropertyUnitProductCategoryProductsWhereUniqueInput
  }


  /**
   * PropertyUnitProductCategoryProducts updateMany
   */
  export type PropertyUnitProductCategoryProductsUpdateManyArgs = {
    data: XOR<PropertyUnitProductCategoryProductsUpdateManyMutationInput, PropertyUnitProductCategoryProductsUncheckedUpdateManyInput>
    where?: PropertyUnitProductCategoryProductsWhereInput
  }


  /**
   * PropertyUnitProductCategoryProducts upsert
   */
  export type PropertyUnitProductCategoryProductsUpsertArgs = {
    /**
     * Select specific fields to fetch from the PropertyUnitProductCategoryProducts
    **/
    select?: PropertyUnitProductCategoryProductsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PropertyUnitProductCategoryProductsInclude | null
    /**
     * The filter to search for the PropertyUnitProductCategoryProducts to update in case it exists.
    **/
    where: PropertyUnitProductCategoryProductsWhereUniqueInput
    /**
     * In case the PropertyUnitProductCategoryProducts found by the `where` argument doesn't exist, create a new PropertyUnitProductCategoryProducts with this data.
    **/
    create: XOR<PropertyUnitProductCategoryProductsCreateInput, PropertyUnitProductCategoryProductsUncheckedCreateInput>
    /**
     * In case the PropertyUnitProductCategoryProducts was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<PropertyUnitProductCategoryProductsUpdateInput, PropertyUnitProductCategoryProductsUncheckedUpdateInput>
  }


  /**
   * PropertyUnitProductCategoryProducts delete
   */
  export type PropertyUnitProductCategoryProductsDeleteArgs = {
    /**
     * Select specific fields to fetch from the PropertyUnitProductCategoryProducts
    **/
    select?: PropertyUnitProductCategoryProductsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PropertyUnitProductCategoryProductsInclude | null
    /**
     * Filter which PropertyUnitProductCategoryProducts to delete.
    **/
    where: PropertyUnitProductCategoryProductsWhereUniqueInput
  }


  /**
   * PropertyUnitProductCategoryProducts deleteMany
   */
  export type PropertyUnitProductCategoryProductsDeleteManyArgs = {
    where?: PropertyUnitProductCategoryProductsWhereInput
  }


  /**
   * PropertyUnitProductCategoryProducts without action
   */
  export type PropertyUnitProductCategoryProductsArgs = {
    /**
     * Select specific fields to fetch from the PropertyUnitProductCategoryProducts
    **/
    select?: PropertyUnitProductCategoryProductsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PropertyUnitProductCategoryProductsInclude | null
  }



  /**
   * Model PropertyUnits
   */


  export type AggregatePropertyUnits = {
    count: PropertyUnitsCountAggregateOutputType | null
    avg: PropertyUnitsAvgAggregateOutputType | null
    sum: PropertyUnitsSumAggregateOutputType | null
    min: PropertyUnitsMinAggregateOutputType | null
    max: PropertyUnitsMaxAggregateOutputType | null
  }

  export type PropertyUnitsAvgAggregateOutputType = {
    id: number
    created_by: number | null
    updated_by: number | null
  }

  export type PropertyUnitsSumAggregateOutputType = {
    id: number
    created_by: number | null
    updated_by: number | null
  }

  export type PropertyUnitsMinAggregateOutputType = {
    id: number
    name: string | null
    slug: string | null
    created_at: Date | null
    updated_at: Date | null
    created_by: number | null
    updated_by: number | null
  }

  export type PropertyUnitsMaxAggregateOutputType = {
    id: number
    name: string | null
    slug: string | null
    created_at: Date | null
    updated_at: Date | null
    created_by: number | null
    updated_by: number | null
  }

  export type PropertyUnitsCountAggregateOutputType = {
    id: number
    name: number | null
    slug: number | null
    created_at: number | null
    updated_at: number | null
    created_by: number | null
    updated_by: number | null
    _all: number
  }


  export type PropertyUnitsAvgAggregateInputType = {
    id?: true
    created_by?: true
    updated_by?: true
  }

  export type PropertyUnitsSumAggregateInputType = {
    id?: true
    created_by?: true
    updated_by?: true
  }

  export type PropertyUnitsMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type PropertyUnitsMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type PropertyUnitsCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
    _all?: true
  }

  export type PropertyUnitsAggregateArgs = {
    /**
     * Filter which PropertyUnits to aggregate.
    **/
    where?: PropertyUnitsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyUnits to fetch.
    **/
    orderBy?: Enumerable<PropertyUnitsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: PropertyUnitsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyUnits from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyUnits.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PropertyUnits
    **/
    count?: true | PropertyUnitsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: PropertyUnitsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: PropertyUnitsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: PropertyUnitsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: PropertyUnitsMaxAggregateInputType
  }

  export type GetPropertyUnitsAggregateType<T extends PropertyUnitsAggregateArgs> = {
    [P in keyof T & keyof AggregatePropertyUnits]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePropertyUnits[P]>
      : GetScalarType<T[P], AggregatePropertyUnits[P]>
  }



  export type PropertyUnitsSelect = {
    id?: boolean
    name?: boolean
    slug?: boolean
    created_at?: boolean
    updated_at?: boolean
    created_by?: boolean
    updated_by?: boolean
    ProductPropertyUnits?: boolean | ProductPropertyUnitsFindManyArgs
    PropertyUnitAttributes?: boolean | PropertyUnitAttributesFindManyArgs
    PropertyUnitProductCategories?: boolean | PropertyUnitProductCategoriesFindManyArgs
    UnitLocations?: boolean | UnitLocationsFindManyArgs
  }

  export type PropertyUnitsInclude = {
    ProductPropertyUnits?: boolean | ProductPropertyUnitsFindManyArgs
    PropertyUnitAttributes?: boolean | PropertyUnitAttributesFindManyArgs
    PropertyUnitProductCategories?: boolean | PropertyUnitProductCategoriesFindManyArgs
    UnitLocations?: boolean | UnitLocationsFindManyArgs
  }

  export type PropertyUnitsGetPayload<
    S extends boolean | null | undefined | PropertyUnitsArgs,
    U = keyof S
      > = S extends true
        ? PropertyUnits
    : S extends undefined
    ? never
    : S extends PropertyUnitsArgs | PropertyUnitsFindManyArgs
    ?'include' extends U
    ? PropertyUnits  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'ProductPropertyUnits'
        ? Array < ProductPropertyUnitsGetPayload<S['include'][P]>>  :
        P extends 'PropertyUnitAttributes'
        ? Array < PropertyUnitAttributesGetPayload<S['include'][P]>>  :
        P extends 'PropertyUnitProductCategories'
        ? Array < PropertyUnitProductCategoriesGetPayload<S['include'][P]>>  :
        P extends 'UnitLocations'
        ? Array < UnitLocationsGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof PropertyUnits ?PropertyUnits [P]
  : 
          P extends 'ProductPropertyUnits'
        ? Array < ProductPropertyUnitsGetPayload<S['select'][P]>>  :
        P extends 'PropertyUnitAttributes'
        ? Array < PropertyUnitAttributesGetPayload<S['select'][P]>>  :
        P extends 'PropertyUnitProductCategories'
        ? Array < PropertyUnitProductCategoriesGetPayload<S['select'][P]>>  :
        P extends 'UnitLocations'
        ? Array < UnitLocationsGetPayload<S['select'][P]>>  : never
  } 
    : PropertyUnits
  : PropertyUnits


  type PropertyUnitsCountArgs = Merge<
    Omit<PropertyUnitsFindManyArgs, 'select' | 'include'> & {
      select?: PropertyUnitsCountAggregateInputType | true
    }
  >

  export interface PropertyUnitsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one PropertyUnits that matches the filter.
     * @param {PropertyUnitsFindUniqueArgs} args - Arguments to find a PropertyUnits
     * @example
     * // Get one PropertyUnits
     * const propertyUnits = await prisma.propertyUnits.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PropertyUnitsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PropertyUnitsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PropertyUnits'> extends True ? CheckSelect<T, Prisma__PropertyUnitsClient<PropertyUnits>, Prisma__PropertyUnitsClient<PropertyUnitsGetPayload<T>>> : CheckSelect<T, Prisma__PropertyUnitsClient<PropertyUnits | null >, Prisma__PropertyUnitsClient<PropertyUnitsGetPayload<T> | null >>

    /**
     * Find the first PropertyUnits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyUnitsFindFirstArgs} args - Arguments to find a PropertyUnits
     * @example
     * // Get one PropertyUnits
     * const propertyUnits = await prisma.propertyUnits.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PropertyUnitsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PropertyUnitsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PropertyUnits'> extends True ? CheckSelect<T, Prisma__PropertyUnitsClient<PropertyUnits>, Prisma__PropertyUnitsClient<PropertyUnitsGetPayload<T>>> : CheckSelect<T, Prisma__PropertyUnitsClient<PropertyUnits | null >, Prisma__PropertyUnitsClient<PropertyUnitsGetPayload<T> | null >>

    /**
     * Find zero or more PropertyUnits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyUnitsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PropertyUnits
     * const propertyUnits = await prisma.propertyUnits.findMany()
     * 
     * // Get first 10 PropertyUnits
     * const propertyUnits = await prisma.propertyUnits.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertyUnitsWithIdOnly = await prisma.propertyUnits.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PropertyUnitsFindManyArgs>(
      args?: SelectSubset<T, PropertyUnitsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<PropertyUnits>>, PrismaPromise<Array<PropertyUnitsGetPayload<T>>>>

    /**
     * Create a PropertyUnits.
     * @param {PropertyUnitsCreateArgs} args - Arguments to create a PropertyUnits.
     * @example
     * // Create one PropertyUnits
     * const PropertyUnits = await prisma.propertyUnits.create({
     *   data: {
     *     // ... data to create a PropertyUnits
     *   }
     * })
     * 
    **/
    create<T extends PropertyUnitsCreateArgs>(
      args: SelectSubset<T, PropertyUnitsCreateArgs>
    ): CheckSelect<T, Prisma__PropertyUnitsClient<PropertyUnits>, Prisma__PropertyUnitsClient<PropertyUnitsGetPayload<T>>>

    /**
     * Delete a PropertyUnits.
     * @param {PropertyUnitsDeleteArgs} args - Arguments to delete one PropertyUnits.
     * @example
     * // Delete one PropertyUnits
     * const PropertyUnits = await prisma.propertyUnits.delete({
     *   where: {
     *     // ... filter to delete one PropertyUnits
     *   }
     * })
     * 
    **/
    delete<T extends PropertyUnitsDeleteArgs>(
      args: SelectSubset<T, PropertyUnitsDeleteArgs>
    ): CheckSelect<T, Prisma__PropertyUnitsClient<PropertyUnits>, Prisma__PropertyUnitsClient<PropertyUnitsGetPayload<T>>>

    /**
     * Update one PropertyUnits.
     * @param {PropertyUnitsUpdateArgs} args - Arguments to update one PropertyUnits.
     * @example
     * // Update one PropertyUnits
     * const propertyUnits = await prisma.propertyUnits.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PropertyUnitsUpdateArgs>(
      args: SelectSubset<T, PropertyUnitsUpdateArgs>
    ): CheckSelect<T, Prisma__PropertyUnitsClient<PropertyUnits>, Prisma__PropertyUnitsClient<PropertyUnitsGetPayload<T>>>

    /**
     * Delete zero or more PropertyUnits.
     * @param {PropertyUnitsDeleteManyArgs} args - Arguments to filter PropertyUnits to delete.
     * @example
     * // Delete a few PropertyUnits
     * const { count } = await prisma.propertyUnits.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PropertyUnitsDeleteManyArgs>(
      args?: SelectSubset<T, PropertyUnitsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyUnits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyUnitsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PropertyUnits
     * const propertyUnits = await prisma.propertyUnits.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PropertyUnitsUpdateManyArgs>(
      args: SelectSubset<T, PropertyUnitsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one PropertyUnits.
     * @param {PropertyUnitsUpsertArgs} args - Arguments to update or create a PropertyUnits.
     * @example
     * // Update or create a PropertyUnits
     * const propertyUnits = await prisma.propertyUnits.upsert({
     *   create: {
     *     // ... data to create a PropertyUnits
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PropertyUnits we want to update
     *   }
     * })
    **/
    upsert<T extends PropertyUnitsUpsertArgs>(
      args: SelectSubset<T, PropertyUnitsUpsertArgs>
    ): CheckSelect<T, Prisma__PropertyUnitsClient<PropertyUnits>, Prisma__PropertyUnitsClient<PropertyUnitsGetPayload<T>>>

    /**
     * Count the number of PropertyUnits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyUnitsCountArgs} args - Arguments to filter PropertyUnits to count.
     * @example
     * // Count the number of PropertyUnits
     * const count = await prisma.propertyUnits.count({
     *   where: {
     *     // ... the filter for the PropertyUnits we want to count
     *   }
     * })
    **/
    count<T extends PropertyUnitsCountArgs>(
      args?: Subset<T, PropertyUnitsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertyUnitsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PropertyUnits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyUnitsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertyUnitsAggregateArgs>(args: Subset<T, PropertyUnitsAggregateArgs>): PrismaPromise<GetPropertyUnitsAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for PropertyUnits.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PropertyUnitsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    ProductPropertyUnits<T extends ProductPropertyUnitsFindManyArgs = {}>(args?: Subset<T, ProductPropertyUnitsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ProductPropertyUnits>>, PrismaPromise<Array<ProductPropertyUnitsGetPayload<T>>>>;

    PropertyUnitAttributes<T extends PropertyUnitAttributesFindManyArgs = {}>(args?: Subset<T, PropertyUnitAttributesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<PropertyUnitAttributes>>, PrismaPromise<Array<PropertyUnitAttributesGetPayload<T>>>>;

    PropertyUnitProductCategories<T extends PropertyUnitProductCategoriesFindManyArgs = {}>(args?: Subset<T, PropertyUnitProductCategoriesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<PropertyUnitProductCategories>>, PrismaPromise<Array<PropertyUnitProductCategoriesGetPayload<T>>>>;

    UnitLocations<T extends UnitLocationsFindManyArgs = {}>(args?: Subset<T, UnitLocationsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<UnitLocations>>, PrismaPromise<Array<UnitLocationsGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * PropertyUnits findUnique
   */
  export type PropertyUnitsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the PropertyUnits
    **/
    select?: PropertyUnitsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PropertyUnitsInclude | null
    /**
     * Throw an Error if a PropertyUnits can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which PropertyUnits to fetch.
    **/
    where: PropertyUnitsWhereUniqueInput
  }


  /**
   * PropertyUnits findFirst
   */
  export type PropertyUnitsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the PropertyUnits
    **/
    select?: PropertyUnitsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PropertyUnitsInclude | null
    /**
     * Throw an Error if a PropertyUnits can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which PropertyUnits to fetch.
    **/
    where?: PropertyUnitsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyUnits to fetch.
    **/
    orderBy?: Enumerable<PropertyUnitsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyUnits.
    **/
    cursor?: PropertyUnitsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyUnits from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyUnits.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyUnits.
    **/
    distinct?: Enumerable<PropertyUnitsScalarFieldEnum>
  }


  /**
   * PropertyUnits findMany
   */
  export type PropertyUnitsFindManyArgs = {
    /**
     * Select specific fields to fetch from the PropertyUnits
    **/
    select?: PropertyUnitsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PropertyUnitsInclude | null
    /**
     * Filter, which PropertyUnits to fetch.
    **/
    where?: PropertyUnitsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyUnits to fetch.
    **/
    orderBy?: Enumerable<PropertyUnitsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PropertyUnits.
    **/
    cursor?: PropertyUnitsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyUnits from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyUnits.
    **/
    skip?: number
    distinct?: Enumerable<PropertyUnitsScalarFieldEnum>
  }


  /**
   * PropertyUnits create
   */
  export type PropertyUnitsCreateArgs = {
    /**
     * Select specific fields to fetch from the PropertyUnits
    **/
    select?: PropertyUnitsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PropertyUnitsInclude | null
    /**
     * The data needed to create a PropertyUnits.
    **/
    data: XOR<PropertyUnitsCreateInput, PropertyUnitsUncheckedCreateInput>
  }


  /**
   * PropertyUnits update
   */
  export type PropertyUnitsUpdateArgs = {
    /**
     * Select specific fields to fetch from the PropertyUnits
    **/
    select?: PropertyUnitsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PropertyUnitsInclude | null
    /**
     * The data needed to update a PropertyUnits.
    **/
    data: XOR<PropertyUnitsUpdateInput, PropertyUnitsUncheckedUpdateInput>
    /**
     * Choose, which PropertyUnits to update.
    **/
    where: PropertyUnitsWhereUniqueInput
  }


  /**
   * PropertyUnits updateMany
   */
  export type PropertyUnitsUpdateManyArgs = {
    data: XOR<PropertyUnitsUpdateManyMutationInput, PropertyUnitsUncheckedUpdateManyInput>
    where?: PropertyUnitsWhereInput
  }


  /**
   * PropertyUnits upsert
   */
  export type PropertyUnitsUpsertArgs = {
    /**
     * Select specific fields to fetch from the PropertyUnits
    **/
    select?: PropertyUnitsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PropertyUnitsInclude | null
    /**
     * The filter to search for the PropertyUnits to update in case it exists.
    **/
    where: PropertyUnitsWhereUniqueInput
    /**
     * In case the PropertyUnits found by the `where` argument doesn't exist, create a new PropertyUnits with this data.
    **/
    create: XOR<PropertyUnitsCreateInput, PropertyUnitsUncheckedCreateInput>
    /**
     * In case the PropertyUnits was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<PropertyUnitsUpdateInput, PropertyUnitsUncheckedUpdateInput>
  }


  /**
   * PropertyUnits delete
   */
  export type PropertyUnitsDeleteArgs = {
    /**
     * Select specific fields to fetch from the PropertyUnits
    **/
    select?: PropertyUnitsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PropertyUnitsInclude | null
    /**
     * Filter which PropertyUnits to delete.
    **/
    where: PropertyUnitsWhereUniqueInput
  }


  /**
   * PropertyUnits deleteMany
   */
  export type PropertyUnitsDeleteManyArgs = {
    where?: PropertyUnitsWhereInput
  }


  /**
   * PropertyUnits without action
   */
  export type PropertyUnitsArgs = {
    /**
     * Select specific fields to fetch from the PropertyUnits
    **/
    select?: PropertyUnitsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PropertyUnitsInclude | null
  }



  /**
   * Model Property_Addresses
   */


  export type AggregateProperty_Addresses = {
    count: Property_AddressesCountAggregateOutputType | null
    avg: Property_AddressesAvgAggregateOutputType | null
    sum: Property_AddressesSumAggregateOutputType | null
    min: Property_AddressesMinAggregateOutputType | null
    max: Property_AddressesMaxAggregateOutputType | null
  }

  export type Property_AddressesAvgAggregateOutputType = {
    id: number
    property_owner_id: number
    city_id: number
    property_sub_type_id: number
    storyId: number | null
    created_by: number | null
    updated_by: number | null
  }

  export type Property_AddressesSumAggregateOutputType = {
    id: number
    property_owner_id: number
    city_id: number
    property_sub_type_id: number
    storyId: number | null
    created_by: number | null
    updated_by: number | null
  }

  export type Property_AddressesMinAggregateOutputType = {
    id: number
    street: string | null
    property_owner_id: number
    city_id: number
    property_sub_type_id: number
    postal_code: string | null
    construction_type: string | null
    withBasement: boolean | null
    storyId: number | null
    created_at: Date | null
    updated_at: Date | null
    created_by: number | null
    updated_by: number | null
  }

  export type Property_AddressesMaxAggregateOutputType = {
    id: number
    street: string | null
    property_owner_id: number
    city_id: number
    property_sub_type_id: number
    postal_code: string | null
    construction_type: string | null
    withBasement: boolean | null
    storyId: number | null
    created_at: Date | null
    updated_at: Date | null
    created_by: number | null
    updated_by: number | null
  }

  export type Property_AddressesCountAggregateOutputType = {
    id: number
    street: number | null
    property_owner_id: number
    city_id: number
    property_sub_type_id: number
    postal_code: number | null
    construction_type: number | null
    withBasement: number | null
    storyId: number | null
    created_at: number | null
    updated_at: number | null
    created_by: number | null
    updated_by: number | null
    _all: number
  }


  export type Property_AddressesAvgAggregateInputType = {
    id?: true
    property_owner_id?: true
    city_id?: true
    property_sub_type_id?: true
    storyId?: true
    created_by?: true
    updated_by?: true
  }

  export type Property_AddressesSumAggregateInputType = {
    id?: true
    property_owner_id?: true
    city_id?: true
    property_sub_type_id?: true
    storyId?: true
    created_by?: true
    updated_by?: true
  }

  export type Property_AddressesMinAggregateInputType = {
    id?: true
    street?: true
    property_owner_id?: true
    city_id?: true
    property_sub_type_id?: true
    postal_code?: true
    construction_type?: true
    withBasement?: true
    storyId?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type Property_AddressesMaxAggregateInputType = {
    id?: true
    street?: true
    property_owner_id?: true
    city_id?: true
    property_sub_type_id?: true
    postal_code?: true
    construction_type?: true
    withBasement?: true
    storyId?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type Property_AddressesCountAggregateInputType = {
    id?: true
    street?: true
    property_owner_id?: true
    city_id?: true
    property_sub_type_id?: true
    postal_code?: true
    construction_type?: true
    withBasement?: true
    storyId?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
    _all?: true
  }

  export type Property_AddressesAggregateArgs = {
    /**
     * Filter which Property_Addresses to aggregate.
    **/
    where?: Property_AddressesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Property_Addresses to fetch.
    **/
    orderBy?: Enumerable<Property_AddressesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: Property_AddressesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Property_Addresses from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Property_Addresses.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Property_Addresses
    **/
    count?: true | Property_AddressesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: Property_AddressesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: Property_AddressesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: Property_AddressesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: Property_AddressesMaxAggregateInputType
  }

  export type GetProperty_AddressesAggregateType<T extends Property_AddressesAggregateArgs> = {
    [P in keyof T & keyof AggregateProperty_Addresses]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProperty_Addresses[P]>
      : GetScalarType<T[P], AggregateProperty_Addresses[P]>
  }



  export type Property_AddressesSelect = {
    id?: boolean
    street?: boolean
    property_owner_id?: boolean
    city_id?: boolean
    property_sub_type_id?: boolean
    postal_code?: boolean
    construction_type?: boolean
    withBasement?: boolean
    storyId?: boolean
    created_at?: boolean
    updated_at?: boolean
    created_by?: boolean
    updated_by?: boolean
    Cities?: boolean | CitiesArgs
    PropertyOwners?: boolean | PropertyOwnersArgs
    PropertySubTypes?: boolean | PropertySubTypesArgs
    Projects?: boolean | ProjectsFindManyArgs
  }

  export type Property_AddressesInclude = {
    Cities?: boolean | CitiesArgs
    PropertyOwners?: boolean | PropertyOwnersArgs
    PropertySubTypes?: boolean | PropertySubTypesArgs
    Projects?: boolean | ProjectsFindManyArgs
  }

  export type Property_AddressesGetPayload<
    S extends boolean | null | undefined | Property_AddressesArgs,
    U = keyof S
      > = S extends true
        ? Property_Addresses
    : S extends undefined
    ? never
    : S extends Property_AddressesArgs | Property_AddressesFindManyArgs
    ?'include' extends U
    ? Property_Addresses  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'Cities'
        ? CitiesGetPayload<S['include'][P]> :
        P extends 'PropertyOwners'
        ? PropertyOwnersGetPayload<S['include'][P]> :
        P extends 'PropertySubTypes'
        ? PropertySubTypesGetPayload<S['include'][P]> :
        P extends 'Projects'
        ? Array < ProjectsGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Property_Addresses ?Property_Addresses [P]
  : 
          P extends 'Cities'
        ? CitiesGetPayload<S['select'][P]> :
        P extends 'PropertyOwners'
        ? PropertyOwnersGetPayload<S['select'][P]> :
        P extends 'PropertySubTypes'
        ? PropertySubTypesGetPayload<S['select'][P]> :
        P extends 'Projects'
        ? Array < ProjectsGetPayload<S['select'][P]>>  : never
  } 
    : Property_Addresses
  : Property_Addresses


  type Property_AddressesCountArgs = Merge<
    Omit<Property_AddressesFindManyArgs, 'select' | 'include'> & {
      select?: Property_AddressesCountAggregateInputType | true
    }
  >

  export interface Property_AddressesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Property_Addresses that matches the filter.
     * @param {Property_AddressesFindUniqueArgs} args - Arguments to find a Property_Addresses
     * @example
     * // Get one Property_Addresses
     * const property_Addresses = await prisma.property_Addresses.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends Property_AddressesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, Property_AddressesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Property_Addresses'> extends True ? CheckSelect<T, Prisma__Property_AddressesClient<Property_Addresses>, Prisma__Property_AddressesClient<Property_AddressesGetPayload<T>>> : CheckSelect<T, Prisma__Property_AddressesClient<Property_Addresses | null >, Prisma__Property_AddressesClient<Property_AddressesGetPayload<T> | null >>

    /**
     * Find the first Property_Addresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Property_AddressesFindFirstArgs} args - Arguments to find a Property_Addresses
     * @example
     * // Get one Property_Addresses
     * const property_Addresses = await prisma.property_Addresses.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends Property_AddressesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, Property_AddressesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Property_Addresses'> extends True ? CheckSelect<T, Prisma__Property_AddressesClient<Property_Addresses>, Prisma__Property_AddressesClient<Property_AddressesGetPayload<T>>> : CheckSelect<T, Prisma__Property_AddressesClient<Property_Addresses | null >, Prisma__Property_AddressesClient<Property_AddressesGetPayload<T> | null >>

    /**
     * Find zero or more Property_Addresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Property_AddressesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Property_Addresses
     * const property_Addresses = await prisma.property_Addresses.findMany()
     * 
     * // Get first 10 Property_Addresses
     * const property_Addresses = await prisma.property_Addresses.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const property_AddressesWithIdOnly = await prisma.property_Addresses.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends Property_AddressesFindManyArgs>(
      args?: SelectSubset<T, Property_AddressesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Property_Addresses>>, PrismaPromise<Array<Property_AddressesGetPayload<T>>>>

    /**
     * Create a Property_Addresses.
     * @param {Property_AddressesCreateArgs} args - Arguments to create a Property_Addresses.
     * @example
     * // Create one Property_Addresses
     * const Property_Addresses = await prisma.property_Addresses.create({
     *   data: {
     *     // ... data to create a Property_Addresses
     *   }
     * })
     * 
    **/
    create<T extends Property_AddressesCreateArgs>(
      args: SelectSubset<T, Property_AddressesCreateArgs>
    ): CheckSelect<T, Prisma__Property_AddressesClient<Property_Addresses>, Prisma__Property_AddressesClient<Property_AddressesGetPayload<T>>>

    /**
     * Delete a Property_Addresses.
     * @param {Property_AddressesDeleteArgs} args - Arguments to delete one Property_Addresses.
     * @example
     * // Delete one Property_Addresses
     * const Property_Addresses = await prisma.property_Addresses.delete({
     *   where: {
     *     // ... filter to delete one Property_Addresses
     *   }
     * })
     * 
    **/
    delete<T extends Property_AddressesDeleteArgs>(
      args: SelectSubset<T, Property_AddressesDeleteArgs>
    ): CheckSelect<T, Prisma__Property_AddressesClient<Property_Addresses>, Prisma__Property_AddressesClient<Property_AddressesGetPayload<T>>>

    /**
     * Update one Property_Addresses.
     * @param {Property_AddressesUpdateArgs} args - Arguments to update one Property_Addresses.
     * @example
     * // Update one Property_Addresses
     * const property_Addresses = await prisma.property_Addresses.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends Property_AddressesUpdateArgs>(
      args: SelectSubset<T, Property_AddressesUpdateArgs>
    ): CheckSelect<T, Prisma__Property_AddressesClient<Property_Addresses>, Prisma__Property_AddressesClient<Property_AddressesGetPayload<T>>>

    /**
     * Delete zero or more Property_Addresses.
     * @param {Property_AddressesDeleteManyArgs} args - Arguments to filter Property_Addresses to delete.
     * @example
     * // Delete a few Property_Addresses
     * const { count } = await prisma.property_Addresses.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends Property_AddressesDeleteManyArgs>(
      args?: SelectSubset<T, Property_AddressesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Property_Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Property_AddressesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Property_Addresses
     * const property_Addresses = await prisma.property_Addresses.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends Property_AddressesUpdateManyArgs>(
      args: SelectSubset<T, Property_AddressesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Property_Addresses.
     * @param {Property_AddressesUpsertArgs} args - Arguments to update or create a Property_Addresses.
     * @example
     * // Update or create a Property_Addresses
     * const property_Addresses = await prisma.property_Addresses.upsert({
     *   create: {
     *     // ... data to create a Property_Addresses
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Property_Addresses we want to update
     *   }
     * })
    **/
    upsert<T extends Property_AddressesUpsertArgs>(
      args: SelectSubset<T, Property_AddressesUpsertArgs>
    ): CheckSelect<T, Prisma__Property_AddressesClient<Property_Addresses>, Prisma__Property_AddressesClient<Property_AddressesGetPayload<T>>>

    /**
     * Count the number of Property_Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Property_AddressesCountArgs} args - Arguments to filter Property_Addresses to count.
     * @example
     * // Count the number of Property_Addresses
     * const count = await prisma.property_Addresses.count({
     *   where: {
     *     // ... the filter for the Property_Addresses we want to count
     *   }
     * })
    **/
    count<T extends Property_AddressesCountArgs>(
      args?: Subset<T, Property_AddressesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Property_AddressesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Property_Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Property_AddressesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Property_AddressesAggregateArgs>(args: Subset<T, Property_AddressesAggregateArgs>): PrismaPromise<GetProperty_AddressesAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for Property_Addresses.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__Property_AddressesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Cities<T extends CitiesArgs = {}>(args?: Subset<T, CitiesArgs>): CheckSelect<T, Prisma__CitiesClient<Cities | null >, Prisma__CitiesClient<CitiesGetPayload<T> | null >>;

    PropertyOwners<T extends PropertyOwnersArgs = {}>(args?: Subset<T, PropertyOwnersArgs>): CheckSelect<T, Prisma__PropertyOwnersClient<PropertyOwners | null >, Prisma__PropertyOwnersClient<PropertyOwnersGetPayload<T> | null >>;

    PropertySubTypes<T extends PropertySubTypesArgs = {}>(args?: Subset<T, PropertySubTypesArgs>): CheckSelect<T, Prisma__PropertySubTypesClient<PropertySubTypes | null >, Prisma__PropertySubTypesClient<PropertySubTypesGetPayload<T> | null >>;

    Projects<T extends ProjectsFindManyArgs = {}>(args?: Subset<T, ProjectsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Projects>>, PrismaPromise<Array<ProjectsGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Property_Addresses findUnique
   */
  export type Property_AddressesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Property_Addresses
    **/
    select?: Property_AddressesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: Property_AddressesInclude | null
    /**
     * Throw an Error if a Property_Addresses can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Property_Addresses to fetch.
    **/
    where: Property_AddressesWhereUniqueInput
  }


  /**
   * Property_Addresses findFirst
   */
  export type Property_AddressesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Property_Addresses
    **/
    select?: Property_AddressesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: Property_AddressesInclude | null
    /**
     * Throw an Error if a Property_Addresses can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Property_Addresses to fetch.
    **/
    where?: Property_AddressesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Property_Addresses to fetch.
    **/
    orderBy?: Enumerable<Property_AddressesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Property_Addresses.
    **/
    cursor?: Property_AddressesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Property_Addresses from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Property_Addresses.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Property_Addresses.
    **/
    distinct?: Enumerable<Property_AddressesScalarFieldEnum>
  }


  /**
   * Property_Addresses findMany
   */
  export type Property_AddressesFindManyArgs = {
    /**
     * Select specific fields to fetch from the Property_Addresses
    **/
    select?: Property_AddressesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: Property_AddressesInclude | null
    /**
     * Filter, which Property_Addresses to fetch.
    **/
    where?: Property_AddressesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Property_Addresses to fetch.
    **/
    orderBy?: Enumerable<Property_AddressesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Property_Addresses.
    **/
    cursor?: Property_AddressesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Property_Addresses from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Property_Addresses.
    **/
    skip?: number
    distinct?: Enumerable<Property_AddressesScalarFieldEnum>
  }


  /**
   * Property_Addresses create
   */
  export type Property_AddressesCreateArgs = {
    /**
     * Select specific fields to fetch from the Property_Addresses
    **/
    select?: Property_AddressesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: Property_AddressesInclude | null
    /**
     * The data needed to create a Property_Addresses.
    **/
    data: XOR<Property_AddressesCreateInput, Property_AddressesUncheckedCreateInput>
  }


  /**
   * Property_Addresses update
   */
  export type Property_AddressesUpdateArgs = {
    /**
     * Select specific fields to fetch from the Property_Addresses
    **/
    select?: Property_AddressesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: Property_AddressesInclude | null
    /**
     * The data needed to update a Property_Addresses.
    **/
    data: XOR<Property_AddressesUpdateInput, Property_AddressesUncheckedUpdateInput>
    /**
     * Choose, which Property_Addresses to update.
    **/
    where: Property_AddressesWhereUniqueInput
  }


  /**
   * Property_Addresses updateMany
   */
  export type Property_AddressesUpdateManyArgs = {
    data: XOR<Property_AddressesUpdateManyMutationInput, Property_AddressesUncheckedUpdateManyInput>
    where?: Property_AddressesWhereInput
  }


  /**
   * Property_Addresses upsert
   */
  export type Property_AddressesUpsertArgs = {
    /**
     * Select specific fields to fetch from the Property_Addresses
    **/
    select?: Property_AddressesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: Property_AddressesInclude | null
    /**
     * The filter to search for the Property_Addresses to update in case it exists.
    **/
    where: Property_AddressesWhereUniqueInput
    /**
     * In case the Property_Addresses found by the `where` argument doesn't exist, create a new Property_Addresses with this data.
    **/
    create: XOR<Property_AddressesCreateInput, Property_AddressesUncheckedCreateInput>
    /**
     * In case the Property_Addresses was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<Property_AddressesUpdateInput, Property_AddressesUncheckedUpdateInput>
  }


  /**
   * Property_Addresses delete
   */
  export type Property_AddressesDeleteArgs = {
    /**
     * Select specific fields to fetch from the Property_Addresses
    **/
    select?: Property_AddressesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: Property_AddressesInclude | null
    /**
     * Filter which Property_Addresses to delete.
    **/
    where: Property_AddressesWhereUniqueInput
  }


  /**
   * Property_Addresses deleteMany
   */
  export type Property_AddressesDeleteManyArgs = {
    where?: Property_AddressesWhereInput
  }


  /**
   * Property_Addresses without action
   */
  export type Property_AddressesArgs = {
    /**
     * Select specific fields to fetch from the Property_Addresses
    **/
    select?: Property_AddressesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: Property_AddressesInclude | null
  }



  /**
   * Model Property_Types
   */


  export type AggregateProperty_Types = {
    count: Property_TypesCountAggregateOutputType | null
    avg: Property_TypesAvgAggregateOutputType | null
    sum: Property_TypesSumAggregateOutputType | null
    min: Property_TypesMinAggregateOutputType | null
    max: Property_TypesMaxAggregateOutputType | null
  }

  export type Property_TypesAvgAggregateOutputType = {
    id: number
    created_by: number | null
    updated_by: number | null
  }

  export type Property_TypesSumAggregateOutputType = {
    id: number
    created_by: number | null
    updated_by: number | null
  }

  export type Property_TypesMinAggregateOutputType = {
    id: number
    name: string | null
    slug: string | null
    created_at: Date | null
    updated_at: Date | null
    created_by: number | null
    updated_by: number | null
  }

  export type Property_TypesMaxAggregateOutputType = {
    id: number
    name: string | null
    slug: string | null
    created_at: Date | null
    updated_at: Date | null
    created_by: number | null
    updated_by: number | null
  }

  export type Property_TypesCountAggregateOutputType = {
    id: number
    name: number | null
    slug: number | null
    created_at: number | null
    updated_at: number | null
    created_by: number | null
    updated_by: number | null
    _all: number
  }


  export type Property_TypesAvgAggregateInputType = {
    id?: true
    created_by?: true
    updated_by?: true
  }

  export type Property_TypesSumAggregateInputType = {
    id?: true
    created_by?: true
    updated_by?: true
  }

  export type Property_TypesMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type Property_TypesMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type Property_TypesCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
    _all?: true
  }

  export type Property_TypesAggregateArgs = {
    /**
     * Filter which Property_Types to aggregate.
    **/
    where?: Property_TypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Property_Types to fetch.
    **/
    orderBy?: Enumerable<Property_TypesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: Property_TypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Property_Types from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Property_Types.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Property_Types
    **/
    count?: true | Property_TypesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: Property_TypesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: Property_TypesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: Property_TypesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: Property_TypesMaxAggregateInputType
  }

  export type GetProperty_TypesAggregateType<T extends Property_TypesAggregateArgs> = {
    [P in keyof T & keyof AggregateProperty_Types]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProperty_Types[P]>
      : GetScalarType<T[P], AggregateProperty_Types[P]>
  }



  export type Property_TypesSelect = {
    id?: boolean
    name?: boolean
    slug?: boolean
    created_at?: boolean
    updated_at?: boolean
    created_by?: boolean
    updated_by?: boolean
    PropertySubTypes?: boolean | PropertySubTypesFindManyArgs
  }

  export type Property_TypesInclude = {
    PropertySubTypes?: boolean | PropertySubTypesFindManyArgs
  }

  export type Property_TypesGetPayload<
    S extends boolean | null | undefined | Property_TypesArgs,
    U = keyof S
      > = S extends true
        ? Property_Types
    : S extends undefined
    ? never
    : S extends Property_TypesArgs | Property_TypesFindManyArgs
    ?'include' extends U
    ? Property_Types  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'PropertySubTypes'
        ? Array < PropertySubTypesGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Property_Types ?Property_Types [P]
  : 
          P extends 'PropertySubTypes'
        ? Array < PropertySubTypesGetPayload<S['select'][P]>>  : never
  } 
    : Property_Types
  : Property_Types


  type Property_TypesCountArgs = Merge<
    Omit<Property_TypesFindManyArgs, 'select' | 'include'> & {
      select?: Property_TypesCountAggregateInputType | true
    }
  >

  export interface Property_TypesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Property_Types that matches the filter.
     * @param {Property_TypesFindUniqueArgs} args - Arguments to find a Property_Types
     * @example
     * // Get one Property_Types
     * const property_Types = await prisma.property_Types.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends Property_TypesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, Property_TypesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Property_Types'> extends True ? CheckSelect<T, Prisma__Property_TypesClient<Property_Types>, Prisma__Property_TypesClient<Property_TypesGetPayload<T>>> : CheckSelect<T, Prisma__Property_TypesClient<Property_Types | null >, Prisma__Property_TypesClient<Property_TypesGetPayload<T> | null >>

    /**
     * Find the first Property_Types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Property_TypesFindFirstArgs} args - Arguments to find a Property_Types
     * @example
     * // Get one Property_Types
     * const property_Types = await prisma.property_Types.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends Property_TypesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, Property_TypesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Property_Types'> extends True ? CheckSelect<T, Prisma__Property_TypesClient<Property_Types>, Prisma__Property_TypesClient<Property_TypesGetPayload<T>>> : CheckSelect<T, Prisma__Property_TypesClient<Property_Types | null >, Prisma__Property_TypesClient<Property_TypesGetPayload<T> | null >>

    /**
     * Find zero or more Property_Types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Property_TypesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Property_Types
     * const property_Types = await prisma.property_Types.findMany()
     * 
     * // Get first 10 Property_Types
     * const property_Types = await prisma.property_Types.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const property_TypesWithIdOnly = await prisma.property_Types.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends Property_TypesFindManyArgs>(
      args?: SelectSubset<T, Property_TypesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Property_Types>>, PrismaPromise<Array<Property_TypesGetPayload<T>>>>

    /**
     * Create a Property_Types.
     * @param {Property_TypesCreateArgs} args - Arguments to create a Property_Types.
     * @example
     * // Create one Property_Types
     * const Property_Types = await prisma.property_Types.create({
     *   data: {
     *     // ... data to create a Property_Types
     *   }
     * })
     * 
    **/
    create<T extends Property_TypesCreateArgs>(
      args: SelectSubset<T, Property_TypesCreateArgs>
    ): CheckSelect<T, Prisma__Property_TypesClient<Property_Types>, Prisma__Property_TypesClient<Property_TypesGetPayload<T>>>

    /**
     * Delete a Property_Types.
     * @param {Property_TypesDeleteArgs} args - Arguments to delete one Property_Types.
     * @example
     * // Delete one Property_Types
     * const Property_Types = await prisma.property_Types.delete({
     *   where: {
     *     // ... filter to delete one Property_Types
     *   }
     * })
     * 
    **/
    delete<T extends Property_TypesDeleteArgs>(
      args: SelectSubset<T, Property_TypesDeleteArgs>
    ): CheckSelect<T, Prisma__Property_TypesClient<Property_Types>, Prisma__Property_TypesClient<Property_TypesGetPayload<T>>>

    /**
     * Update one Property_Types.
     * @param {Property_TypesUpdateArgs} args - Arguments to update one Property_Types.
     * @example
     * // Update one Property_Types
     * const property_Types = await prisma.property_Types.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends Property_TypesUpdateArgs>(
      args: SelectSubset<T, Property_TypesUpdateArgs>
    ): CheckSelect<T, Prisma__Property_TypesClient<Property_Types>, Prisma__Property_TypesClient<Property_TypesGetPayload<T>>>

    /**
     * Delete zero or more Property_Types.
     * @param {Property_TypesDeleteManyArgs} args - Arguments to filter Property_Types to delete.
     * @example
     * // Delete a few Property_Types
     * const { count } = await prisma.property_Types.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends Property_TypesDeleteManyArgs>(
      args?: SelectSubset<T, Property_TypesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Property_Types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Property_TypesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Property_Types
     * const property_Types = await prisma.property_Types.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends Property_TypesUpdateManyArgs>(
      args: SelectSubset<T, Property_TypesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Property_Types.
     * @param {Property_TypesUpsertArgs} args - Arguments to update or create a Property_Types.
     * @example
     * // Update or create a Property_Types
     * const property_Types = await prisma.property_Types.upsert({
     *   create: {
     *     // ... data to create a Property_Types
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Property_Types we want to update
     *   }
     * })
    **/
    upsert<T extends Property_TypesUpsertArgs>(
      args: SelectSubset<T, Property_TypesUpsertArgs>
    ): CheckSelect<T, Prisma__Property_TypesClient<Property_Types>, Prisma__Property_TypesClient<Property_TypesGetPayload<T>>>

    /**
     * Count the number of Property_Types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Property_TypesCountArgs} args - Arguments to filter Property_Types to count.
     * @example
     * // Count the number of Property_Types
     * const count = await prisma.property_Types.count({
     *   where: {
     *     // ... the filter for the Property_Types we want to count
     *   }
     * })
    **/
    count<T extends Property_TypesCountArgs>(
      args?: Subset<T, Property_TypesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Property_TypesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Property_Types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Property_TypesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Property_TypesAggregateArgs>(args: Subset<T, Property_TypesAggregateArgs>): PrismaPromise<GetProperty_TypesAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for Property_Types.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__Property_TypesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    PropertySubTypes<T extends PropertySubTypesFindManyArgs = {}>(args?: Subset<T, PropertySubTypesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<PropertySubTypes>>, PrismaPromise<Array<PropertySubTypesGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Property_Types findUnique
   */
  export type Property_TypesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Property_Types
    **/
    select?: Property_TypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: Property_TypesInclude | null
    /**
     * Throw an Error if a Property_Types can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Property_Types to fetch.
    **/
    where: Property_TypesWhereUniqueInput
  }


  /**
   * Property_Types findFirst
   */
  export type Property_TypesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Property_Types
    **/
    select?: Property_TypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: Property_TypesInclude | null
    /**
     * Throw an Error if a Property_Types can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Property_Types to fetch.
    **/
    where?: Property_TypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Property_Types to fetch.
    **/
    orderBy?: Enumerable<Property_TypesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Property_Types.
    **/
    cursor?: Property_TypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Property_Types from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Property_Types.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Property_Types.
    **/
    distinct?: Enumerable<Property_TypesScalarFieldEnum>
  }


  /**
   * Property_Types findMany
   */
  export type Property_TypesFindManyArgs = {
    /**
     * Select specific fields to fetch from the Property_Types
    **/
    select?: Property_TypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: Property_TypesInclude | null
    /**
     * Filter, which Property_Types to fetch.
    **/
    where?: Property_TypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Property_Types to fetch.
    **/
    orderBy?: Enumerable<Property_TypesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Property_Types.
    **/
    cursor?: Property_TypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Property_Types from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Property_Types.
    **/
    skip?: number
    distinct?: Enumerable<Property_TypesScalarFieldEnum>
  }


  /**
   * Property_Types create
   */
  export type Property_TypesCreateArgs = {
    /**
     * Select specific fields to fetch from the Property_Types
    **/
    select?: Property_TypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: Property_TypesInclude | null
    /**
     * The data needed to create a Property_Types.
    **/
    data: XOR<Property_TypesCreateInput, Property_TypesUncheckedCreateInput>
  }


  /**
   * Property_Types update
   */
  export type Property_TypesUpdateArgs = {
    /**
     * Select specific fields to fetch from the Property_Types
    **/
    select?: Property_TypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: Property_TypesInclude | null
    /**
     * The data needed to update a Property_Types.
    **/
    data: XOR<Property_TypesUpdateInput, Property_TypesUncheckedUpdateInput>
    /**
     * Choose, which Property_Types to update.
    **/
    where: Property_TypesWhereUniqueInput
  }


  /**
   * Property_Types updateMany
   */
  export type Property_TypesUpdateManyArgs = {
    data: XOR<Property_TypesUpdateManyMutationInput, Property_TypesUncheckedUpdateManyInput>
    where?: Property_TypesWhereInput
  }


  /**
   * Property_Types upsert
   */
  export type Property_TypesUpsertArgs = {
    /**
     * Select specific fields to fetch from the Property_Types
    **/
    select?: Property_TypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: Property_TypesInclude | null
    /**
     * The filter to search for the Property_Types to update in case it exists.
    **/
    where: Property_TypesWhereUniqueInput
    /**
     * In case the Property_Types found by the `where` argument doesn't exist, create a new Property_Types with this data.
    **/
    create: XOR<Property_TypesCreateInput, Property_TypesUncheckedCreateInput>
    /**
     * In case the Property_Types was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<Property_TypesUpdateInput, Property_TypesUncheckedUpdateInput>
  }


  /**
   * Property_Types delete
   */
  export type Property_TypesDeleteArgs = {
    /**
     * Select specific fields to fetch from the Property_Types
    **/
    select?: Property_TypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: Property_TypesInclude | null
    /**
     * Filter which Property_Types to delete.
    **/
    where: Property_TypesWhereUniqueInput
  }


  /**
   * Property_Types deleteMany
   */
  export type Property_TypesDeleteManyArgs = {
    where?: Property_TypesWhereInput
  }


  /**
   * Property_Types without action
   */
  export type Property_TypesArgs = {
    /**
     * Select specific fields to fetch from the Property_Types
    **/
    select?: Property_TypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: Property_TypesInclude | null
  }



  /**
   * Model ScopeOfWorkPropertyUnits
   */


  export type AggregateScopeOfWorkPropertyUnits = {
    count: ScopeOfWorkPropertyUnitsCountAggregateOutputType | null
    avg: ScopeOfWorkPropertyUnitsAvgAggregateOutputType | null
    sum: ScopeOfWorkPropertyUnitsSumAggregateOutputType | null
    min: ScopeOfWorkPropertyUnitsMinAggregateOutputType | null
    max: ScopeOfWorkPropertyUnitsMaxAggregateOutputType | null
  }

  export type ScopeOfWorkPropertyUnitsAvgAggregateOutputType = {
    id: number
    project_proposal_id: number
    area_of_work_id: number
    property_unit_attribute_id: number
    created_by: number | null
    updated_by: number | null
  }

  export type ScopeOfWorkPropertyUnitsSumAggregateOutputType = {
    id: number
    project_proposal_id: number
    area_of_work_id: number
    property_unit_attribute_id: number
    created_by: number | null
    updated_by: number | null
  }

  export type ScopeOfWorkPropertyUnitsMinAggregateOutputType = {
    id: number
    project_proposal_id: number
    area_of_work_id: number
    property_unit_attribute_id: number
    value: string | null
    attribute_custom_name: string | null
    attribute_custom_value: string | null
    attribute_custom_unit: string | null
    created_at: Date | null
    updated_at: Date | null
    created_by: number | null
    updated_by: number | null
  }

  export type ScopeOfWorkPropertyUnitsMaxAggregateOutputType = {
    id: number
    project_proposal_id: number
    area_of_work_id: number
    property_unit_attribute_id: number
    value: string | null
    attribute_custom_name: string | null
    attribute_custom_value: string | null
    attribute_custom_unit: string | null
    created_at: Date | null
    updated_at: Date | null
    created_by: number | null
    updated_by: number | null
  }

  export type ScopeOfWorkPropertyUnitsCountAggregateOutputType = {
    id: number
    project_proposal_id: number
    area_of_work_id: number
    property_unit_attribute_id: number
    value: number | null
    attribute_custom_name: number | null
    attribute_custom_value: number | null
    attribute_custom_unit: number | null
    created_at: number | null
    updated_at: number | null
    created_by: number | null
    updated_by: number | null
    _all: number
  }


  export type ScopeOfWorkPropertyUnitsAvgAggregateInputType = {
    id?: true
    project_proposal_id?: true
    area_of_work_id?: true
    property_unit_attribute_id?: true
    created_by?: true
    updated_by?: true
  }

  export type ScopeOfWorkPropertyUnitsSumAggregateInputType = {
    id?: true
    project_proposal_id?: true
    area_of_work_id?: true
    property_unit_attribute_id?: true
    created_by?: true
    updated_by?: true
  }

  export type ScopeOfWorkPropertyUnitsMinAggregateInputType = {
    id?: true
    project_proposal_id?: true
    area_of_work_id?: true
    property_unit_attribute_id?: true
    value?: true
    attribute_custom_name?: true
    attribute_custom_value?: true
    attribute_custom_unit?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type ScopeOfWorkPropertyUnitsMaxAggregateInputType = {
    id?: true
    project_proposal_id?: true
    area_of_work_id?: true
    property_unit_attribute_id?: true
    value?: true
    attribute_custom_name?: true
    attribute_custom_value?: true
    attribute_custom_unit?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type ScopeOfWorkPropertyUnitsCountAggregateInputType = {
    id?: true
    project_proposal_id?: true
    area_of_work_id?: true
    property_unit_attribute_id?: true
    value?: true
    attribute_custom_name?: true
    attribute_custom_value?: true
    attribute_custom_unit?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
    _all?: true
  }

  export type ScopeOfWorkPropertyUnitsAggregateArgs = {
    /**
     * Filter which ScopeOfWorkPropertyUnits to aggregate.
    **/
    where?: ScopeOfWorkPropertyUnitsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScopeOfWorkPropertyUnits to fetch.
    **/
    orderBy?: Enumerable<ScopeOfWorkPropertyUnitsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: ScopeOfWorkPropertyUnitsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScopeOfWorkPropertyUnits from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScopeOfWorkPropertyUnits.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ScopeOfWorkPropertyUnits
    **/
    count?: true | ScopeOfWorkPropertyUnitsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: ScopeOfWorkPropertyUnitsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: ScopeOfWorkPropertyUnitsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: ScopeOfWorkPropertyUnitsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: ScopeOfWorkPropertyUnitsMaxAggregateInputType
  }

  export type GetScopeOfWorkPropertyUnitsAggregateType<T extends ScopeOfWorkPropertyUnitsAggregateArgs> = {
    [P in keyof T & keyof AggregateScopeOfWorkPropertyUnits]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScopeOfWorkPropertyUnits[P]>
      : GetScalarType<T[P], AggregateScopeOfWorkPropertyUnits[P]>
  }



  export type ScopeOfWorkPropertyUnitsSelect = {
    id?: boolean
    project_proposal_id?: boolean
    area_of_work_id?: boolean
    property_unit_attribute_id?: boolean
    value?: boolean
    attribute_custom_name?: boolean
    attribute_custom_value?: boolean
    attribute_custom_unit?: boolean
    created_at?: boolean
    updated_at?: boolean
    created_by?: boolean
    updated_by?: boolean
    AreaOfWorks?: boolean | AreaOfWorksArgs
    ProjectProposals?: boolean | ProjectProposalsArgs
    PropertyUnitAttributes?: boolean | PropertyUnitAttributesArgs
  }

  export type ScopeOfWorkPropertyUnitsInclude = {
    AreaOfWorks?: boolean | AreaOfWorksArgs
    ProjectProposals?: boolean | ProjectProposalsArgs
    PropertyUnitAttributes?: boolean | PropertyUnitAttributesArgs
  }

  export type ScopeOfWorkPropertyUnitsGetPayload<
    S extends boolean | null | undefined | ScopeOfWorkPropertyUnitsArgs,
    U = keyof S
      > = S extends true
        ? ScopeOfWorkPropertyUnits
    : S extends undefined
    ? never
    : S extends ScopeOfWorkPropertyUnitsArgs | ScopeOfWorkPropertyUnitsFindManyArgs
    ?'include' extends U
    ? ScopeOfWorkPropertyUnits  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'AreaOfWorks'
        ? AreaOfWorksGetPayload<S['include'][P]> :
        P extends 'ProjectProposals'
        ? ProjectProposalsGetPayload<S['include'][P]> :
        P extends 'PropertyUnitAttributes'
        ? PropertyUnitAttributesGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof ScopeOfWorkPropertyUnits ?ScopeOfWorkPropertyUnits [P]
  : 
          P extends 'AreaOfWorks'
        ? AreaOfWorksGetPayload<S['select'][P]> :
        P extends 'ProjectProposals'
        ? ProjectProposalsGetPayload<S['select'][P]> :
        P extends 'PropertyUnitAttributes'
        ? PropertyUnitAttributesGetPayload<S['select'][P]> : never
  } 
    : ScopeOfWorkPropertyUnits
  : ScopeOfWorkPropertyUnits


  type ScopeOfWorkPropertyUnitsCountArgs = Merge<
    Omit<ScopeOfWorkPropertyUnitsFindManyArgs, 'select' | 'include'> & {
      select?: ScopeOfWorkPropertyUnitsCountAggregateInputType | true
    }
  >

  export interface ScopeOfWorkPropertyUnitsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one ScopeOfWorkPropertyUnits that matches the filter.
     * @param {ScopeOfWorkPropertyUnitsFindUniqueArgs} args - Arguments to find a ScopeOfWorkPropertyUnits
     * @example
     * // Get one ScopeOfWorkPropertyUnits
     * const scopeOfWorkPropertyUnits = await prisma.scopeOfWorkPropertyUnits.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ScopeOfWorkPropertyUnitsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ScopeOfWorkPropertyUnitsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ScopeOfWorkPropertyUnits'> extends True ? CheckSelect<T, Prisma__ScopeOfWorkPropertyUnitsClient<ScopeOfWorkPropertyUnits>, Prisma__ScopeOfWorkPropertyUnitsClient<ScopeOfWorkPropertyUnitsGetPayload<T>>> : CheckSelect<T, Prisma__ScopeOfWorkPropertyUnitsClient<ScopeOfWorkPropertyUnits | null >, Prisma__ScopeOfWorkPropertyUnitsClient<ScopeOfWorkPropertyUnitsGetPayload<T> | null >>

    /**
     * Find the first ScopeOfWorkPropertyUnits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScopeOfWorkPropertyUnitsFindFirstArgs} args - Arguments to find a ScopeOfWorkPropertyUnits
     * @example
     * // Get one ScopeOfWorkPropertyUnits
     * const scopeOfWorkPropertyUnits = await prisma.scopeOfWorkPropertyUnits.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ScopeOfWorkPropertyUnitsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ScopeOfWorkPropertyUnitsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ScopeOfWorkPropertyUnits'> extends True ? CheckSelect<T, Prisma__ScopeOfWorkPropertyUnitsClient<ScopeOfWorkPropertyUnits>, Prisma__ScopeOfWorkPropertyUnitsClient<ScopeOfWorkPropertyUnitsGetPayload<T>>> : CheckSelect<T, Prisma__ScopeOfWorkPropertyUnitsClient<ScopeOfWorkPropertyUnits | null >, Prisma__ScopeOfWorkPropertyUnitsClient<ScopeOfWorkPropertyUnitsGetPayload<T> | null >>

    /**
     * Find zero or more ScopeOfWorkPropertyUnits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScopeOfWorkPropertyUnitsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ScopeOfWorkPropertyUnits
     * const scopeOfWorkPropertyUnits = await prisma.scopeOfWorkPropertyUnits.findMany()
     * 
     * // Get first 10 ScopeOfWorkPropertyUnits
     * const scopeOfWorkPropertyUnits = await prisma.scopeOfWorkPropertyUnits.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const scopeOfWorkPropertyUnitsWithIdOnly = await prisma.scopeOfWorkPropertyUnits.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ScopeOfWorkPropertyUnitsFindManyArgs>(
      args?: SelectSubset<T, ScopeOfWorkPropertyUnitsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ScopeOfWorkPropertyUnits>>, PrismaPromise<Array<ScopeOfWorkPropertyUnitsGetPayload<T>>>>

    /**
     * Create a ScopeOfWorkPropertyUnits.
     * @param {ScopeOfWorkPropertyUnitsCreateArgs} args - Arguments to create a ScopeOfWorkPropertyUnits.
     * @example
     * // Create one ScopeOfWorkPropertyUnits
     * const ScopeOfWorkPropertyUnits = await prisma.scopeOfWorkPropertyUnits.create({
     *   data: {
     *     // ... data to create a ScopeOfWorkPropertyUnits
     *   }
     * })
     * 
    **/
    create<T extends ScopeOfWorkPropertyUnitsCreateArgs>(
      args: SelectSubset<T, ScopeOfWorkPropertyUnitsCreateArgs>
    ): CheckSelect<T, Prisma__ScopeOfWorkPropertyUnitsClient<ScopeOfWorkPropertyUnits>, Prisma__ScopeOfWorkPropertyUnitsClient<ScopeOfWorkPropertyUnitsGetPayload<T>>>

    /**
     * Delete a ScopeOfWorkPropertyUnits.
     * @param {ScopeOfWorkPropertyUnitsDeleteArgs} args - Arguments to delete one ScopeOfWorkPropertyUnits.
     * @example
     * // Delete one ScopeOfWorkPropertyUnits
     * const ScopeOfWorkPropertyUnits = await prisma.scopeOfWorkPropertyUnits.delete({
     *   where: {
     *     // ... filter to delete one ScopeOfWorkPropertyUnits
     *   }
     * })
     * 
    **/
    delete<T extends ScopeOfWorkPropertyUnitsDeleteArgs>(
      args: SelectSubset<T, ScopeOfWorkPropertyUnitsDeleteArgs>
    ): CheckSelect<T, Prisma__ScopeOfWorkPropertyUnitsClient<ScopeOfWorkPropertyUnits>, Prisma__ScopeOfWorkPropertyUnitsClient<ScopeOfWorkPropertyUnitsGetPayload<T>>>

    /**
     * Update one ScopeOfWorkPropertyUnits.
     * @param {ScopeOfWorkPropertyUnitsUpdateArgs} args - Arguments to update one ScopeOfWorkPropertyUnits.
     * @example
     * // Update one ScopeOfWorkPropertyUnits
     * const scopeOfWorkPropertyUnits = await prisma.scopeOfWorkPropertyUnits.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ScopeOfWorkPropertyUnitsUpdateArgs>(
      args: SelectSubset<T, ScopeOfWorkPropertyUnitsUpdateArgs>
    ): CheckSelect<T, Prisma__ScopeOfWorkPropertyUnitsClient<ScopeOfWorkPropertyUnits>, Prisma__ScopeOfWorkPropertyUnitsClient<ScopeOfWorkPropertyUnitsGetPayload<T>>>

    /**
     * Delete zero or more ScopeOfWorkPropertyUnits.
     * @param {ScopeOfWorkPropertyUnitsDeleteManyArgs} args - Arguments to filter ScopeOfWorkPropertyUnits to delete.
     * @example
     * // Delete a few ScopeOfWorkPropertyUnits
     * const { count } = await prisma.scopeOfWorkPropertyUnits.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ScopeOfWorkPropertyUnitsDeleteManyArgs>(
      args?: SelectSubset<T, ScopeOfWorkPropertyUnitsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScopeOfWorkPropertyUnits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScopeOfWorkPropertyUnitsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ScopeOfWorkPropertyUnits
     * const scopeOfWorkPropertyUnits = await prisma.scopeOfWorkPropertyUnits.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ScopeOfWorkPropertyUnitsUpdateManyArgs>(
      args: SelectSubset<T, ScopeOfWorkPropertyUnitsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ScopeOfWorkPropertyUnits.
     * @param {ScopeOfWorkPropertyUnitsUpsertArgs} args - Arguments to update or create a ScopeOfWorkPropertyUnits.
     * @example
     * // Update or create a ScopeOfWorkPropertyUnits
     * const scopeOfWorkPropertyUnits = await prisma.scopeOfWorkPropertyUnits.upsert({
     *   create: {
     *     // ... data to create a ScopeOfWorkPropertyUnits
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ScopeOfWorkPropertyUnits we want to update
     *   }
     * })
    **/
    upsert<T extends ScopeOfWorkPropertyUnitsUpsertArgs>(
      args: SelectSubset<T, ScopeOfWorkPropertyUnitsUpsertArgs>
    ): CheckSelect<T, Prisma__ScopeOfWorkPropertyUnitsClient<ScopeOfWorkPropertyUnits>, Prisma__ScopeOfWorkPropertyUnitsClient<ScopeOfWorkPropertyUnitsGetPayload<T>>>

    /**
     * Count the number of ScopeOfWorkPropertyUnits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScopeOfWorkPropertyUnitsCountArgs} args - Arguments to filter ScopeOfWorkPropertyUnits to count.
     * @example
     * // Count the number of ScopeOfWorkPropertyUnits
     * const count = await prisma.scopeOfWorkPropertyUnits.count({
     *   where: {
     *     // ... the filter for the ScopeOfWorkPropertyUnits we want to count
     *   }
     * })
    **/
    count<T extends ScopeOfWorkPropertyUnitsCountArgs>(
      args?: Subset<T, ScopeOfWorkPropertyUnitsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScopeOfWorkPropertyUnitsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ScopeOfWorkPropertyUnits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScopeOfWorkPropertyUnitsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScopeOfWorkPropertyUnitsAggregateArgs>(args: Subset<T, ScopeOfWorkPropertyUnitsAggregateArgs>): PrismaPromise<GetScopeOfWorkPropertyUnitsAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for ScopeOfWorkPropertyUnits.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ScopeOfWorkPropertyUnitsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    AreaOfWorks<T extends AreaOfWorksArgs = {}>(args?: Subset<T, AreaOfWorksArgs>): CheckSelect<T, Prisma__AreaOfWorksClient<AreaOfWorks | null >, Prisma__AreaOfWorksClient<AreaOfWorksGetPayload<T> | null >>;

    ProjectProposals<T extends ProjectProposalsArgs = {}>(args?: Subset<T, ProjectProposalsArgs>): CheckSelect<T, Prisma__ProjectProposalsClient<ProjectProposals | null >, Prisma__ProjectProposalsClient<ProjectProposalsGetPayload<T> | null >>;

    PropertyUnitAttributes<T extends PropertyUnitAttributesArgs = {}>(args?: Subset<T, PropertyUnitAttributesArgs>): CheckSelect<T, Prisma__PropertyUnitAttributesClient<PropertyUnitAttributes | null >, Prisma__PropertyUnitAttributesClient<PropertyUnitAttributesGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * ScopeOfWorkPropertyUnits findUnique
   */
  export type ScopeOfWorkPropertyUnitsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the ScopeOfWorkPropertyUnits
    **/
    select?: ScopeOfWorkPropertyUnitsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ScopeOfWorkPropertyUnitsInclude | null
    /**
     * Throw an Error if a ScopeOfWorkPropertyUnits can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ScopeOfWorkPropertyUnits to fetch.
    **/
    where: ScopeOfWorkPropertyUnitsWhereUniqueInput
  }


  /**
   * ScopeOfWorkPropertyUnits findFirst
   */
  export type ScopeOfWorkPropertyUnitsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the ScopeOfWorkPropertyUnits
    **/
    select?: ScopeOfWorkPropertyUnitsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ScopeOfWorkPropertyUnitsInclude | null
    /**
     * Throw an Error if a ScopeOfWorkPropertyUnits can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ScopeOfWorkPropertyUnits to fetch.
    **/
    where?: ScopeOfWorkPropertyUnitsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScopeOfWorkPropertyUnits to fetch.
    **/
    orderBy?: Enumerable<ScopeOfWorkPropertyUnitsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScopeOfWorkPropertyUnits.
    **/
    cursor?: ScopeOfWorkPropertyUnitsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScopeOfWorkPropertyUnits from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScopeOfWorkPropertyUnits.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScopeOfWorkPropertyUnits.
    **/
    distinct?: Enumerable<ScopeOfWorkPropertyUnitsScalarFieldEnum>
  }


  /**
   * ScopeOfWorkPropertyUnits findMany
   */
  export type ScopeOfWorkPropertyUnitsFindManyArgs = {
    /**
     * Select specific fields to fetch from the ScopeOfWorkPropertyUnits
    **/
    select?: ScopeOfWorkPropertyUnitsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ScopeOfWorkPropertyUnitsInclude | null
    /**
     * Filter, which ScopeOfWorkPropertyUnits to fetch.
    **/
    where?: ScopeOfWorkPropertyUnitsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScopeOfWorkPropertyUnits to fetch.
    **/
    orderBy?: Enumerable<ScopeOfWorkPropertyUnitsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ScopeOfWorkPropertyUnits.
    **/
    cursor?: ScopeOfWorkPropertyUnitsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScopeOfWorkPropertyUnits from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScopeOfWorkPropertyUnits.
    **/
    skip?: number
    distinct?: Enumerable<ScopeOfWorkPropertyUnitsScalarFieldEnum>
  }


  /**
   * ScopeOfWorkPropertyUnits create
   */
  export type ScopeOfWorkPropertyUnitsCreateArgs = {
    /**
     * Select specific fields to fetch from the ScopeOfWorkPropertyUnits
    **/
    select?: ScopeOfWorkPropertyUnitsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ScopeOfWorkPropertyUnitsInclude | null
    /**
     * The data needed to create a ScopeOfWorkPropertyUnits.
    **/
    data: XOR<ScopeOfWorkPropertyUnitsCreateInput, ScopeOfWorkPropertyUnitsUncheckedCreateInput>
  }


  /**
   * ScopeOfWorkPropertyUnits update
   */
  export type ScopeOfWorkPropertyUnitsUpdateArgs = {
    /**
     * Select specific fields to fetch from the ScopeOfWorkPropertyUnits
    **/
    select?: ScopeOfWorkPropertyUnitsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ScopeOfWorkPropertyUnitsInclude | null
    /**
     * The data needed to update a ScopeOfWorkPropertyUnits.
    **/
    data: XOR<ScopeOfWorkPropertyUnitsUpdateInput, ScopeOfWorkPropertyUnitsUncheckedUpdateInput>
    /**
     * Choose, which ScopeOfWorkPropertyUnits to update.
    **/
    where: ScopeOfWorkPropertyUnitsWhereUniqueInput
  }


  /**
   * ScopeOfWorkPropertyUnits updateMany
   */
  export type ScopeOfWorkPropertyUnitsUpdateManyArgs = {
    data: XOR<ScopeOfWorkPropertyUnitsUpdateManyMutationInput, ScopeOfWorkPropertyUnitsUncheckedUpdateManyInput>
    where?: ScopeOfWorkPropertyUnitsWhereInput
  }


  /**
   * ScopeOfWorkPropertyUnits upsert
   */
  export type ScopeOfWorkPropertyUnitsUpsertArgs = {
    /**
     * Select specific fields to fetch from the ScopeOfWorkPropertyUnits
    **/
    select?: ScopeOfWorkPropertyUnitsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ScopeOfWorkPropertyUnitsInclude | null
    /**
     * The filter to search for the ScopeOfWorkPropertyUnits to update in case it exists.
    **/
    where: ScopeOfWorkPropertyUnitsWhereUniqueInput
    /**
     * In case the ScopeOfWorkPropertyUnits found by the `where` argument doesn't exist, create a new ScopeOfWorkPropertyUnits with this data.
    **/
    create: XOR<ScopeOfWorkPropertyUnitsCreateInput, ScopeOfWorkPropertyUnitsUncheckedCreateInput>
    /**
     * In case the ScopeOfWorkPropertyUnits was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<ScopeOfWorkPropertyUnitsUpdateInput, ScopeOfWorkPropertyUnitsUncheckedUpdateInput>
  }


  /**
   * ScopeOfWorkPropertyUnits delete
   */
  export type ScopeOfWorkPropertyUnitsDeleteArgs = {
    /**
     * Select specific fields to fetch from the ScopeOfWorkPropertyUnits
    **/
    select?: ScopeOfWorkPropertyUnitsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ScopeOfWorkPropertyUnitsInclude | null
    /**
     * Filter which ScopeOfWorkPropertyUnits to delete.
    **/
    where: ScopeOfWorkPropertyUnitsWhereUniqueInput
  }


  /**
   * ScopeOfWorkPropertyUnits deleteMany
   */
  export type ScopeOfWorkPropertyUnitsDeleteManyArgs = {
    where?: ScopeOfWorkPropertyUnitsWhereInput
  }


  /**
   * ScopeOfWorkPropertyUnits without action
   */
  export type ScopeOfWorkPropertyUnitsArgs = {
    /**
     * Select specific fields to fetch from the ScopeOfWorkPropertyUnits
    **/
    select?: ScopeOfWorkPropertyUnitsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ScopeOfWorkPropertyUnitsInclude | null
  }



  /**
   * Model ScopeOfWorks
   */


  export type AggregateScopeOfWorks = {
    count: ScopeOfWorksCountAggregateOutputType | null
    avg: ScopeOfWorksAvgAggregateOutputType | null
    sum: ScopeOfWorksSumAggregateOutputType | null
    min: ScopeOfWorksMinAggregateOutputType | null
    max: ScopeOfWorksMaxAggregateOutputType | null
  }

  export type ScopeOfWorksAvgAggregateOutputType = {
    id: number
    project_proposal_id: number
    area_of_work_id: number
    product_attribute_unit_id: number
    product_attribute_unit_value_id: number
    created_by: number | null
    updated_by: number | null
  }

  export type ScopeOfWorksSumAggregateOutputType = {
    id: number
    project_proposal_id: number
    area_of_work_id: number
    product_attribute_unit_id: number
    product_attribute_unit_value_id: number
    created_by: number | null
    updated_by: number | null
  }

  export type ScopeOfWorksMinAggregateOutputType = {
    id: number
    project_proposal_id: number
    area_of_work_id: number
    product_attribute_unit_id: number
    product_attribute_unit_value_id: number
    attribute_custom_name: string | null
    attribute_custom_value: string | null
    attribute_custom_unit: string | null
    created_at: Date | null
    updated_at: Date | null
    created_by: number | null
    updated_by: number | null
  }

  export type ScopeOfWorksMaxAggregateOutputType = {
    id: number
    project_proposal_id: number
    area_of_work_id: number
    product_attribute_unit_id: number
    product_attribute_unit_value_id: number
    attribute_custom_name: string | null
    attribute_custom_value: string | null
    attribute_custom_unit: string | null
    created_at: Date | null
    updated_at: Date | null
    created_by: number | null
    updated_by: number | null
  }

  export type ScopeOfWorksCountAggregateOutputType = {
    id: number
    project_proposal_id: number
    area_of_work_id: number
    product_attribute_unit_id: number
    product_attribute_unit_value_id: number
    attribute_custom_name: number | null
    attribute_custom_value: number | null
    attribute_custom_unit: number | null
    created_at: number | null
    updated_at: number | null
    created_by: number | null
    updated_by: number | null
    _all: number
  }


  export type ScopeOfWorksAvgAggregateInputType = {
    id?: true
    project_proposal_id?: true
    area_of_work_id?: true
    product_attribute_unit_id?: true
    product_attribute_unit_value_id?: true
    created_by?: true
    updated_by?: true
  }

  export type ScopeOfWorksSumAggregateInputType = {
    id?: true
    project_proposal_id?: true
    area_of_work_id?: true
    product_attribute_unit_id?: true
    product_attribute_unit_value_id?: true
    created_by?: true
    updated_by?: true
  }

  export type ScopeOfWorksMinAggregateInputType = {
    id?: true
    project_proposal_id?: true
    area_of_work_id?: true
    product_attribute_unit_id?: true
    product_attribute_unit_value_id?: true
    attribute_custom_name?: true
    attribute_custom_value?: true
    attribute_custom_unit?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type ScopeOfWorksMaxAggregateInputType = {
    id?: true
    project_proposal_id?: true
    area_of_work_id?: true
    product_attribute_unit_id?: true
    product_attribute_unit_value_id?: true
    attribute_custom_name?: true
    attribute_custom_value?: true
    attribute_custom_unit?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type ScopeOfWorksCountAggregateInputType = {
    id?: true
    project_proposal_id?: true
    area_of_work_id?: true
    product_attribute_unit_id?: true
    product_attribute_unit_value_id?: true
    attribute_custom_name?: true
    attribute_custom_value?: true
    attribute_custom_unit?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
    _all?: true
  }

  export type ScopeOfWorksAggregateArgs = {
    /**
     * Filter which ScopeOfWorks to aggregate.
    **/
    where?: ScopeOfWorksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScopeOfWorks to fetch.
    **/
    orderBy?: Enumerable<ScopeOfWorksOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: ScopeOfWorksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScopeOfWorks from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScopeOfWorks.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ScopeOfWorks
    **/
    count?: true | ScopeOfWorksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: ScopeOfWorksAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: ScopeOfWorksSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: ScopeOfWorksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: ScopeOfWorksMaxAggregateInputType
  }

  export type GetScopeOfWorksAggregateType<T extends ScopeOfWorksAggregateArgs> = {
    [P in keyof T & keyof AggregateScopeOfWorks]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScopeOfWorks[P]>
      : GetScalarType<T[P], AggregateScopeOfWorks[P]>
  }



  export type ScopeOfWorksSelect = {
    id?: boolean
    project_proposal_id?: boolean
    area_of_work_id?: boolean
    product_attribute_unit_id?: boolean
    product_attribute_unit_value_id?: boolean
    attribute_custom_name?: boolean
    attribute_custom_value?: boolean
    attribute_custom_unit?: boolean
    created_at?: boolean
    updated_at?: boolean
    created_by?: boolean
    updated_by?: boolean
    AreaOfWorks?: boolean | AreaOfWorksArgs
    ProductAttributeUnits?: boolean | ProductAttributeUnitsArgs
    ProductAttributeUnitValues?: boolean | ProductAttributeUnitValuesArgs
    ProjectProposals?: boolean | ProjectProposalsArgs
  }

  export type ScopeOfWorksInclude = {
    AreaOfWorks?: boolean | AreaOfWorksArgs
    ProductAttributeUnits?: boolean | ProductAttributeUnitsArgs
    ProductAttributeUnitValues?: boolean | ProductAttributeUnitValuesArgs
    ProjectProposals?: boolean | ProjectProposalsArgs
  }

  export type ScopeOfWorksGetPayload<
    S extends boolean | null | undefined | ScopeOfWorksArgs,
    U = keyof S
      > = S extends true
        ? ScopeOfWorks
    : S extends undefined
    ? never
    : S extends ScopeOfWorksArgs | ScopeOfWorksFindManyArgs
    ?'include' extends U
    ? ScopeOfWorks  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'AreaOfWorks'
        ? AreaOfWorksGetPayload<S['include'][P]> :
        P extends 'ProductAttributeUnits'
        ? ProductAttributeUnitsGetPayload<S['include'][P]> :
        P extends 'ProductAttributeUnitValues'
        ? ProductAttributeUnitValuesGetPayload<S['include'][P]> :
        P extends 'ProjectProposals'
        ? ProjectProposalsGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof ScopeOfWorks ?ScopeOfWorks [P]
  : 
          P extends 'AreaOfWorks'
        ? AreaOfWorksGetPayload<S['select'][P]> :
        P extends 'ProductAttributeUnits'
        ? ProductAttributeUnitsGetPayload<S['select'][P]> :
        P extends 'ProductAttributeUnitValues'
        ? ProductAttributeUnitValuesGetPayload<S['select'][P]> :
        P extends 'ProjectProposals'
        ? ProjectProposalsGetPayload<S['select'][P]> : never
  } 
    : ScopeOfWorks
  : ScopeOfWorks


  type ScopeOfWorksCountArgs = Merge<
    Omit<ScopeOfWorksFindManyArgs, 'select' | 'include'> & {
      select?: ScopeOfWorksCountAggregateInputType | true
    }
  >

  export interface ScopeOfWorksDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one ScopeOfWorks that matches the filter.
     * @param {ScopeOfWorksFindUniqueArgs} args - Arguments to find a ScopeOfWorks
     * @example
     * // Get one ScopeOfWorks
     * const scopeOfWorks = await prisma.scopeOfWorks.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ScopeOfWorksFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ScopeOfWorksFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ScopeOfWorks'> extends True ? CheckSelect<T, Prisma__ScopeOfWorksClient<ScopeOfWorks>, Prisma__ScopeOfWorksClient<ScopeOfWorksGetPayload<T>>> : CheckSelect<T, Prisma__ScopeOfWorksClient<ScopeOfWorks | null >, Prisma__ScopeOfWorksClient<ScopeOfWorksGetPayload<T> | null >>

    /**
     * Find the first ScopeOfWorks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScopeOfWorksFindFirstArgs} args - Arguments to find a ScopeOfWorks
     * @example
     * // Get one ScopeOfWorks
     * const scopeOfWorks = await prisma.scopeOfWorks.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ScopeOfWorksFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ScopeOfWorksFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ScopeOfWorks'> extends True ? CheckSelect<T, Prisma__ScopeOfWorksClient<ScopeOfWorks>, Prisma__ScopeOfWorksClient<ScopeOfWorksGetPayload<T>>> : CheckSelect<T, Prisma__ScopeOfWorksClient<ScopeOfWorks | null >, Prisma__ScopeOfWorksClient<ScopeOfWorksGetPayload<T> | null >>

    /**
     * Find zero or more ScopeOfWorks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScopeOfWorksFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ScopeOfWorks
     * const scopeOfWorks = await prisma.scopeOfWorks.findMany()
     * 
     * // Get first 10 ScopeOfWorks
     * const scopeOfWorks = await prisma.scopeOfWorks.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const scopeOfWorksWithIdOnly = await prisma.scopeOfWorks.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ScopeOfWorksFindManyArgs>(
      args?: SelectSubset<T, ScopeOfWorksFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ScopeOfWorks>>, PrismaPromise<Array<ScopeOfWorksGetPayload<T>>>>

    /**
     * Create a ScopeOfWorks.
     * @param {ScopeOfWorksCreateArgs} args - Arguments to create a ScopeOfWorks.
     * @example
     * // Create one ScopeOfWorks
     * const ScopeOfWorks = await prisma.scopeOfWorks.create({
     *   data: {
     *     // ... data to create a ScopeOfWorks
     *   }
     * })
     * 
    **/
    create<T extends ScopeOfWorksCreateArgs>(
      args: SelectSubset<T, ScopeOfWorksCreateArgs>
    ): CheckSelect<T, Prisma__ScopeOfWorksClient<ScopeOfWorks>, Prisma__ScopeOfWorksClient<ScopeOfWorksGetPayload<T>>>

    /**
     * Delete a ScopeOfWorks.
     * @param {ScopeOfWorksDeleteArgs} args - Arguments to delete one ScopeOfWorks.
     * @example
     * // Delete one ScopeOfWorks
     * const ScopeOfWorks = await prisma.scopeOfWorks.delete({
     *   where: {
     *     // ... filter to delete one ScopeOfWorks
     *   }
     * })
     * 
    **/
    delete<T extends ScopeOfWorksDeleteArgs>(
      args: SelectSubset<T, ScopeOfWorksDeleteArgs>
    ): CheckSelect<T, Prisma__ScopeOfWorksClient<ScopeOfWorks>, Prisma__ScopeOfWorksClient<ScopeOfWorksGetPayload<T>>>

    /**
     * Update one ScopeOfWorks.
     * @param {ScopeOfWorksUpdateArgs} args - Arguments to update one ScopeOfWorks.
     * @example
     * // Update one ScopeOfWorks
     * const scopeOfWorks = await prisma.scopeOfWorks.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ScopeOfWorksUpdateArgs>(
      args: SelectSubset<T, ScopeOfWorksUpdateArgs>
    ): CheckSelect<T, Prisma__ScopeOfWorksClient<ScopeOfWorks>, Prisma__ScopeOfWorksClient<ScopeOfWorksGetPayload<T>>>

    /**
     * Delete zero or more ScopeOfWorks.
     * @param {ScopeOfWorksDeleteManyArgs} args - Arguments to filter ScopeOfWorks to delete.
     * @example
     * // Delete a few ScopeOfWorks
     * const { count } = await prisma.scopeOfWorks.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ScopeOfWorksDeleteManyArgs>(
      args?: SelectSubset<T, ScopeOfWorksDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScopeOfWorks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScopeOfWorksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ScopeOfWorks
     * const scopeOfWorks = await prisma.scopeOfWorks.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ScopeOfWorksUpdateManyArgs>(
      args: SelectSubset<T, ScopeOfWorksUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ScopeOfWorks.
     * @param {ScopeOfWorksUpsertArgs} args - Arguments to update or create a ScopeOfWorks.
     * @example
     * // Update or create a ScopeOfWorks
     * const scopeOfWorks = await prisma.scopeOfWorks.upsert({
     *   create: {
     *     // ... data to create a ScopeOfWorks
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ScopeOfWorks we want to update
     *   }
     * })
    **/
    upsert<T extends ScopeOfWorksUpsertArgs>(
      args: SelectSubset<T, ScopeOfWorksUpsertArgs>
    ): CheckSelect<T, Prisma__ScopeOfWorksClient<ScopeOfWorks>, Prisma__ScopeOfWorksClient<ScopeOfWorksGetPayload<T>>>

    /**
     * Count the number of ScopeOfWorks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScopeOfWorksCountArgs} args - Arguments to filter ScopeOfWorks to count.
     * @example
     * // Count the number of ScopeOfWorks
     * const count = await prisma.scopeOfWorks.count({
     *   where: {
     *     // ... the filter for the ScopeOfWorks we want to count
     *   }
     * })
    **/
    count<T extends ScopeOfWorksCountArgs>(
      args?: Subset<T, ScopeOfWorksCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScopeOfWorksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ScopeOfWorks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScopeOfWorksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScopeOfWorksAggregateArgs>(args: Subset<T, ScopeOfWorksAggregateArgs>): PrismaPromise<GetScopeOfWorksAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for ScopeOfWorks.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ScopeOfWorksClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    AreaOfWorks<T extends AreaOfWorksArgs = {}>(args?: Subset<T, AreaOfWorksArgs>): CheckSelect<T, Prisma__AreaOfWorksClient<AreaOfWorks | null >, Prisma__AreaOfWorksClient<AreaOfWorksGetPayload<T> | null >>;

    ProductAttributeUnits<T extends ProductAttributeUnitsArgs = {}>(args?: Subset<T, ProductAttributeUnitsArgs>): CheckSelect<T, Prisma__ProductAttributeUnitsClient<ProductAttributeUnits | null >, Prisma__ProductAttributeUnitsClient<ProductAttributeUnitsGetPayload<T> | null >>;

    ProductAttributeUnitValues<T extends ProductAttributeUnitValuesArgs = {}>(args?: Subset<T, ProductAttributeUnitValuesArgs>): CheckSelect<T, Prisma__ProductAttributeUnitValuesClient<ProductAttributeUnitValues | null >, Prisma__ProductAttributeUnitValuesClient<ProductAttributeUnitValuesGetPayload<T> | null >>;

    ProjectProposals<T extends ProjectProposalsArgs = {}>(args?: Subset<T, ProjectProposalsArgs>): CheckSelect<T, Prisma__ProjectProposalsClient<ProjectProposals | null >, Prisma__ProjectProposalsClient<ProjectProposalsGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * ScopeOfWorks findUnique
   */
  export type ScopeOfWorksFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the ScopeOfWorks
    **/
    select?: ScopeOfWorksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ScopeOfWorksInclude | null
    /**
     * Throw an Error if a ScopeOfWorks can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ScopeOfWorks to fetch.
    **/
    where: ScopeOfWorksWhereUniqueInput
  }


  /**
   * ScopeOfWorks findFirst
   */
  export type ScopeOfWorksFindFirstArgs = {
    /**
     * Select specific fields to fetch from the ScopeOfWorks
    **/
    select?: ScopeOfWorksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ScopeOfWorksInclude | null
    /**
     * Throw an Error if a ScopeOfWorks can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ScopeOfWorks to fetch.
    **/
    where?: ScopeOfWorksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScopeOfWorks to fetch.
    **/
    orderBy?: Enumerable<ScopeOfWorksOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScopeOfWorks.
    **/
    cursor?: ScopeOfWorksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScopeOfWorks from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScopeOfWorks.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScopeOfWorks.
    **/
    distinct?: Enumerable<ScopeOfWorksScalarFieldEnum>
  }


  /**
   * ScopeOfWorks findMany
   */
  export type ScopeOfWorksFindManyArgs = {
    /**
     * Select specific fields to fetch from the ScopeOfWorks
    **/
    select?: ScopeOfWorksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ScopeOfWorksInclude | null
    /**
     * Filter, which ScopeOfWorks to fetch.
    **/
    where?: ScopeOfWorksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScopeOfWorks to fetch.
    **/
    orderBy?: Enumerable<ScopeOfWorksOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ScopeOfWorks.
    **/
    cursor?: ScopeOfWorksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScopeOfWorks from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScopeOfWorks.
    **/
    skip?: number
    distinct?: Enumerable<ScopeOfWorksScalarFieldEnum>
  }


  /**
   * ScopeOfWorks create
   */
  export type ScopeOfWorksCreateArgs = {
    /**
     * Select specific fields to fetch from the ScopeOfWorks
    **/
    select?: ScopeOfWorksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ScopeOfWorksInclude | null
    /**
     * The data needed to create a ScopeOfWorks.
    **/
    data: XOR<ScopeOfWorksCreateInput, ScopeOfWorksUncheckedCreateInput>
  }


  /**
   * ScopeOfWorks update
   */
  export type ScopeOfWorksUpdateArgs = {
    /**
     * Select specific fields to fetch from the ScopeOfWorks
    **/
    select?: ScopeOfWorksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ScopeOfWorksInclude | null
    /**
     * The data needed to update a ScopeOfWorks.
    **/
    data: XOR<ScopeOfWorksUpdateInput, ScopeOfWorksUncheckedUpdateInput>
    /**
     * Choose, which ScopeOfWorks to update.
    **/
    where: ScopeOfWorksWhereUniqueInput
  }


  /**
   * ScopeOfWorks updateMany
   */
  export type ScopeOfWorksUpdateManyArgs = {
    data: XOR<ScopeOfWorksUpdateManyMutationInput, ScopeOfWorksUncheckedUpdateManyInput>
    where?: ScopeOfWorksWhereInput
  }


  /**
   * ScopeOfWorks upsert
   */
  export type ScopeOfWorksUpsertArgs = {
    /**
     * Select specific fields to fetch from the ScopeOfWorks
    **/
    select?: ScopeOfWorksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ScopeOfWorksInclude | null
    /**
     * The filter to search for the ScopeOfWorks to update in case it exists.
    **/
    where: ScopeOfWorksWhereUniqueInput
    /**
     * In case the ScopeOfWorks found by the `where` argument doesn't exist, create a new ScopeOfWorks with this data.
    **/
    create: XOR<ScopeOfWorksCreateInput, ScopeOfWorksUncheckedCreateInput>
    /**
     * In case the ScopeOfWorks was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<ScopeOfWorksUpdateInput, ScopeOfWorksUncheckedUpdateInput>
  }


  /**
   * ScopeOfWorks delete
   */
  export type ScopeOfWorksDeleteArgs = {
    /**
     * Select specific fields to fetch from the ScopeOfWorks
    **/
    select?: ScopeOfWorksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ScopeOfWorksInclude | null
    /**
     * Filter which ScopeOfWorks to delete.
    **/
    where: ScopeOfWorksWhereUniqueInput
  }


  /**
   * ScopeOfWorks deleteMany
   */
  export type ScopeOfWorksDeleteManyArgs = {
    where?: ScopeOfWorksWhereInput
  }


  /**
   * ScopeOfWorks without action
   */
  export type ScopeOfWorksArgs = {
    /**
     * Select specific fields to fetch from the ScopeOfWorks
    **/
    select?: ScopeOfWorksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ScopeOfWorksInclude | null
  }



  /**
   * Model SequelizeMeta
   */


  export type AggregateSequelizeMeta = {
    count: SequelizeMetaCountAggregateOutputType | null
    min: SequelizeMetaMinAggregateOutputType | null
    max: SequelizeMetaMaxAggregateOutputType | null
  }

  export type SequelizeMetaMinAggregateOutputType = {
    name: string | null
  }

  export type SequelizeMetaMaxAggregateOutputType = {
    name: string | null
  }

  export type SequelizeMetaCountAggregateOutputType = {
    name: number | null
    _all: number
  }


  export type SequelizeMetaMinAggregateInputType = {
    name?: true
  }

  export type SequelizeMetaMaxAggregateInputType = {
    name?: true
  }

  export type SequelizeMetaCountAggregateInputType = {
    name?: true
    _all?: true
  }

  export type SequelizeMetaAggregateArgs = {
    /**
     * Filter which SequelizeMeta to aggregate.
    **/
    where?: SequelizeMetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SequelizeMetas to fetch.
    **/
    orderBy?: Enumerable<SequelizeMetaOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: SequelizeMetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SequelizeMetas from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SequelizeMetas.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SequelizeMetas
    **/
    count?: true | SequelizeMetaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: SequelizeMetaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: SequelizeMetaMaxAggregateInputType
  }

  export type GetSequelizeMetaAggregateType<T extends SequelizeMetaAggregateArgs> = {
    [P in keyof T & keyof AggregateSequelizeMeta]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSequelizeMeta[P]>
      : GetScalarType<T[P], AggregateSequelizeMeta[P]>
  }



  export type SequelizeMetaSelect = {
    name?: boolean
  }

  export type SequelizeMetaGetPayload<
    S extends boolean | null | undefined | SequelizeMetaArgs,
    U = keyof S
      > = S extends true
        ? SequelizeMeta
    : S extends undefined
    ? never
    : S extends SequelizeMetaArgs | SequelizeMetaFindManyArgs
    ?'include' extends U
    ? SequelizeMeta 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof SequelizeMeta ?SequelizeMeta [P]
  : 
     never
  } 
    : SequelizeMeta
  : SequelizeMeta


  type SequelizeMetaCountArgs = Merge<
    Omit<SequelizeMetaFindManyArgs, 'select' | 'include'> & {
      select?: SequelizeMetaCountAggregateInputType | true
    }
  >

  export interface SequelizeMetaDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one SequelizeMeta that matches the filter.
     * @param {SequelizeMetaFindUniqueArgs} args - Arguments to find a SequelizeMeta
     * @example
     * // Get one SequelizeMeta
     * const sequelizeMeta = await prisma.sequelizeMeta.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SequelizeMetaFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SequelizeMetaFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'SequelizeMeta'> extends True ? CheckSelect<T, Prisma__SequelizeMetaClient<SequelizeMeta>, Prisma__SequelizeMetaClient<SequelizeMetaGetPayload<T>>> : CheckSelect<T, Prisma__SequelizeMetaClient<SequelizeMeta | null >, Prisma__SequelizeMetaClient<SequelizeMetaGetPayload<T> | null >>

    /**
     * Find the first SequelizeMeta that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SequelizeMetaFindFirstArgs} args - Arguments to find a SequelizeMeta
     * @example
     * // Get one SequelizeMeta
     * const sequelizeMeta = await prisma.sequelizeMeta.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SequelizeMetaFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SequelizeMetaFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'SequelizeMeta'> extends True ? CheckSelect<T, Prisma__SequelizeMetaClient<SequelizeMeta>, Prisma__SequelizeMetaClient<SequelizeMetaGetPayload<T>>> : CheckSelect<T, Prisma__SequelizeMetaClient<SequelizeMeta | null >, Prisma__SequelizeMetaClient<SequelizeMetaGetPayload<T> | null >>

    /**
     * Find zero or more SequelizeMetas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SequelizeMetaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SequelizeMetas
     * const sequelizeMetas = await prisma.sequelizeMeta.findMany()
     * 
     * // Get first 10 SequelizeMetas
     * const sequelizeMetas = await prisma.sequelizeMeta.findMany({ take: 10 })
     * 
     * // Only select the `name`
     * const sequelizeMetaWithNameOnly = await prisma.sequelizeMeta.findMany({ select: { name: true } })
     * 
    **/
    findMany<T extends SequelizeMetaFindManyArgs>(
      args?: SelectSubset<T, SequelizeMetaFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<SequelizeMeta>>, PrismaPromise<Array<SequelizeMetaGetPayload<T>>>>

    /**
     * Create a SequelizeMeta.
     * @param {SequelizeMetaCreateArgs} args - Arguments to create a SequelizeMeta.
     * @example
     * // Create one SequelizeMeta
     * const SequelizeMeta = await prisma.sequelizeMeta.create({
     *   data: {
     *     // ... data to create a SequelizeMeta
     *   }
     * })
     * 
    **/
    create<T extends SequelizeMetaCreateArgs>(
      args: SelectSubset<T, SequelizeMetaCreateArgs>
    ): CheckSelect<T, Prisma__SequelizeMetaClient<SequelizeMeta>, Prisma__SequelizeMetaClient<SequelizeMetaGetPayload<T>>>

    /**
     * Delete a SequelizeMeta.
     * @param {SequelizeMetaDeleteArgs} args - Arguments to delete one SequelizeMeta.
     * @example
     * // Delete one SequelizeMeta
     * const SequelizeMeta = await prisma.sequelizeMeta.delete({
     *   where: {
     *     // ... filter to delete one SequelizeMeta
     *   }
     * })
     * 
    **/
    delete<T extends SequelizeMetaDeleteArgs>(
      args: SelectSubset<T, SequelizeMetaDeleteArgs>
    ): CheckSelect<T, Prisma__SequelizeMetaClient<SequelizeMeta>, Prisma__SequelizeMetaClient<SequelizeMetaGetPayload<T>>>

    /**
     * Update one SequelizeMeta.
     * @param {SequelizeMetaUpdateArgs} args - Arguments to update one SequelizeMeta.
     * @example
     * // Update one SequelizeMeta
     * const sequelizeMeta = await prisma.sequelizeMeta.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SequelizeMetaUpdateArgs>(
      args: SelectSubset<T, SequelizeMetaUpdateArgs>
    ): CheckSelect<T, Prisma__SequelizeMetaClient<SequelizeMeta>, Prisma__SequelizeMetaClient<SequelizeMetaGetPayload<T>>>

    /**
     * Delete zero or more SequelizeMetas.
     * @param {SequelizeMetaDeleteManyArgs} args - Arguments to filter SequelizeMetas to delete.
     * @example
     * // Delete a few SequelizeMetas
     * const { count } = await prisma.sequelizeMeta.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SequelizeMetaDeleteManyArgs>(
      args?: SelectSubset<T, SequelizeMetaDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more SequelizeMetas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SequelizeMetaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SequelizeMetas
     * const sequelizeMeta = await prisma.sequelizeMeta.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SequelizeMetaUpdateManyArgs>(
      args: SelectSubset<T, SequelizeMetaUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one SequelizeMeta.
     * @param {SequelizeMetaUpsertArgs} args - Arguments to update or create a SequelizeMeta.
     * @example
     * // Update or create a SequelizeMeta
     * const sequelizeMeta = await prisma.sequelizeMeta.upsert({
     *   create: {
     *     // ... data to create a SequelizeMeta
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SequelizeMeta we want to update
     *   }
     * })
    **/
    upsert<T extends SequelizeMetaUpsertArgs>(
      args: SelectSubset<T, SequelizeMetaUpsertArgs>
    ): CheckSelect<T, Prisma__SequelizeMetaClient<SequelizeMeta>, Prisma__SequelizeMetaClient<SequelizeMetaGetPayload<T>>>

    /**
     * Count the number of SequelizeMetas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SequelizeMetaCountArgs} args - Arguments to filter SequelizeMetas to count.
     * @example
     * // Count the number of SequelizeMetas
     * const count = await prisma.sequelizeMeta.count({
     *   where: {
     *     // ... the filter for the SequelizeMetas we want to count
     *   }
     * })
    **/
    count<T extends SequelizeMetaCountArgs>(
      args?: Subset<T, SequelizeMetaCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SequelizeMetaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SequelizeMeta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SequelizeMetaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SequelizeMetaAggregateArgs>(args: Subset<T, SequelizeMetaAggregateArgs>): PrismaPromise<GetSequelizeMetaAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for SequelizeMeta.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SequelizeMetaClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * SequelizeMeta findUnique
   */
  export type SequelizeMetaFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the SequelizeMeta
    **/
    select?: SequelizeMetaSelect | null
    /**
     * Throw an Error if a SequelizeMeta can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which SequelizeMeta to fetch.
    **/
    where: SequelizeMetaWhereUniqueInput
  }


  /**
   * SequelizeMeta findFirst
   */
  export type SequelizeMetaFindFirstArgs = {
    /**
     * Select specific fields to fetch from the SequelizeMeta
    **/
    select?: SequelizeMetaSelect | null
    /**
     * Throw an Error if a SequelizeMeta can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which SequelizeMeta to fetch.
    **/
    where?: SequelizeMetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SequelizeMetas to fetch.
    **/
    orderBy?: Enumerable<SequelizeMetaOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SequelizeMetas.
    **/
    cursor?: SequelizeMetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SequelizeMetas from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SequelizeMetas.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SequelizeMetas.
    **/
    distinct?: Enumerable<SequelizeMetaScalarFieldEnum>
  }


  /**
   * SequelizeMeta findMany
   */
  export type SequelizeMetaFindManyArgs = {
    /**
     * Select specific fields to fetch from the SequelizeMeta
    **/
    select?: SequelizeMetaSelect | null
    /**
     * Filter, which SequelizeMetas to fetch.
    **/
    where?: SequelizeMetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SequelizeMetas to fetch.
    **/
    orderBy?: Enumerable<SequelizeMetaOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SequelizeMetas.
    **/
    cursor?: SequelizeMetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SequelizeMetas from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SequelizeMetas.
    **/
    skip?: number
    distinct?: Enumerable<SequelizeMetaScalarFieldEnum>
  }


  /**
   * SequelizeMeta create
   */
  export type SequelizeMetaCreateArgs = {
    /**
     * Select specific fields to fetch from the SequelizeMeta
    **/
    select?: SequelizeMetaSelect | null
    /**
     * The data needed to create a SequelizeMeta.
    **/
    data: XOR<SequelizeMetaCreateInput, SequelizeMetaUncheckedCreateInput>
  }


  /**
   * SequelizeMeta update
   */
  export type SequelizeMetaUpdateArgs = {
    /**
     * Select specific fields to fetch from the SequelizeMeta
    **/
    select?: SequelizeMetaSelect | null
    /**
     * The data needed to update a SequelizeMeta.
    **/
    data: XOR<SequelizeMetaUpdateInput, SequelizeMetaUncheckedUpdateInput>
    /**
     * Choose, which SequelizeMeta to update.
    **/
    where: SequelizeMetaWhereUniqueInput
  }


  /**
   * SequelizeMeta updateMany
   */
  export type SequelizeMetaUpdateManyArgs = {
    data: XOR<SequelizeMetaUpdateManyMutationInput, SequelizeMetaUncheckedUpdateManyInput>
    where?: SequelizeMetaWhereInput
  }


  /**
   * SequelizeMeta upsert
   */
  export type SequelizeMetaUpsertArgs = {
    /**
     * Select specific fields to fetch from the SequelizeMeta
    **/
    select?: SequelizeMetaSelect | null
    /**
     * The filter to search for the SequelizeMeta to update in case it exists.
    **/
    where: SequelizeMetaWhereUniqueInput
    /**
     * In case the SequelizeMeta found by the `where` argument doesn't exist, create a new SequelizeMeta with this data.
    **/
    create: XOR<SequelizeMetaCreateInput, SequelizeMetaUncheckedCreateInput>
    /**
     * In case the SequelizeMeta was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<SequelizeMetaUpdateInput, SequelizeMetaUncheckedUpdateInput>
  }


  /**
   * SequelizeMeta delete
   */
  export type SequelizeMetaDeleteArgs = {
    /**
     * Select specific fields to fetch from the SequelizeMeta
    **/
    select?: SequelizeMetaSelect | null
    /**
     * Filter which SequelizeMeta to delete.
    **/
    where: SequelizeMetaWhereUniqueInput
  }


  /**
   * SequelizeMeta deleteMany
   */
  export type SequelizeMetaDeleteManyArgs = {
    where?: SequelizeMetaWhereInput
  }


  /**
   * SequelizeMeta without action
   */
  export type SequelizeMetaArgs = {
    /**
     * Select specific fields to fetch from the SequelizeMeta
    **/
    select?: SequelizeMetaSelect | null
  }



  /**
   * Model States
   */


  export type AggregateStates = {
    count: StatesCountAggregateOutputType | null
    avg: StatesAvgAggregateOutputType | null
    sum: StatesSumAggregateOutputType | null
    min: StatesMinAggregateOutputType | null
    max: StatesMaxAggregateOutputType | null
  }

  export type StatesAvgAggregateOutputType = {
    id: number
    country_id: number
    created_by: number | null
    updated_by: number | null
  }

  export type StatesSumAggregateOutputType = {
    id: number
    country_id: number
    created_by: number | null
    updated_by: number | null
  }

  export type StatesMinAggregateOutputType = {
    id: number
    country_id: number
    name: string | null
    state_code: string | null
    status: boolean | null
    created_at: Date | null
    updated_at: Date | null
    created_by: number | null
    updated_by: number | null
  }

  export type StatesMaxAggregateOutputType = {
    id: number
    country_id: number
    name: string | null
    state_code: string | null
    status: boolean | null
    created_at: Date | null
    updated_at: Date | null
    created_by: number | null
    updated_by: number | null
  }

  export type StatesCountAggregateOutputType = {
    id: number
    country_id: number
    name: number | null
    state_code: number | null
    status: number | null
    created_at: number | null
    updated_at: number | null
    created_by: number | null
    updated_by: number | null
    _all: number
  }


  export type StatesAvgAggregateInputType = {
    id?: true
    country_id?: true
    created_by?: true
    updated_by?: true
  }

  export type StatesSumAggregateInputType = {
    id?: true
    country_id?: true
    created_by?: true
    updated_by?: true
  }

  export type StatesMinAggregateInputType = {
    id?: true
    country_id?: true
    name?: true
    state_code?: true
    status?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type StatesMaxAggregateInputType = {
    id?: true
    country_id?: true
    name?: true
    state_code?: true
    status?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type StatesCountAggregateInputType = {
    id?: true
    country_id?: true
    name?: true
    state_code?: true
    status?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
    _all?: true
  }

  export type StatesAggregateArgs = {
    /**
     * Filter which States to aggregate.
    **/
    where?: StatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of States to fetch.
    **/
    orderBy?: Enumerable<StatesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: StatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` States from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` States.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned States
    **/
    count?: true | StatesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: StatesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: StatesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: StatesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: StatesMaxAggregateInputType
  }

  export type GetStatesAggregateType<T extends StatesAggregateArgs> = {
    [P in keyof T & keyof AggregateStates]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStates[P]>
      : GetScalarType<T[P], AggregateStates[P]>
  }



  export type StatesSelect = {
    id?: boolean
    country_id?: boolean
    name?: boolean
    state_code?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    created_by?: boolean
    updated_by?: boolean
    Countries?: boolean | CountriesArgs
    Cities?: boolean | CitiesFindManyArgs
  }

  export type StatesInclude = {
    Countries?: boolean | CountriesArgs
    Cities?: boolean | CitiesFindManyArgs
  }

  export type StatesGetPayload<
    S extends boolean | null | undefined | StatesArgs,
    U = keyof S
      > = S extends true
        ? States
    : S extends undefined
    ? never
    : S extends StatesArgs | StatesFindManyArgs
    ?'include' extends U
    ? States  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'Countries'
        ? CountriesGetPayload<S['include'][P]> :
        P extends 'Cities'
        ? Array < CitiesGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof States ?States [P]
  : 
          P extends 'Countries'
        ? CountriesGetPayload<S['select'][P]> :
        P extends 'Cities'
        ? Array < CitiesGetPayload<S['select'][P]>>  : never
  } 
    : States
  : States


  type StatesCountArgs = Merge<
    Omit<StatesFindManyArgs, 'select' | 'include'> & {
      select?: StatesCountAggregateInputType | true
    }
  >

  export interface StatesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one States that matches the filter.
     * @param {StatesFindUniqueArgs} args - Arguments to find a States
     * @example
     * // Get one States
     * const states = await prisma.states.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StatesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, StatesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'States'> extends True ? CheckSelect<T, Prisma__StatesClient<States>, Prisma__StatesClient<StatesGetPayload<T>>> : CheckSelect<T, Prisma__StatesClient<States | null >, Prisma__StatesClient<StatesGetPayload<T> | null >>

    /**
     * Find the first States that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatesFindFirstArgs} args - Arguments to find a States
     * @example
     * // Get one States
     * const states = await prisma.states.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StatesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, StatesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'States'> extends True ? CheckSelect<T, Prisma__StatesClient<States>, Prisma__StatesClient<StatesGetPayload<T>>> : CheckSelect<T, Prisma__StatesClient<States | null >, Prisma__StatesClient<StatesGetPayload<T> | null >>

    /**
     * Find zero or more States that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all States
     * const states = await prisma.states.findMany()
     * 
     * // Get first 10 States
     * const states = await prisma.states.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const statesWithIdOnly = await prisma.states.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends StatesFindManyArgs>(
      args?: SelectSubset<T, StatesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<States>>, PrismaPromise<Array<StatesGetPayload<T>>>>

    /**
     * Create a States.
     * @param {StatesCreateArgs} args - Arguments to create a States.
     * @example
     * // Create one States
     * const States = await prisma.states.create({
     *   data: {
     *     // ... data to create a States
     *   }
     * })
     * 
    **/
    create<T extends StatesCreateArgs>(
      args: SelectSubset<T, StatesCreateArgs>
    ): CheckSelect<T, Prisma__StatesClient<States>, Prisma__StatesClient<StatesGetPayload<T>>>

    /**
     * Delete a States.
     * @param {StatesDeleteArgs} args - Arguments to delete one States.
     * @example
     * // Delete one States
     * const States = await prisma.states.delete({
     *   where: {
     *     // ... filter to delete one States
     *   }
     * })
     * 
    **/
    delete<T extends StatesDeleteArgs>(
      args: SelectSubset<T, StatesDeleteArgs>
    ): CheckSelect<T, Prisma__StatesClient<States>, Prisma__StatesClient<StatesGetPayload<T>>>

    /**
     * Update one States.
     * @param {StatesUpdateArgs} args - Arguments to update one States.
     * @example
     * // Update one States
     * const states = await prisma.states.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StatesUpdateArgs>(
      args: SelectSubset<T, StatesUpdateArgs>
    ): CheckSelect<T, Prisma__StatesClient<States>, Prisma__StatesClient<StatesGetPayload<T>>>

    /**
     * Delete zero or more States.
     * @param {StatesDeleteManyArgs} args - Arguments to filter States to delete.
     * @example
     * // Delete a few States
     * const { count } = await prisma.states.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StatesDeleteManyArgs>(
      args?: SelectSubset<T, StatesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more States.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many States
     * const states = await prisma.states.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StatesUpdateManyArgs>(
      args: SelectSubset<T, StatesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one States.
     * @param {StatesUpsertArgs} args - Arguments to update or create a States.
     * @example
     * // Update or create a States
     * const states = await prisma.states.upsert({
     *   create: {
     *     // ... data to create a States
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the States we want to update
     *   }
     * })
    **/
    upsert<T extends StatesUpsertArgs>(
      args: SelectSubset<T, StatesUpsertArgs>
    ): CheckSelect<T, Prisma__StatesClient<States>, Prisma__StatesClient<StatesGetPayload<T>>>

    /**
     * Count the number of States.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatesCountArgs} args - Arguments to filter States to count.
     * @example
     * // Count the number of States
     * const count = await prisma.states.count({
     *   where: {
     *     // ... the filter for the States we want to count
     *   }
     * })
    **/
    count<T extends StatesCountArgs>(
      args?: Subset<T, StatesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StatesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a States.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StatesAggregateArgs>(args: Subset<T, StatesAggregateArgs>): PrismaPromise<GetStatesAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for States.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__StatesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Countries<T extends CountriesArgs = {}>(args?: Subset<T, CountriesArgs>): CheckSelect<T, Prisma__CountriesClient<Countries | null >, Prisma__CountriesClient<CountriesGetPayload<T> | null >>;

    Cities<T extends CitiesFindManyArgs = {}>(args?: Subset<T, CitiesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Cities>>, PrismaPromise<Array<CitiesGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * States findUnique
   */
  export type StatesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the States
    **/
    select?: StatesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: StatesInclude | null
    /**
     * Throw an Error if a States can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which States to fetch.
    **/
    where: StatesWhereUniqueInput
  }


  /**
   * States findFirst
   */
  export type StatesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the States
    **/
    select?: StatesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: StatesInclude | null
    /**
     * Throw an Error if a States can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which States to fetch.
    **/
    where?: StatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of States to fetch.
    **/
    orderBy?: Enumerable<StatesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for States.
    **/
    cursor?: StatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` States from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` States.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of States.
    **/
    distinct?: Enumerable<StatesScalarFieldEnum>
  }


  /**
   * States findMany
   */
  export type StatesFindManyArgs = {
    /**
     * Select specific fields to fetch from the States
    **/
    select?: StatesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: StatesInclude | null
    /**
     * Filter, which States to fetch.
    **/
    where?: StatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of States to fetch.
    **/
    orderBy?: Enumerable<StatesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing States.
    **/
    cursor?: StatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` States from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` States.
    **/
    skip?: number
    distinct?: Enumerable<StatesScalarFieldEnum>
  }


  /**
   * States create
   */
  export type StatesCreateArgs = {
    /**
     * Select specific fields to fetch from the States
    **/
    select?: StatesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: StatesInclude | null
    /**
     * The data needed to create a States.
    **/
    data: XOR<StatesCreateInput, StatesUncheckedCreateInput>
  }


  /**
   * States update
   */
  export type StatesUpdateArgs = {
    /**
     * Select specific fields to fetch from the States
    **/
    select?: StatesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: StatesInclude | null
    /**
     * The data needed to update a States.
    **/
    data: XOR<StatesUpdateInput, StatesUncheckedUpdateInput>
    /**
     * Choose, which States to update.
    **/
    where: StatesWhereUniqueInput
  }


  /**
   * States updateMany
   */
  export type StatesUpdateManyArgs = {
    data: XOR<StatesUpdateManyMutationInput, StatesUncheckedUpdateManyInput>
    where?: StatesWhereInput
  }


  /**
   * States upsert
   */
  export type StatesUpsertArgs = {
    /**
     * Select specific fields to fetch from the States
    **/
    select?: StatesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: StatesInclude | null
    /**
     * The filter to search for the States to update in case it exists.
    **/
    where: StatesWhereUniqueInput
    /**
     * In case the States found by the `where` argument doesn't exist, create a new States with this data.
    **/
    create: XOR<StatesCreateInput, StatesUncheckedCreateInput>
    /**
     * In case the States was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<StatesUpdateInput, StatesUncheckedUpdateInput>
  }


  /**
   * States delete
   */
  export type StatesDeleteArgs = {
    /**
     * Select specific fields to fetch from the States
    **/
    select?: StatesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: StatesInclude | null
    /**
     * Filter which States to delete.
    **/
    where: StatesWhereUniqueInput
  }


  /**
   * States deleteMany
   */
  export type StatesDeleteManyArgs = {
    where?: StatesWhereInput
  }


  /**
   * States without action
   */
  export type StatesArgs = {
    /**
     * Select specific fields to fetch from the States
    **/
    select?: StatesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: StatesInclude | null
  }



  /**
   * Model UnitLocations
   */


  export type AggregateUnitLocations = {
    count: UnitLocationsCountAggregateOutputType | null
    avg: UnitLocationsAvgAggregateOutputType | null
    sum: UnitLocationsSumAggregateOutputType | null
    min: UnitLocationsMinAggregateOutputType | null
    max: UnitLocationsMaxAggregateOutputType | null
  }

  export type UnitLocationsAvgAggregateOutputType = {
    id: number
    property_sub_type_id: number
    property_level_id: number
    property_unit_id: number
    created_by: number | null
    updated_by: number | null
  }

  export type UnitLocationsSumAggregateOutputType = {
    id: number
    property_sub_type_id: number
    property_level_id: number
    property_unit_id: number
    created_by: number | null
    updated_by: number | null
  }

  export type UnitLocationsMinAggregateOutputType = {
    id: number
    unit_name: string | null
    property_sub_type_id: number
    property_level_id: number
    property_unit_id: number
    created_at: Date | null
    updated_at: Date | null
    created_by: number | null
    updated_by: number | null
  }

  export type UnitLocationsMaxAggregateOutputType = {
    id: number
    unit_name: string | null
    property_sub_type_id: number
    property_level_id: number
    property_unit_id: number
    created_at: Date | null
    updated_at: Date | null
    created_by: number | null
    updated_by: number | null
  }

  export type UnitLocationsCountAggregateOutputType = {
    id: number
    unit_name: number | null
    property_sub_type_id: number
    property_level_id: number
    property_unit_id: number
    created_at: number | null
    updated_at: number | null
    created_by: number | null
    updated_by: number | null
    _all: number
  }


  export type UnitLocationsAvgAggregateInputType = {
    id?: true
    property_sub_type_id?: true
    property_level_id?: true
    property_unit_id?: true
    created_by?: true
    updated_by?: true
  }

  export type UnitLocationsSumAggregateInputType = {
    id?: true
    property_sub_type_id?: true
    property_level_id?: true
    property_unit_id?: true
    created_by?: true
    updated_by?: true
  }

  export type UnitLocationsMinAggregateInputType = {
    id?: true
    unit_name?: true
    property_sub_type_id?: true
    property_level_id?: true
    property_unit_id?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type UnitLocationsMaxAggregateInputType = {
    id?: true
    unit_name?: true
    property_sub_type_id?: true
    property_level_id?: true
    property_unit_id?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
  }

  export type UnitLocationsCountAggregateInputType = {
    id?: true
    unit_name?: true
    property_sub_type_id?: true
    property_level_id?: true
    property_unit_id?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
    _all?: true
  }

  export type UnitLocationsAggregateArgs = {
    /**
     * Filter which UnitLocations to aggregate.
    **/
    where?: UnitLocationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitLocations to fetch.
    **/
    orderBy?: Enumerable<UnitLocationsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: UnitLocationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitLocations from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitLocations.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UnitLocations
    **/
    count?: true | UnitLocationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: UnitLocationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: UnitLocationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: UnitLocationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: UnitLocationsMaxAggregateInputType
  }

  export type GetUnitLocationsAggregateType<T extends UnitLocationsAggregateArgs> = {
    [P in keyof T & keyof AggregateUnitLocations]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnitLocations[P]>
      : GetScalarType<T[P], AggregateUnitLocations[P]>
  }



  export type UnitLocationsSelect = {
    id?: boolean
    unit_name?: boolean
    property_sub_type_id?: boolean
    property_level_id?: boolean
    property_unit_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    created_by?: boolean
    updated_by?: boolean
    PropertyLevels?: boolean | PropertyLevelsArgs
    PropertySubTypes?: boolean | PropertySubTypesArgs
    PropertyUnits?: boolean | PropertyUnitsArgs
    AreaOfWorks?: boolean | AreaOfWorksFindManyArgs
  }

  export type UnitLocationsInclude = {
    PropertyLevels?: boolean | PropertyLevelsArgs
    PropertySubTypes?: boolean | PropertySubTypesArgs
    PropertyUnits?: boolean | PropertyUnitsArgs
    AreaOfWorks?: boolean | AreaOfWorksFindManyArgs
  }

  export type UnitLocationsGetPayload<
    S extends boolean | null | undefined | UnitLocationsArgs,
    U = keyof S
      > = S extends true
        ? UnitLocations
    : S extends undefined
    ? never
    : S extends UnitLocationsArgs | UnitLocationsFindManyArgs
    ?'include' extends U
    ? UnitLocations  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'PropertyLevels'
        ? PropertyLevelsGetPayload<S['include'][P]> :
        P extends 'PropertySubTypes'
        ? PropertySubTypesGetPayload<S['include'][P]> :
        P extends 'PropertyUnits'
        ? PropertyUnitsGetPayload<S['include'][P]> :
        P extends 'AreaOfWorks'
        ? Array < AreaOfWorksGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof UnitLocations ?UnitLocations [P]
  : 
          P extends 'PropertyLevels'
        ? PropertyLevelsGetPayload<S['select'][P]> :
        P extends 'PropertySubTypes'
        ? PropertySubTypesGetPayload<S['select'][P]> :
        P extends 'PropertyUnits'
        ? PropertyUnitsGetPayload<S['select'][P]> :
        P extends 'AreaOfWorks'
        ? Array < AreaOfWorksGetPayload<S['select'][P]>>  : never
  } 
    : UnitLocations
  : UnitLocations


  type UnitLocationsCountArgs = Merge<
    Omit<UnitLocationsFindManyArgs, 'select' | 'include'> & {
      select?: UnitLocationsCountAggregateInputType | true
    }
  >

  export interface UnitLocationsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one UnitLocations that matches the filter.
     * @param {UnitLocationsFindUniqueArgs} args - Arguments to find a UnitLocations
     * @example
     * // Get one UnitLocations
     * const unitLocations = await prisma.unitLocations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UnitLocationsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UnitLocationsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UnitLocations'> extends True ? CheckSelect<T, Prisma__UnitLocationsClient<UnitLocations>, Prisma__UnitLocationsClient<UnitLocationsGetPayload<T>>> : CheckSelect<T, Prisma__UnitLocationsClient<UnitLocations | null >, Prisma__UnitLocationsClient<UnitLocationsGetPayload<T> | null >>

    /**
     * Find the first UnitLocations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitLocationsFindFirstArgs} args - Arguments to find a UnitLocations
     * @example
     * // Get one UnitLocations
     * const unitLocations = await prisma.unitLocations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UnitLocationsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UnitLocationsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UnitLocations'> extends True ? CheckSelect<T, Prisma__UnitLocationsClient<UnitLocations>, Prisma__UnitLocationsClient<UnitLocationsGetPayload<T>>> : CheckSelect<T, Prisma__UnitLocationsClient<UnitLocations | null >, Prisma__UnitLocationsClient<UnitLocationsGetPayload<T> | null >>

    /**
     * Find zero or more UnitLocations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitLocationsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UnitLocations
     * const unitLocations = await prisma.unitLocations.findMany()
     * 
     * // Get first 10 UnitLocations
     * const unitLocations = await prisma.unitLocations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const unitLocationsWithIdOnly = await prisma.unitLocations.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UnitLocationsFindManyArgs>(
      args?: SelectSubset<T, UnitLocationsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<UnitLocations>>, PrismaPromise<Array<UnitLocationsGetPayload<T>>>>

    /**
     * Create a UnitLocations.
     * @param {UnitLocationsCreateArgs} args - Arguments to create a UnitLocations.
     * @example
     * // Create one UnitLocations
     * const UnitLocations = await prisma.unitLocations.create({
     *   data: {
     *     // ... data to create a UnitLocations
     *   }
     * })
     * 
    **/
    create<T extends UnitLocationsCreateArgs>(
      args: SelectSubset<T, UnitLocationsCreateArgs>
    ): CheckSelect<T, Prisma__UnitLocationsClient<UnitLocations>, Prisma__UnitLocationsClient<UnitLocationsGetPayload<T>>>

    /**
     * Delete a UnitLocations.
     * @param {UnitLocationsDeleteArgs} args - Arguments to delete one UnitLocations.
     * @example
     * // Delete one UnitLocations
     * const UnitLocations = await prisma.unitLocations.delete({
     *   where: {
     *     // ... filter to delete one UnitLocations
     *   }
     * })
     * 
    **/
    delete<T extends UnitLocationsDeleteArgs>(
      args: SelectSubset<T, UnitLocationsDeleteArgs>
    ): CheckSelect<T, Prisma__UnitLocationsClient<UnitLocations>, Prisma__UnitLocationsClient<UnitLocationsGetPayload<T>>>

    /**
     * Update one UnitLocations.
     * @param {UnitLocationsUpdateArgs} args - Arguments to update one UnitLocations.
     * @example
     * // Update one UnitLocations
     * const unitLocations = await prisma.unitLocations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UnitLocationsUpdateArgs>(
      args: SelectSubset<T, UnitLocationsUpdateArgs>
    ): CheckSelect<T, Prisma__UnitLocationsClient<UnitLocations>, Prisma__UnitLocationsClient<UnitLocationsGetPayload<T>>>

    /**
     * Delete zero or more UnitLocations.
     * @param {UnitLocationsDeleteManyArgs} args - Arguments to filter UnitLocations to delete.
     * @example
     * // Delete a few UnitLocations
     * const { count } = await prisma.unitLocations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UnitLocationsDeleteManyArgs>(
      args?: SelectSubset<T, UnitLocationsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more UnitLocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitLocationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UnitLocations
     * const unitLocations = await prisma.unitLocations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UnitLocationsUpdateManyArgs>(
      args: SelectSubset<T, UnitLocationsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one UnitLocations.
     * @param {UnitLocationsUpsertArgs} args - Arguments to update or create a UnitLocations.
     * @example
     * // Update or create a UnitLocations
     * const unitLocations = await prisma.unitLocations.upsert({
     *   create: {
     *     // ... data to create a UnitLocations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UnitLocations we want to update
     *   }
     * })
    **/
    upsert<T extends UnitLocationsUpsertArgs>(
      args: SelectSubset<T, UnitLocationsUpsertArgs>
    ): CheckSelect<T, Prisma__UnitLocationsClient<UnitLocations>, Prisma__UnitLocationsClient<UnitLocationsGetPayload<T>>>

    /**
     * Count the number of UnitLocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitLocationsCountArgs} args - Arguments to filter UnitLocations to count.
     * @example
     * // Count the number of UnitLocations
     * const count = await prisma.unitLocations.count({
     *   where: {
     *     // ... the filter for the UnitLocations we want to count
     *   }
     * })
    **/
    count<T extends UnitLocationsCountArgs>(
      args?: Subset<T, UnitLocationsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UnitLocationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UnitLocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitLocationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UnitLocationsAggregateArgs>(args: Subset<T, UnitLocationsAggregateArgs>): PrismaPromise<GetUnitLocationsAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for UnitLocations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UnitLocationsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    PropertyLevels<T extends PropertyLevelsArgs = {}>(args?: Subset<T, PropertyLevelsArgs>): CheckSelect<T, Prisma__PropertyLevelsClient<PropertyLevels | null >, Prisma__PropertyLevelsClient<PropertyLevelsGetPayload<T> | null >>;

    PropertySubTypes<T extends PropertySubTypesArgs = {}>(args?: Subset<T, PropertySubTypesArgs>): CheckSelect<T, Prisma__PropertySubTypesClient<PropertySubTypes | null >, Prisma__PropertySubTypesClient<PropertySubTypesGetPayload<T> | null >>;

    PropertyUnits<T extends PropertyUnitsArgs = {}>(args?: Subset<T, PropertyUnitsArgs>): CheckSelect<T, Prisma__PropertyUnitsClient<PropertyUnits | null >, Prisma__PropertyUnitsClient<PropertyUnitsGetPayload<T> | null >>;

    AreaOfWorks<T extends AreaOfWorksFindManyArgs = {}>(args?: Subset<T, AreaOfWorksFindManyArgs>): CheckSelect<T, PrismaPromise<Array<AreaOfWorks>>, PrismaPromise<Array<AreaOfWorksGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * UnitLocations findUnique
   */
  export type UnitLocationsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the UnitLocations
    **/
    select?: UnitLocationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UnitLocationsInclude | null
    /**
     * Throw an Error if a UnitLocations can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UnitLocations to fetch.
    **/
    where: UnitLocationsWhereUniqueInput
  }


  /**
   * UnitLocations findFirst
   */
  export type UnitLocationsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the UnitLocations
    **/
    select?: UnitLocationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UnitLocationsInclude | null
    /**
     * Throw an Error if a UnitLocations can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UnitLocations to fetch.
    **/
    where?: UnitLocationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitLocations to fetch.
    **/
    orderBy?: Enumerable<UnitLocationsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnitLocations.
    **/
    cursor?: UnitLocationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitLocations from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitLocations.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnitLocations.
    **/
    distinct?: Enumerable<UnitLocationsScalarFieldEnum>
  }


  /**
   * UnitLocations findMany
   */
  export type UnitLocationsFindManyArgs = {
    /**
     * Select specific fields to fetch from the UnitLocations
    **/
    select?: UnitLocationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UnitLocationsInclude | null
    /**
     * Filter, which UnitLocations to fetch.
    **/
    where?: UnitLocationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitLocations to fetch.
    **/
    orderBy?: Enumerable<UnitLocationsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UnitLocations.
    **/
    cursor?: UnitLocationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitLocations from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitLocations.
    **/
    skip?: number
    distinct?: Enumerable<UnitLocationsScalarFieldEnum>
  }


  /**
   * UnitLocations create
   */
  export type UnitLocationsCreateArgs = {
    /**
     * Select specific fields to fetch from the UnitLocations
    **/
    select?: UnitLocationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UnitLocationsInclude | null
    /**
     * The data needed to create a UnitLocations.
    **/
    data: XOR<UnitLocationsCreateInput, UnitLocationsUncheckedCreateInput>
  }


  /**
   * UnitLocations update
   */
  export type UnitLocationsUpdateArgs = {
    /**
     * Select specific fields to fetch from the UnitLocations
    **/
    select?: UnitLocationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UnitLocationsInclude | null
    /**
     * The data needed to update a UnitLocations.
    **/
    data: XOR<UnitLocationsUpdateInput, UnitLocationsUncheckedUpdateInput>
    /**
     * Choose, which UnitLocations to update.
    **/
    where: UnitLocationsWhereUniqueInput
  }


  /**
   * UnitLocations updateMany
   */
  export type UnitLocationsUpdateManyArgs = {
    data: XOR<UnitLocationsUpdateManyMutationInput, UnitLocationsUncheckedUpdateManyInput>
    where?: UnitLocationsWhereInput
  }


  /**
   * UnitLocations upsert
   */
  export type UnitLocationsUpsertArgs = {
    /**
     * Select specific fields to fetch from the UnitLocations
    **/
    select?: UnitLocationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UnitLocationsInclude | null
    /**
     * The filter to search for the UnitLocations to update in case it exists.
    **/
    where: UnitLocationsWhereUniqueInput
    /**
     * In case the UnitLocations found by the `where` argument doesn't exist, create a new UnitLocations with this data.
    **/
    create: XOR<UnitLocationsCreateInput, UnitLocationsUncheckedCreateInput>
    /**
     * In case the UnitLocations was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<UnitLocationsUpdateInput, UnitLocationsUncheckedUpdateInput>
  }


  /**
   * UnitLocations delete
   */
  export type UnitLocationsDeleteArgs = {
    /**
     * Select specific fields to fetch from the UnitLocations
    **/
    select?: UnitLocationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UnitLocationsInclude | null
    /**
     * Filter which UnitLocations to delete.
    **/
    where: UnitLocationsWhereUniqueInput
  }


  /**
   * UnitLocations deleteMany
   */
  export type UnitLocationsDeleteManyArgs = {
    where?: UnitLocationsWhereInput
  }


  /**
   * UnitLocations without action
   */
  export type UnitLocationsArgs = {
    /**
     * Select specific fields to fetch from the UnitLocations
    **/
    select?: UnitLocationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UnitLocationsInclude | null
  }



  /**
   * Model Users
   */


  export type AggregateUsers = {
    count: UsersCountAggregateOutputType | null
    avg: UsersAvgAggregateOutputType | null
    sum: UsersSumAggregateOutputType | null
    min: UsersMinAggregateOutputType | null
    max: UsersMaxAggregateOutputType | null
  }

  export type UsersAvgAggregateOutputType = {
    id: number
    created_by: number | null
    updated_by: number | null
  }

  export type UsersSumAggregateOutputType = {
    id: number
    created_by: number | null
    updated_by: number | null
  }

  export type UsersMinAggregateOutputType = {
    id: number
    user_type: string | null
    email: string | null
    status: boolean | null
    created_at: Date | null
    updated_at: Date | null
    created_by: number | null
    updated_by: number | null
    username: string | null
    email_verified: boolean | null
    name: string | null
  }

  export type UsersMaxAggregateOutputType = {
    id: number
    user_type: string | null
    email: string | null
    status: boolean | null
    created_at: Date | null
    updated_at: Date | null
    created_by: number | null
    updated_by: number | null
    username: string | null
    email_verified: boolean | null
    name: string | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    user_type: number | null
    email: number | null
    status: number | null
    created_at: number | null
    updated_at: number | null
    created_by: number | null
    updated_by: number | null
    username: number | null
    email_verified: number | null
    name: number | null
    _all: number
  }


  export type UsersAvgAggregateInputType = {
    id?: true
    created_by?: true
    updated_by?: true
  }

  export type UsersSumAggregateInputType = {
    id?: true
    created_by?: true
    updated_by?: true
  }

  export type UsersMinAggregateInputType = {
    id?: true
    user_type?: true
    email?: true
    status?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
    username?: true
    email_verified?: true
    name?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    user_type?: true
    email?: true
    status?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
    username?: true
    email_verified?: true
    name?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    user_type?: true
    email?: true
    status?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    updated_by?: true
    username?: true
    email_verified?: true
    name?: true
    _all?: true
  }

  export type UsersAggregateArgs = {
    /**
     * Filter which Users to aggregate.
    **/
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
    **/
    orderBy?: Enumerable<UsersOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: UsersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: UsersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
    [P in keyof T & keyof AggregateUsers]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }



  export type UsersSelect = {
    id?: boolean
    user_type?: boolean
    email?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    created_by?: boolean
    updated_by?: boolean
    username?: boolean
    email_verified?: boolean
    name?: boolean
    Backend_Users?: boolean | Backend_UsersFindManyArgs
    Contractors?: boolean | ContractorsFindManyArgs
    PropertyOwners?: boolean | PropertyOwnersFindManyArgs
  }

  export type UsersInclude = {
    Backend_Users?: boolean | Backend_UsersFindManyArgs
    Contractors?: boolean | ContractorsFindManyArgs
    PropertyOwners?: boolean | PropertyOwnersFindManyArgs
  }

  export type UsersGetPayload<
    S extends boolean | null | undefined | UsersArgs,
    U = keyof S
      > = S extends true
        ? Users
    : S extends undefined
    ? never
    : S extends UsersArgs | UsersFindManyArgs
    ?'include' extends U
    ? Users  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'Backend_Users'
        ? Array < Backend_UsersGetPayload<S['include'][P]>>  :
        P extends 'Contractors'
        ? Array < ContractorsGetPayload<S['include'][P]>>  :
        P extends 'PropertyOwners'
        ? Array < PropertyOwnersGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Users ?Users [P]
  : 
          P extends 'Backend_Users'
        ? Array < Backend_UsersGetPayload<S['select'][P]>>  :
        P extends 'Contractors'
        ? Array < ContractorsGetPayload<S['select'][P]>>  :
        P extends 'PropertyOwners'
        ? Array < PropertyOwnersGetPayload<S['select'][P]>>  : never
  } 
    : Users
  : Users


  type UsersCountArgs = Merge<
    Omit<UsersFindManyArgs, 'select' | 'include'> & {
      select?: UsersCountAggregateInputType | true
    }
  >

  export interface UsersDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Users that matches the filter.
     * @param {UsersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UsersFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UsersFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Users'> extends True ? CheckSelect<T, Prisma__UsersClient<Users>, Prisma__UsersClient<UsersGetPayload<T>>> : CheckSelect<T, Prisma__UsersClient<Users | null >, Prisma__UsersClient<UsersGetPayload<T> | null >>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UsersFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UsersFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Users'> extends True ? CheckSelect<T, Prisma__UsersClient<Users>, Prisma__UsersClient<UsersGetPayload<T>>> : CheckSelect<T, Prisma__UsersClient<Users | null >, Prisma__UsersClient<UsersGetPayload<T> | null >>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UsersFindManyArgs>(
      args?: SelectSubset<T, UsersFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Users>>, PrismaPromise<Array<UsersGetPayload<T>>>>

    /**
     * Create a Users.
     * @param {UsersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
    **/
    create<T extends UsersCreateArgs>(
      args: SelectSubset<T, UsersCreateArgs>
    ): CheckSelect<T, Prisma__UsersClient<Users>, Prisma__UsersClient<UsersGetPayload<T>>>

    /**
     * Delete a Users.
     * @param {UsersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
    **/
    delete<T extends UsersDeleteArgs>(
      args: SelectSubset<T, UsersDeleteArgs>
    ): CheckSelect<T, Prisma__UsersClient<Users>, Prisma__UsersClient<UsersGetPayload<T>>>

    /**
     * Update one Users.
     * @param {UsersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UsersUpdateArgs>(
      args: SelectSubset<T, UsersUpdateArgs>
    ): CheckSelect<T, Prisma__UsersClient<Users>, Prisma__UsersClient<UsersGetPayload<T>>>

    /**
     * Delete zero or more Users.
     * @param {UsersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UsersDeleteManyArgs>(
      args?: SelectSubset<T, UsersDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UsersUpdateManyArgs>(
      args: SelectSubset<T, UsersUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Users.
     * @param {UsersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
    **/
    upsert<T extends UsersUpsertArgs>(
      args: SelectSubset<T, UsersUpsertArgs>
    ): CheckSelect<T, Prisma__UsersClient<Users>, Prisma__UsersClient<UsersGetPayload<T>>>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UsersCountArgs>(
      args?: Subset<T, UsersCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): PrismaPromise<GetUsersAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for Users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UsersClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Backend_Users<T extends Backend_UsersFindManyArgs = {}>(args?: Subset<T, Backend_UsersFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Backend_Users>>, PrismaPromise<Array<Backend_UsersGetPayload<T>>>>;

    Contractors<T extends ContractorsFindManyArgs = {}>(args?: Subset<T, ContractorsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Contractors>>, PrismaPromise<Array<ContractorsGetPayload<T>>>>;

    PropertyOwners<T extends PropertyOwnersFindManyArgs = {}>(args?: Subset<T, PropertyOwnersFindManyArgs>): CheckSelect<T, PrismaPromise<Array<PropertyOwners>>, PrismaPromise<Array<PropertyOwnersGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Users findUnique
   */
  export type UsersFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Users
    **/
    select?: UsersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UsersInclude | null
    /**
     * Throw an Error if a Users can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Users to fetch.
    **/
    where: UsersWhereUniqueInput
  }


  /**
   * Users findFirst
   */
  export type UsersFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Users
    **/
    select?: UsersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UsersInclude | null
    /**
     * Throw an Error if a Users can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Users to fetch.
    **/
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
    **/
    orderBy?: Enumerable<UsersOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
    **/
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
    **/
    distinct?: Enumerable<UsersScalarFieldEnum>
  }


  /**
   * Users findMany
   */
  export type UsersFindManyArgs = {
    /**
     * Select specific fields to fetch from the Users
    **/
    select?: UsersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UsersInclude | null
    /**
     * Filter, which Users to fetch.
    **/
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
    **/
    orderBy?: Enumerable<UsersOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
    **/
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
    **/
    skip?: number
    distinct?: Enumerable<UsersScalarFieldEnum>
  }


  /**
   * Users create
   */
  export type UsersCreateArgs = {
    /**
     * Select specific fields to fetch from the Users
    **/
    select?: UsersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UsersInclude | null
    /**
     * The data needed to create a Users.
    **/
    data: XOR<UsersCreateInput, UsersUncheckedCreateInput>
  }


  /**
   * Users update
   */
  export type UsersUpdateArgs = {
    /**
     * Select specific fields to fetch from the Users
    **/
    select?: UsersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UsersInclude | null
    /**
     * The data needed to update a Users.
    **/
    data: XOR<UsersUpdateInput, UsersUncheckedUpdateInput>
    /**
     * Choose, which Users to update.
    **/
    where: UsersWhereUniqueInput
  }


  /**
   * Users updateMany
   */
  export type UsersUpdateManyArgs = {
    data: XOR<UsersUpdateManyMutationInput, UsersUncheckedUpdateManyInput>
    where?: UsersWhereInput
  }


  /**
   * Users upsert
   */
  export type UsersUpsertArgs = {
    /**
     * Select specific fields to fetch from the Users
    **/
    select?: UsersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UsersInclude | null
    /**
     * The filter to search for the Users to update in case it exists.
    **/
    where: UsersWhereUniqueInput
    /**
     * In case the Users found by the `where` argument doesn't exist, create a new Users with this data.
    **/
    create: XOR<UsersCreateInput, UsersUncheckedCreateInput>
    /**
     * In case the Users was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<UsersUpdateInput, UsersUncheckedUpdateInput>
  }


  /**
   * Users delete
   */
  export type UsersDeleteArgs = {
    /**
     * Select specific fields to fetch from the Users
    **/
    select?: UsersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UsersInclude | null
    /**
     * Filter which Users to delete.
    **/
    where: UsersWhereUniqueInput
  }


  /**
   * Users deleteMany
   */
  export type UsersDeleteManyArgs = {
    where?: UsersWhereInput
  }


  /**
   * Users without action
   */
  export type UsersArgs = {
    /**
     * Select specific fields to fetch from the Users
    **/
    select?: UsersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UsersInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const AreaOfWorksScalarFieldEnum: {
    id: 'id',
    project_proposal_id: 'project_proposal_id',
    unit_location_id: 'unit_location_id',
    new_unit: 'new_unit',
    existing_unit: 'existing_unit',
    unit_alias: 'unit_alias',
    work_type: 'work_type',
    created_at: 'created_at',
    updated_at: 'updated_at',
    created_by: 'created_by',
    updated_by: 'updated_by'
  };

  export type AreaOfWorksScalarFieldEnum = (typeof AreaOfWorksScalarFieldEnum)[keyof typeof AreaOfWorksScalarFieldEnum]


  export const AttributesScalarFieldEnum: {
    id: 'id',
    parent_id: 'parent_id',
    name: 'name',
    slug: 'slug',
    created_at: 'created_at',
    updated_at: 'updated_at',
    created_by: 'created_by',
    updated_by: 'updated_by'
  };

  export type AttributesScalarFieldEnum = (typeof AttributesScalarFieldEnum)[keyof typeof AttributesScalarFieldEnum]


  export const AttributeUnitsScalarFieldEnum: {
    id: 'id',
    attribute_parent_id: 'attribute_parent_id',
    unit_name: 'unit_name',
    slug: 'slug',
    created_at: 'created_at',
    updated_at: 'updated_at',
    created_by: 'created_by',
    updated_by: 'updated_by'
  };

  export type AttributeUnitsScalarFieldEnum = (typeof AttributeUnitsScalarFieldEnum)[keyof typeof AttributeUnitsScalarFieldEnum]


  export const Backend_UsersScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    first_name: 'first_name',
    last_name: 'last_name',
    created_at: 'created_at',
    updated_at: 'updated_at',
    created_by: 'created_by',
    updated_by: 'updated_by'
  };

  export type Backend_UsersScalarFieldEnum = (typeof Backend_UsersScalarFieldEnum)[keyof typeof Backend_UsersScalarFieldEnum]


  export const CitiesScalarFieldEnum: {
    id: 'id',
    state_id: 'state_id',
    name: 'name',
    status: 'status',
    created_at: 'created_at',
    updated_at: 'updated_at',
    created_by: 'created_by',
    updated_by: 'updated_by'
  };

  export type CitiesScalarFieldEnum = (typeof CitiesScalarFieldEnum)[keyof typeof CitiesScalarFieldEnum]


  export const ContractorsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    first_name: 'first_name',
    last_name: 'last_name',
    mobile: 'mobile',
    company_name: 'company_name',
    created_at: 'created_at',
    updated_at: 'updated_at',
    created_by: 'created_by',
    updated_by: 'updated_by'
  };

  export type ContractorsScalarFieldEnum = (typeof ContractorsScalarFieldEnum)[keyof typeof ContractorsScalarFieldEnum]


  export const CountriesScalarFieldEnum: {
    id: 'id',
    country_name: 'country_name',
    country_code: 'country_code',
    iso3: 'iso3',
    phone_code: 'phone_code',
    status: 'status',
    created_at: 'created_at',
    updated_at: 'updated_at',
    created_by: 'created_by',
    updated_by: 'updated_by'
  };

  export type CountriesScalarFieldEnum = (typeof CountriesScalarFieldEnum)[keyof typeof CountriesScalarFieldEnum]


  export const ProductAttributeUnitsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    product_id: 'product_id',
    attribute_id: 'attribute_id',
    attribute_unit_id: 'attribute_unit_id',
    html_element_type: 'html_element_type',
    display_order: 'display_order',
    created_at: 'created_at',
    updated_at: 'updated_at',
    created_by: 'created_by',
    updated_by: 'updated_by'
  };

  export type ProductAttributeUnitsScalarFieldEnum = (typeof ProductAttributeUnitsScalarFieldEnum)[keyof typeof ProductAttributeUnitsScalarFieldEnum]


  export const ProductAttributeUnitValuesScalarFieldEnum: {
    id: 'id',
    value: 'value',
    slug: 'slug',
    product_attribute_unit_id: 'product_attribute_unit_id',
    custom: 'custom',
    custom_html_element_type: 'custom_html_element_type',
    is_default: 'is_default',
    created_at: 'created_at',
    updated_at: 'updated_at',
    created_by: 'created_by',
    updated_by: 'updated_by'
  };

  export type ProductAttributeUnitValuesScalarFieldEnum = (typeof ProductAttributeUnitValuesScalarFieldEnum)[keyof typeof ProductAttributeUnitValuesScalarFieldEnum]


  export const ProductCategoriesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    created_at: 'created_at',
    updated_at: 'updated_at',
    created_by: 'created_by',
    updated_by: 'updated_by'
  };

  export type ProductCategoriesScalarFieldEnum = (typeof ProductCategoriesScalarFieldEnum)[keyof typeof ProductCategoriesScalarFieldEnum]


  export const ProductPropertyUnitsScalarFieldEnum: {
    id: 'id',
    property_unit_id: 'property_unit_id',
    product_id: 'product_id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    created_by: 'created_by',
    updated_by: 'updated_by'
  };

  export type ProductPropertyUnitsScalarFieldEnum = (typeof ProductPropertyUnitsScalarFieldEnum)[keyof typeof ProductPropertyUnitsScalarFieldEnum]


  export const ProductsScalarFieldEnum: {
    id: 'id',
    parent_id: 'parent_id',
    name: 'name',
    slug: 'slug',
    created_at: 'created_at',
    updated_at: 'updated_at',
    created_by: 'created_by',
    updated_by: 'updated_by'
  };

  export type ProductsScalarFieldEnum = (typeof ProductsScalarFieldEnum)[keyof typeof ProductsScalarFieldEnum]


  export const ProjectProposalsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    project_id: 'project_id',
    proposal_status: 'proposal_status',
    created_at: 'created_at',
    updated_at: 'updated_at',
    created_by: 'created_by',
    updated_by: 'updated_by'
  };

  export type ProjectProposalsScalarFieldEnum = (typeof ProjectProposalsScalarFieldEnum)[keyof typeof ProjectProposalsScalarFieldEnum]


  export const ProjectsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    property_address_id: 'property_address_id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    created_by: 'created_by',
    updated_by: 'updated_by',
    start_date: 'start_date'
  };

  export type ProjectsScalarFieldEnum = (typeof ProjectsScalarFieldEnum)[keyof typeof ProjectsScalarFieldEnum]


  export const ProjectTypeAssociationsScalarFieldEnum: {
    id: 'id',
    project_id: 'project_id',
    project_type_id: 'project_type_id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    created_by: 'created_by',
    updated_by: 'updated_by'
  };

  export type ProjectTypeAssociationsScalarFieldEnum = (typeof ProjectTypeAssociationsScalarFieldEnum)[keyof typeof ProjectTypeAssociationsScalarFieldEnum]


  export const ProjectTypesScalarFieldEnum: {
    id: 'id',
    type: 'type',
    slug: 'slug',
    created_at: 'created_at',
    updated_at: 'updated_at',
    created_by: 'created_by',
    updated_by: 'updated_by'
  };

  export type ProjectTypesScalarFieldEnum = (typeof ProjectTypesScalarFieldEnum)[keyof typeof ProjectTypesScalarFieldEnum]


  export const PropertyLevelsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    created_at: 'created_at',
    updated_at: 'updated_at',
    created_by: 'created_by',
    updated_by: 'updated_by'
  };

  export type PropertyLevelsScalarFieldEnum = (typeof PropertyLevelsScalarFieldEnum)[keyof typeof PropertyLevelsScalarFieldEnum]


  export const PropertyOwnersScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    first_name: 'first_name',
    last_name: 'last_name',
    mobile: 'mobile',
    created_at: 'created_at',
    updated_at: 'updated_at',
    created_by: 'created_by',
    updated_by: 'updated_by'
  };

  export type PropertyOwnersScalarFieldEnum = (typeof PropertyOwnersScalarFieldEnum)[keyof typeof PropertyOwnersScalarFieldEnum]


  export const PropertySubTypesScalarFieldEnum: {
    id: 'id',
    property_type_id: 'property_type_id',
    name: 'name',
    slug: 'slug',
    created_at: 'created_at',
    updated_at: 'updated_at',
    created_by: 'created_by',
    updated_by: 'updated_by'
  };

  export type PropertySubTypesScalarFieldEnum = (typeof PropertySubTypesScalarFieldEnum)[keyof typeof PropertySubTypesScalarFieldEnum]


  export const PropertyUnitAttributesScalarFieldEnum: {
    id: 'id',
    property_unit_id: 'property_unit_id',
    attribute_id: 'attribute_id',
    attribute_unit_id: 'attribute_unit_id',
    html_element_type: 'html_element_type',
    display_order: 'display_order',
    created_at: 'created_at',
    updated_at: 'updated_at',
    created_by: 'created_by',
    updated_by: 'updated_by'
  };

  export type PropertyUnitAttributesScalarFieldEnum = (typeof PropertyUnitAttributesScalarFieldEnum)[keyof typeof PropertyUnitAttributesScalarFieldEnum]


  export const PropertyUnitProductCategoriesScalarFieldEnum: {
    id: 'id',
    property_unit_id: 'property_unit_id',
    product_category_id: 'product_category_id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    created_by: 'created_by',
    updated_by: 'updated_by'
  };

  export type PropertyUnitProductCategoriesScalarFieldEnum = (typeof PropertyUnitProductCategoriesScalarFieldEnum)[keyof typeof PropertyUnitProductCategoriesScalarFieldEnum]


  export const PropertyUnitProductCategoryProductsScalarFieldEnum: {
    id: 'id',
    property_unit_product_category_id: 'property_unit_product_category_id',
    product_id: 'product_id',
    display_order: 'display_order',
    created_at: 'created_at',
    updated_at: 'updated_at',
    created_by: 'created_by',
    updated_by: 'updated_by'
  };

  export type PropertyUnitProductCategoryProductsScalarFieldEnum = (typeof PropertyUnitProductCategoryProductsScalarFieldEnum)[keyof typeof PropertyUnitProductCategoryProductsScalarFieldEnum]


  export const PropertyUnitsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    created_at: 'created_at',
    updated_at: 'updated_at',
    created_by: 'created_by',
    updated_by: 'updated_by'
  };

  export type PropertyUnitsScalarFieldEnum = (typeof PropertyUnitsScalarFieldEnum)[keyof typeof PropertyUnitsScalarFieldEnum]


  export const Property_AddressesScalarFieldEnum: {
    id: 'id',
    street: 'street',
    property_owner_id: 'property_owner_id',
    city_id: 'city_id',
    property_sub_type_id: 'property_sub_type_id',
    postal_code: 'postal_code',
    construction_type: 'construction_type',
    withBasement: 'withBasement',
    storyId: 'storyId',
    created_at: 'created_at',
    updated_at: 'updated_at',
    created_by: 'created_by',
    updated_by: 'updated_by'
  };

  export type Property_AddressesScalarFieldEnum = (typeof Property_AddressesScalarFieldEnum)[keyof typeof Property_AddressesScalarFieldEnum]


  export const Property_TypesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    created_at: 'created_at',
    updated_at: 'updated_at',
    created_by: 'created_by',
    updated_by: 'updated_by'
  };

  export type Property_TypesScalarFieldEnum = (typeof Property_TypesScalarFieldEnum)[keyof typeof Property_TypesScalarFieldEnum]


  export const ScopeOfWorkPropertyUnitsScalarFieldEnum: {
    id: 'id',
    project_proposal_id: 'project_proposal_id',
    area_of_work_id: 'area_of_work_id',
    property_unit_attribute_id: 'property_unit_attribute_id',
    value: 'value',
    attribute_custom_name: 'attribute_custom_name',
    attribute_custom_value: 'attribute_custom_value',
    attribute_custom_unit: 'attribute_custom_unit',
    created_at: 'created_at',
    updated_at: 'updated_at',
    created_by: 'created_by',
    updated_by: 'updated_by'
  };

  export type ScopeOfWorkPropertyUnitsScalarFieldEnum = (typeof ScopeOfWorkPropertyUnitsScalarFieldEnum)[keyof typeof ScopeOfWorkPropertyUnitsScalarFieldEnum]


  export const ScopeOfWorksScalarFieldEnum: {
    id: 'id',
    project_proposal_id: 'project_proposal_id',
    area_of_work_id: 'area_of_work_id',
    product_attribute_unit_id: 'product_attribute_unit_id',
    product_attribute_unit_value_id: 'product_attribute_unit_value_id',
    attribute_custom_name: 'attribute_custom_name',
    attribute_custom_value: 'attribute_custom_value',
    attribute_custom_unit: 'attribute_custom_unit',
    created_at: 'created_at',
    updated_at: 'updated_at',
    created_by: 'created_by',
    updated_by: 'updated_by'
  };

  export type ScopeOfWorksScalarFieldEnum = (typeof ScopeOfWorksScalarFieldEnum)[keyof typeof ScopeOfWorksScalarFieldEnum]


  export const SequelizeMetaScalarFieldEnum: {
    name: 'name'
  };

  export type SequelizeMetaScalarFieldEnum = (typeof SequelizeMetaScalarFieldEnum)[keyof typeof SequelizeMetaScalarFieldEnum]


  export const StatesScalarFieldEnum: {
    id: 'id',
    country_id: 'country_id',
    name: 'name',
    state_code: 'state_code',
    status: 'status',
    created_at: 'created_at',
    updated_at: 'updated_at',
    created_by: 'created_by',
    updated_by: 'updated_by'
  };

  export type StatesScalarFieldEnum = (typeof StatesScalarFieldEnum)[keyof typeof StatesScalarFieldEnum]


  export const UnitLocationsScalarFieldEnum: {
    id: 'id',
    unit_name: 'unit_name',
    property_sub_type_id: 'property_sub_type_id',
    property_level_id: 'property_level_id',
    property_unit_id: 'property_unit_id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    created_by: 'created_by',
    updated_by: 'updated_by'
  };

  export type UnitLocationsScalarFieldEnum = (typeof UnitLocationsScalarFieldEnum)[keyof typeof UnitLocationsScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    id: 'id',
    user_type: 'user_type',
    email: 'email',
    status: 'status',
    created_at: 'created_at',
    updated_at: 'updated_at',
    created_by: 'created_by',
    updated_by: 'updated_by',
    username: 'username',
    email_verified: 'email_verified',
    name: 'name'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  /**
   * Deep Input Types
   */


  export type AreaOfWorksWhereInput = {
    AND?: Enumerable<AreaOfWorksWhereInput>
    OR?: Enumerable<AreaOfWorksWhereInput>
    NOT?: Enumerable<AreaOfWorksWhereInput>
    id?: IntFilter | number
    project_proposal_id?: IntFilter | number
    unit_location_id?: IntFilter | number
    new_unit?: StringNullableFilter | string | null
    existing_unit?: StringNullableFilter | string | null
    unit_alias?: StringNullableFilter | string | null
    work_type?: StringNullableFilter | string | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    created_by?: IntNullableFilter | number | null
    updated_by?: IntNullableFilter | number | null
    ProjectProposals?: XOR<ProjectProposalsRelationFilter, ProjectProposalsWhereInput>
    UnitLocations?: XOR<UnitLocationsRelationFilter, UnitLocationsWhereInput>
    ScopeOfWorkPropertyUnits?: ScopeOfWorkPropertyUnitsListRelationFilter
    ScopeOfWorks?: ScopeOfWorksListRelationFilter
  }

  export type AreaOfWorksOrderByInput = {
    id?: SortOrder
    project_proposal_id?: SortOrder
    unit_location_id?: SortOrder
    new_unit?: SortOrder
    existing_unit?: SortOrder
    unit_alias?: SortOrder
    work_type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    ProjectProposals?: ProjectProposalsOrderByInput
    UnitLocations?: UnitLocationsOrderByInput
  }

  export type AreaOfWorksWhereUniqueInput = {
    id?: number
  }

  export type AttributesWhereInput = {
    AND?: Enumerable<AttributesWhereInput>
    OR?: Enumerable<AttributesWhereInput>
    NOT?: Enumerable<AttributesWhereInput>
    id?: IntFilter | number
    parent_id?: IntNullableFilter | number | null
    name?: StringNullableFilter | string | null
    slug?: StringNullableFilter | string | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    created_by?: IntNullableFilter | number | null
    updated_by?: IntNullableFilter | number | null
    Attributes?: XOR<AttributesRelationFilter, AttributesWhereInput> | null
    other_Attributes?: AttributesListRelationFilter
    AttributeUnits?: AttributeUnitsListRelationFilter
    ProductAttributeUnits?: ProductAttributeUnitsListRelationFilter
    PropertyUnitAttributes?: PropertyUnitAttributesListRelationFilter
  }

  export type AttributesOrderByInput = {
    id?: SortOrder
    parent_id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    Attributes?: AttributesOrderByInput
  }

  export type AttributesWhereUniqueInput = {
    id?: number
    slug?: string
  }

  export type AttributeUnitsWhereInput = {
    AND?: Enumerable<AttributeUnitsWhereInput>
    OR?: Enumerable<AttributeUnitsWhereInput>
    NOT?: Enumerable<AttributeUnitsWhereInput>
    id?: IntFilter | number
    attribute_parent_id?: IntNullableFilter | number | null
    unit_name?: StringNullableFilter | string | null
    slug?: StringNullableFilter | string | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    created_by?: IntNullableFilter | number | null
    updated_by?: IntNullableFilter | number | null
    Attributes?: XOR<AttributesRelationFilter, AttributesWhereInput> | null
    ProductAttributeUnits?: ProductAttributeUnitsListRelationFilter
    PropertyUnitAttributes?: PropertyUnitAttributesListRelationFilter
  }

  export type AttributeUnitsOrderByInput = {
    id?: SortOrder
    attribute_parent_id?: SortOrder
    unit_name?: SortOrder
    slug?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    Attributes?: AttributesOrderByInput
  }

  export type AttributeUnitsWhereUniqueInput = {
    id?: number
    slug?: string
  }

  export type Backend_UsersWhereInput = {
    AND?: Enumerable<Backend_UsersWhereInput>
    OR?: Enumerable<Backend_UsersWhereInput>
    NOT?: Enumerable<Backend_UsersWhereInput>
    id?: IntFilter | number
    user_id?: IntFilter | number
    first_name?: StringNullableFilter | string | null
    last_name?: StringNullableFilter | string | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    created_by?: IntNullableFilter | number | null
    updated_by?: IntNullableFilter | number | null
    Users?: XOR<UsersRelationFilter, UsersWhereInput>
  }

  export type Backend_UsersOrderByInput = {
    id?: SortOrder
    user_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    Users?: UsersOrderByInput
  }

  export type Backend_UsersWhereUniqueInput = {
    id?: number
  }

  export type CitiesWhereInput = {
    AND?: Enumerable<CitiesWhereInput>
    OR?: Enumerable<CitiesWhereInput>
    NOT?: Enumerable<CitiesWhereInput>
    id?: IntFilter | number
    state_id?: IntFilter | number
    name?: StringFilter | string
    status?: BoolFilter | boolean
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    created_by?: IntNullableFilter | number | null
    updated_by?: IntNullableFilter | number | null
    States?: XOR<StatesRelationFilter, StatesWhereInput>
    Property_Addresses?: Property_AddressesListRelationFilter
  }

  export type CitiesOrderByInput = {
    id?: SortOrder
    state_id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    States?: StatesOrderByInput
  }

  export type CitiesWhereUniqueInput = {
    id?: number
    state_id_name?: CitiesState_id_nameCompoundUniqueInput
  }

  export type ContractorsWhereInput = {
    AND?: Enumerable<ContractorsWhereInput>
    OR?: Enumerable<ContractorsWhereInput>
    NOT?: Enumerable<ContractorsWhereInput>
    id?: IntFilter | number
    user_id?: IntFilter | number
    first_name?: StringNullableFilter | string | null
    last_name?: StringNullableFilter | string | null
    mobile?: StringNullableFilter | string | null
    company_name?: StringNullableFilter | string | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    created_by?: IntNullableFilter | number | null
    updated_by?: IntNullableFilter | number | null
    Users?: XOR<UsersRelationFilter, UsersWhereInput>
  }

  export type ContractorsOrderByInput = {
    id?: SortOrder
    user_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    mobile?: SortOrder
    company_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    Users?: UsersOrderByInput
  }

  export type ContractorsWhereUniqueInput = {
    id?: number
  }

  export type CountriesWhereInput = {
    AND?: Enumerable<CountriesWhereInput>
    OR?: Enumerable<CountriesWhereInput>
    NOT?: Enumerable<CountriesWhereInput>
    id?: IntFilter | number
    country_name?: StringFilter | string
    country_code?: StringFilter | string
    iso3?: StringNullableFilter | string | null
    phone_code?: StringNullableFilter | string | null
    status?: BoolFilter | boolean
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    created_by?: IntNullableFilter | number | null
    updated_by?: IntNullableFilter | number | null
    States?: StatesListRelationFilter
  }

  export type CountriesOrderByInput = {
    id?: SortOrder
    country_name?: SortOrder
    country_code?: SortOrder
    iso3?: SortOrder
    phone_code?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type CountriesWhereUniqueInput = {
    id?: number
    country_code?: string
  }

  export type ProductAttributeUnitsWhereInput = {
    AND?: Enumerable<ProductAttributeUnitsWhereInput>
    OR?: Enumerable<ProductAttributeUnitsWhereInput>
    NOT?: Enumerable<ProductAttributeUnitsWhereInput>
    id?: IntFilter | number
    name?: StringNullableFilter | string | null
    product_id?: IntFilter | number
    attribute_id?: IntFilter | number
    attribute_unit_id?: IntFilter | number
    html_element_type?: StringNullableFilter | string | null
    display_order?: IntNullableFilter | number | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    created_by?: IntNullableFilter | number | null
    updated_by?: IntNullableFilter | number | null
    Attributes?: XOR<AttributesRelationFilter, AttributesWhereInput>
    AttributeUnits?: XOR<AttributeUnitsRelationFilter, AttributeUnitsWhereInput>
    Products?: XOR<ProductsRelationFilter, ProductsWhereInput>
    ProductAttributeUnitValues?: ProductAttributeUnitValuesListRelationFilter
    ScopeOfWorks?: ScopeOfWorksListRelationFilter
  }

  export type ProductAttributeUnitsOrderByInput = {
    id?: SortOrder
    name?: SortOrder
    product_id?: SortOrder
    attribute_id?: SortOrder
    attribute_unit_id?: SortOrder
    html_element_type?: SortOrder
    display_order?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    Attributes?: AttributesOrderByInput
    AttributeUnits?: AttributeUnitsOrderByInput
    Products?: ProductsOrderByInput
  }

  export type ProductAttributeUnitsWhereUniqueInput = {
    id?: number
  }

  export type ProductAttributeUnitValuesWhereInput = {
    AND?: Enumerable<ProductAttributeUnitValuesWhereInput>
    OR?: Enumerable<ProductAttributeUnitValuesWhereInput>
    NOT?: Enumerable<ProductAttributeUnitValuesWhereInput>
    id?: IntFilter | number
    value?: StringNullableFilter | string | null
    slug?: StringNullableFilter | string | null
    product_attribute_unit_id?: IntFilter | number
    custom?: BoolFilter | boolean
    custom_html_element_type?: StringNullableFilter | string | null
    is_default?: BoolFilter | boolean
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    created_by?: IntNullableFilter | number | null
    updated_by?: IntNullableFilter | number | null
    ProductAttributeUnits?: XOR<ProductAttributeUnitsRelationFilter, ProductAttributeUnitsWhereInput>
    ScopeOfWorks?: ScopeOfWorksListRelationFilter
  }

  export type ProductAttributeUnitValuesOrderByInput = {
    id?: SortOrder
    value?: SortOrder
    slug?: SortOrder
    product_attribute_unit_id?: SortOrder
    custom?: SortOrder
    custom_html_element_type?: SortOrder
    is_default?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    ProductAttributeUnits?: ProductAttributeUnitsOrderByInput
  }

  export type ProductAttributeUnitValuesWhereUniqueInput = {
    id?: number
    product_attribute_unit_id_slug?: ProductAttributeUnitValuesProduct_attribute_unit_id_slugCompoundUniqueInput
  }

  export type ProductCategoriesWhereInput = {
    AND?: Enumerable<ProductCategoriesWhereInput>
    OR?: Enumerable<ProductCategoriesWhereInput>
    NOT?: Enumerable<ProductCategoriesWhereInput>
    id?: IntFilter | number
    name?: StringNullableFilter | string | null
    slug?: StringNullableFilter | string | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    created_by?: IntNullableFilter | number | null
    updated_by?: IntNullableFilter | number | null
    PropertyUnitProductCategories?: PropertyUnitProductCategoriesListRelationFilter
  }

  export type ProductCategoriesOrderByInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type ProductCategoriesWhereUniqueInput = {
    id?: number
    slug?: string
  }

  export type ProductPropertyUnitsWhereInput = {
    AND?: Enumerable<ProductPropertyUnitsWhereInput>
    OR?: Enumerable<ProductPropertyUnitsWhereInput>
    NOT?: Enumerable<ProductPropertyUnitsWhereInput>
    id?: IntFilter | number
    property_unit_id?: IntFilter | number
    product_id?: IntFilter | number
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    created_by?: IntNullableFilter | number | null
    updated_by?: IntNullableFilter | number | null
    Products?: XOR<ProductsRelationFilter, ProductsWhereInput>
    PropertyUnits?: XOR<PropertyUnitsRelationFilter, PropertyUnitsWhereInput>
  }

  export type ProductPropertyUnitsOrderByInput = {
    id?: SortOrder
    property_unit_id?: SortOrder
    product_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    Products?: ProductsOrderByInput
    PropertyUnits?: PropertyUnitsOrderByInput
  }

  export type ProductPropertyUnitsWhereUniqueInput = {
    id?: number
    product_property_unit_slug?: ProductPropertyUnitsProduct_property_unit_slugCompoundUniqueInput
  }

  export type ProductsWhereInput = {
    AND?: Enumerable<ProductsWhereInput>
    OR?: Enumerable<ProductsWhereInput>
    NOT?: Enumerable<ProductsWhereInput>
    id?: IntFilter | number
    parent_id?: IntNullableFilter | number | null
    name?: StringNullableFilter | string | null
    slug?: StringNullableFilter | string | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    created_by?: IntNullableFilter | number | null
    updated_by?: IntNullableFilter | number | null
    Products?: XOR<ProductsRelationFilter, ProductsWhereInput> | null
    ProductAttributeUnits?: ProductAttributeUnitsListRelationFilter
    ProductPropertyUnits?: ProductPropertyUnitsListRelationFilter
    other_Products?: ProductsListRelationFilter
    PropertyUnitProductCategoryProducts?: PropertyUnitProductCategoryProductsListRelationFilter
  }

  export type ProductsOrderByInput = {
    id?: SortOrder
    parent_id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    Products?: ProductsOrderByInput
  }

  export type ProductsWhereUniqueInput = {
    id?: number
    slug?: string
  }

  export type ProjectProposalsWhereInput = {
    AND?: Enumerable<ProjectProposalsWhereInput>
    OR?: Enumerable<ProjectProposalsWhereInput>
    NOT?: Enumerable<ProjectProposalsWhereInput>
    id?: IntFilter | number
    name?: StringNullableFilter | string | null
    project_id?: IntFilter | number
    proposal_status?: StringNullableFilter | string | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    created_by?: IntNullableFilter | number | null
    updated_by?: IntNullableFilter | number | null
    Projects?: XOR<ProjectsRelationFilter, ProjectsWhereInput>
    AreaOfWorks?: AreaOfWorksListRelationFilter
    ScopeOfWorkPropertyUnits?: ScopeOfWorkPropertyUnitsListRelationFilter
    ScopeOfWorks?: ScopeOfWorksListRelationFilter
  }

  export type ProjectProposalsOrderByInput = {
    id?: SortOrder
    name?: SortOrder
    project_id?: SortOrder
    proposal_status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    Projects?: ProjectsOrderByInput
  }

  export type ProjectProposalsWhereUniqueInput = {
    id?: number
  }

  export type ProjectsWhereInput = {
    AND?: Enumerable<ProjectsWhereInput>
    OR?: Enumerable<ProjectsWhereInput>
    NOT?: Enumerable<ProjectsWhereInput>
    id?: IntFilter | number
    name?: StringNullableFilter | string | null
    property_address_id?: IntFilter | number
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    created_by?: IntNullableFilter | number | null
    updated_by?: IntNullableFilter | number | null
    start_date?: DateTimeFilter | Date | string
    Property_Addresses?: XOR<Property_AddressesRelationFilter, Property_AddressesWhereInput>
    ProjectProposals?: ProjectProposalsListRelationFilter
    ProjectTypeAssociations?: ProjectTypeAssociationsListRelationFilter
  }

  export type ProjectsOrderByInput = {
    id?: SortOrder
    name?: SortOrder
    property_address_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    start_date?: SortOrder
    Property_Addresses?: Property_AddressesOrderByInput
  }

  export type ProjectsWhereUniqueInput = {
    id?: number
  }

  export type ProjectTypeAssociationsWhereInput = {
    AND?: Enumerable<ProjectTypeAssociationsWhereInput>
    OR?: Enumerable<ProjectTypeAssociationsWhereInput>
    NOT?: Enumerable<ProjectTypeAssociationsWhereInput>
    id?: IntFilter | number
    project_id?: IntFilter | number
    project_type_id?: IntFilter | number
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    created_by?: IntNullableFilter | number | null
    updated_by?: IntNullableFilter | number | null
    Projects?: XOR<ProjectsRelationFilter, ProjectsWhereInput>
    ProjectTypes?: XOR<ProjectTypesRelationFilter, ProjectTypesWhereInput>
  }

  export type ProjectTypeAssociationsOrderByInput = {
    id?: SortOrder
    project_id?: SortOrder
    project_type_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    Projects?: ProjectsOrderByInput
    ProjectTypes?: ProjectTypesOrderByInput
  }

  export type ProjectTypeAssociationsWhereUniqueInput = {
    id?: number
  }

  export type ProjectTypesWhereInput = {
    AND?: Enumerable<ProjectTypesWhereInput>
    OR?: Enumerable<ProjectTypesWhereInput>
    NOT?: Enumerable<ProjectTypesWhereInput>
    id?: IntFilter | number
    type?: StringFilter | string
    slug?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    created_by?: IntNullableFilter | number | null
    updated_by?: IntNullableFilter | number | null
    ProjectTypeAssociations?: ProjectTypeAssociationsListRelationFilter
  }

  export type ProjectTypesOrderByInput = {
    id?: SortOrder
    type?: SortOrder
    slug?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type ProjectTypesWhereUniqueInput = {
    id?: number
    slug?: string
  }

  export type PropertyLevelsWhereInput = {
    AND?: Enumerable<PropertyLevelsWhereInput>
    OR?: Enumerable<PropertyLevelsWhereInput>
    NOT?: Enumerable<PropertyLevelsWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    slug?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    created_by?: IntNullableFilter | number | null
    updated_by?: IntNullableFilter | number | null
    UnitLocations?: UnitLocationsListRelationFilter
  }

  export type PropertyLevelsOrderByInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type PropertyLevelsWhereUniqueInput = {
    id?: number
    slug?: string
  }

  export type PropertyOwnersWhereInput = {
    AND?: Enumerable<PropertyOwnersWhereInput>
    OR?: Enumerable<PropertyOwnersWhereInput>
    NOT?: Enumerable<PropertyOwnersWhereInput>
    id?: IntFilter | number
    user_id?: IntFilter | number
    first_name?: StringNullableFilter | string | null
    last_name?: StringNullableFilter | string | null
    mobile?: StringNullableFilter | string | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    created_by?: IntNullableFilter | number | null
    updated_by?: IntNullableFilter | number | null
    Users?: XOR<UsersRelationFilter, UsersWhereInput>
    Property_Addresses?: Property_AddressesListRelationFilter
  }

  export type PropertyOwnersOrderByInput = {
    id?: SortOrder
    user_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    mobile?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    Users?: UsersOrderByInput
  }

  export type PropertyOwnersWhereUniqueInput = {
    id?: number
  }

  export type PropertySubTypesWhereInput = {
    AND?: Enumerable<PropertySubTypesWhereInput>
    OR?: Enumerable<PropertySubTypesWhereInput>
    NOT?: Enumerable<PropertySubTypesWhereInput>
    id?: IntFilter | number
    property_type_id?: IntFilter | number
    name?: StringFilter | string
    slug?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    created_by?: IntNullableFilter | number | null
    updated_by?: IntNullableFilter | number | null
    Property_Types?: XOR<Property_TypesRelationFilter, Property_TypesWhereInput>
    Property_Addresses?: Property_AddressesListRelationFilter
    UnitLocations?: UnitLocationsListRelationFilter
  }

  export type PropertySubTypesOrderByInput = {
    id?: SortOrder
    property_type_id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    Property_Types?: Property_TypesOrderByInput
  }

  export type PropertySubTypesWhereUniqueInput = {
    id?: number
    slug?: string
  }

  export type PropertyUnitAttributesWhereInput = {
    AND?: Enumerable<PropertyUnitAttributesWhereInput>
    OR?: Enumerable<PropertyUnitAttributesWhereInput>
    NOT?: Enumerable<PropertyUnitAttributesWhereInput>
    id?: IntFilter | number
    property_unit_id?: IntFilter | number
    attribute_id?: IntFilter | number
    attribute_unit_id?: IntFilter | number
    html_element_type?: StringNullableFilter | string | null
    display_order?: IntNullableFilter | number | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    created_by?: IntNullableFilter | number | null
    updated_by?: IntNullableFilter | number | null
    Attributes?: XOR<AttributesRelationFilter, AttributesWhereInput>
    AttributeUnits?: XOR<AttributeUnitsRelationFilter, AttributeUnitsWhereInput>
    PropertyUnits?: XOR<PropertyUnitsRelationFilter, PropertyUnitsWhereInput>
    ScopeOfWorkPropertyUnits?: ScopeOfWorkPropertyUnitsListRelationFilter
  }

  export type PropertyUnitAttributesOrderByInput = {
    id?: SortOrder
    property_unit_id?: SortOrder
    attribute_id?: SortOrder
    attribute_unit_id?: SortOrder
    html_element_type?: SortOrder
    display_order?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    Attributes?: AttributesOrderByInput
    AttributeUnits?: AttributeUnitsOrderByInput
    PropertyUnits?: PropertyUnitsOrderByInput
  }

  export type PropertyUnitAttributesWhereUniqueInput = {
    id?: number
  }

  export type PropertyUnitProductCategoriesWhereInput = {
    AND?: Enumerable<PropertyUnitProductCategoriesWhereInput>
    OR?: Enumerable<PropertyUnitProductCategoriesWhereInput>
    NOT?: Enumerable<PropertyUnitProductCategoriesWhereInput>
    id?: IntFilter | number
    property_unit_id?: IntFilter | number
    product_category_id?: IntFilter | number
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    created_by?: IntNullableFilter | number | null
    updated_by?: IntNullableFilter | number | null
    ProductCategories?: XOR<ProductCategoriesRelationFilter, ProductCategoriesWhereInput>
    PropertyUnits?: XOR<PropertyUnitsRelationFilter, PropertyUnitsWhereInput>
    PropertyUnitProductCategoryProducts?: PropertyUnitProductCategoryProductsListRelationFilter
  }

  export type PropertyUnitProductCategoriesOrderByInput = {
    id?: SortOrder
    property_unit_id?: SortOrder
    product_category_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    ProductCategories?: ProductCategoriesOrderByInput
    PropertyUnits?: PropertyUnitsOrderByInput
  }

  export type PropertyUnitProductCategoriesWhereUniqueInput = {
    id?: number
  }

  export type PropertyUnitProductCategoryProductsWhereInput = {
    AND?: Enumerable<PropertyUnitProductCategoryProductsWhereInput>
    OR?: Enumerable<PropertyUnitProductCategoryProductsWhereInput>
    NOT?: Enumerable<PropertyUnitProductCategoryProductsWhereInput>
    id?: IntFilter | number
    property_unit_product_category_id?: IntFilter | number
    product_id?: IntFilter | number
    display_order?: IntNullableFilter | number | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    created_by?: IntNullableFilter | number | null
    updated_by?: IntNullableFilter | number | null
    Products?: XOR<ProductsRelationFilter, ProductsWhereInput>
    PropertyUnitProductCategories?: XOR<PropertyUnitProductCategoriesRelationFilter, PropertyUnitProductCategoriesWhereInput>
  }

  export type PropertyUnitProductCategoryProductsOrderByInput = {
    id?: SortOrder
    property_unit_product_category_id?: SortOrder
    product_id?: SortOrder
    display_order?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    Products?: ProductsOrderByInput
    PropertyUnitProductCategories?: PropertyUnitProductCategoriesOrderByInput
  }

  export type PropertyUnitProductCategoryProductsWhereUniqueInput = {
    id?: number
  }

  export type PropertyUnitsWhereInput = {
    AND?: Enumerable<PropertyUnitsWhereInput>
    OR?: Enumerable<PropertyUnitsWhereInput>
    NOT?: Enumerable<PropertyUnitsWhereInput>
    id?: IntFilter | number
    name?: StringNullableFilter | string | null
    slug?: StringNullableFilter | string | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    created_by?: IntNullableFilter | number | null
    updated_by?: IntNullableFilter | number | null
    ProductPropertyUnits?: ProductPropertyUnitsListRelationFilter
    PropertyUnitAttributes?: PropertyUnitAttributesListRelationFilter
    PropertyUnitProductCategories?: PropertyUnitProductCategoriesListRelationFilter
    UnitLocations?: UnitLocationsListRelationFilter
  }

  export type PropertyUnitsOrderByInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type PropertyUnitsWhereUniqueInput = {
    id?: number
    slug?: string
  }

  export type Property_AddressesWhereInput = {
    AND?: Enumerable<Property_AddressesWhereInput>
    OR?: Enumerable<Property_AddressesWhereInput>
    NOT?: Enumerable<Property_AddressesWhereInput>
    id?: IntFilter | number
    street?: StringNullableFilter | string | null
    property_owner_id?: IntFilter | number
    city_id?: IntFilter | number
    property_sub_type_id?: IntFilter | number
    postal_code?: StringNullableFilter | string | null
    construction_type?: StringNullableFilter | string | null
    withBasement?: BoolFilter | boolean
    storyId?: IntNullableFilter | number | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    created_by?: IntNullableFilter | number | null
    updated_by?: IntNullableFilter | number | null
    Cities?: XOR<CitiesRelationFilter, CitiesWhereInput>
    PropertyOwners?: XOR<PropertyOwnersRelationFilter, PropertyOwnersWhereInput>
    PropertySubTypes?: XOR<PropertySubTypesRelationFilter, PropertySubTypesWhereInput>
    Projects?: ProjectsListRelationFilter
  }

  export type Property_AddressesOrderByInput = {
    id?: SortOrder
    street?: SortOrder
    property_owner_id?: SortOrder
    city_id?: SortOrder
    property_sub_type_id?: SortOrder
    postal_code?: SortOrder
    construction_type?: SortOrder
    withBasement?: SortOrder
    storyId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    Cities?: CitiesOrderByInput
    PropertyOwners?: PropertyOwnersOrderByInput
    PropertySubTypes?: PropertySubTypesOrderByInput
  }

  export type Property_AddressesWhereUniqueInput = {
    id?: number
  }

  export type Property_TypesWhereInput = {
    AND?: Enumerable<Property_TypesWhereInput>
    OR?: Enumerable<Property_TypesWhereInput>
    NOT?: Enumerable<Property_TypesWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    slug?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    created_by?: IntNullableFilter | number | null
    updated_by?: IntNullableFilter | number | null
    PropertySubTypes?: PropertySubTypesListRelationFilter
  }

  export type Property_TypesOrderByInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type Property_TypesWhereUniqueInput = {
    id?: number
    slug?: string
  }

  export type ScopeOfWorkPropertyUnitsWhereInput = {
    AND?: Enumerable<ScopeOfWorkPropertyUnitsWhereInput>
    OR?: Enumerable<ScopeOfWorkPropertyUnitsWhereInput>
    NOT?: Enumerable<ScopeOfWorkPropertyUnitsWhereInput>
    id?: IntFilter | number
    project_proposal_id?: IntFilter | number
    area_of_work_id?: IntFilter | number
    property_unit_attribute_id?: IntFilter | number
    value?: StringNullableFilter | string | null
    attribute_custom_name?: StringNullableFilter | string | null
    attribute_custom_value?: StringNullableFilter | string | null
    attribute_custom_unit?: StringNullableFilter | string | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    created_by?: IntNullableFilter | number | null
    updated_by?: IntNullableFilter | number | null
    AreaOfWorks?: XOR<AreaOfWorksRelationFilter, AreaOfWorksWhereInput>
    ProjectProposals?: XOR<ProjectProposalsRelationFilter, ProjectProposalsWhereInput>
    PropertyUnitAttributes?: XOR<PropertyUnitAttributesRelationFilter, PropertyUnitAttributesWhereInput>
  }

  export type ScopeOfWorkPropertyUnitsOrderByInput = {
    id?: SortOrder
    project_proposal_id?: SortOrder
    area_of_work_id?: SortOrder
    property_unit_attribute_id?: SortOrder
    value?: SortOrder
    attribute_custom_name?: SortOrder
    attribute_custom_value?: SortOrder
    attribute_custom_unit?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    AreaOfWorks?: AreaOfWorksOrderByInput
    ProjectProposals?: ProjectProposalsOrderByInput
    PropertyUnitAttributes?: PropertyUnitAttributesOrderByInput
  }

  export type ScopeOfWorkPropertyUnitsWhereUniqueInput = {
    id?: number
  }

  export type ScopeOfWorksWhereInput = {
    AND?: Enumerable<ScopeOfWorksWhereInput>
    OR?: Enumerable<ScopeOfWorksWhereInput>
    NOT?: Enumerable<ScopeOfWorksWhereInput>
    id?: IntFilter | number
    project_proposal_id?: IntFilter | number
    area_of_work_id?: IntFilter | number
    product_attribute_unit_id?: IntFilter | number
    product_attribute_unit_value_id?: IntFilter | number
    attribute_custom_name?: StringNullableFilter | string | null
    attribute_custom_value?: StringNullableFilter | string | null
    attribute_custom_unit?: StringNullableFilter | string | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    created_by?: IntNullableFilter | number | null
    updated_by?: IntNullableFilter | number | null
    AreaOfWorks?: XOR<AreaOfWorksRelationFilter, AreaOfWorksWhereInput>
    ProductAttributeUnits?: XOR<ProductAttributeUnitsRelationFilter, ProductAttributeUnitsWhereInput>
    ProductAttributeUnitValues?: XOR<ProductAttributeUnitValuesRelationFilter, ProductAttributeUnitValuesWhereInput>
    ProjectProposals?: XOR<ProjectProposalsRelationFilter, ProjectProposalsWhereInput>
  }

  export type ScopeOfWorksOrderByInput = {
    id?: SortOrder
    project_proposal_id?: SortOrder
    area_of_work_id?: SortOrder
    product_attribute_unit_id?: SortOrder
    product_attribute_unit_value_id?: SortOrder
    attribute_custom_name?: SortOrder
    attribute_custom_value?: SortOrder
    attribute_custom_unit?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    AreaOfWorks?: AreaOfWorksOrderByInput
    ProductAttributeUnits?: ProductAttributeUnitsOrderByInput
    ProductAttributeUnitValues?: ProductAttributeUnitValuesOrderByInput
    ProjectProposals?: ProjectProposalsOrderByInput
  }

  export type ScopeOfWorksWhereUniqueInput = {
    id?: number
  }

  export type SequelizeMetaWhereInput = {
    AND?: Enumerable<SequelizeMetaWhereInput>
    OR?: Enumerable<SequelizeMetaWhereInput>
    NOT?: Enumerable<SequelizeMetaWhereInput>
    name?: StringFilter | string
  }

  export type SequelizeMetaOrderByInput = {
    name?: SortOrder
  }

  export type SequelizeMetaWhereUniqueInput = {
    name?: string
  }

  export type StatesWhereInput = {
    AND?: Enumerable<StatesWhereInput>
    OR?: Enumerable<StatesWhereInput>
    NOT?: Enumerable<StatesWhereInput>
    id?: IntFilter | number
    country_id?: IntFilter | number
    name?: StringNullableFilter | string | null
    state_code?: StringFilter | string
    status?: BoolFilter | boolean
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    created_by?: IntNullableFilter | number | null
    updated_by?: IntNullableFilter | number | null
    Countries?: XOR<CountriesRelationFilter, CountriesWhereInput>
    Cities?: CitiesListRelationFilter
  }

  export type StatesOrderByInput = {
    id?: SortOrder
    country_id?: SortOrder
    name?: SortOrder
    state_code?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    Countries?: CountriesOrderByInput
  }

  export type StatesWhereUniqueInput = {
    id?: number
    country_id_state_code?: StatesCountry_id_state_codeCompoundUniqueInput
  }

  export type UnitLocationsWhereInput = {
    AND?: Enumerable<UnitLocationsWhereInput>
    OR?: Enumerable<UnitLocationsWhereInput>
    NOT?: Enumerable<UnitLocationsWhereInput>
    id?: IntFilter | number
    unit_name?: StringNullableFilter | string | null
    property_sub_type_id?: IntFilter | number
    property_level_id?: IntFilter | number
    property_unit_id?: IntFilter | number
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    created_by?: IntNullableFilter | number | null
    updated_by?: IntNullableFilter | number | null
    PropertyLevels?: XOR<PropertyLevelsRelationFilter, PropertyLevelsWhereInput>
    PropertySubTypes?: XOR<PropertySubTypesRelationFilter, PropertySubTypesWhereInput>
    PropertyUnits?: XOR<PropertyUnitsRelationFilter, PropertyUnitsWhereInput>
    AreaOfWorks?: AreaOfWorksListRelationFilter
  }

  export type UnitLocationsOrderByInput = {
    id?: SortOrder
    unit_name?: SortOrder
    property_sub_type_id?: SortOrder
    property_level_id?: SortOrder
    property_unit_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    PropertyLevels?: PropertyLevelsOrderByInput
    PropertySubTypes?: PropertySubTypesOrderByInput
    PropertyUnits?: PropertyUnitsOrderByInput
  }

  export type UnitLocationsWhereUniqueInput = {
    id?: number
    product_property_unit_slug?: UnitLocationsProduct_property_unit_slugCompoundUniqueInput
  }

  export type UsersWhereInput = {
    AND?: Enumerable<UsersWhereInput>
    OR?: Enumerable<UsersWhereInput>
    NOT?: Enumerable<UsersWhereInput>
    id?: IntFilter | number
    user_type?: StringFilter | string
    email?: StringFilter | string
    status?: BoolFilter | boolean
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    created_by?: IntNullableFilter | number | null
    updated_by?: IntNullableFilter | number | null
    username?: StringNullableFilter | string | null
    email_verified?: BoolFilter | boolean
    name?: StringNullableFilter | string | null
    Backend_Users?: Backend_UsersListRelationFilter
    Contractors?: ContractorsListRelationFilter
    PropertyOwners?: PropertyOwnersListRelationFilter
  }

  export type UsersOrderByInput = {
    id?: SortOrder
    user_type?: SortOrder
    email?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    username?: SortOrder
    email_verified?: SortOrder
    name?: SortOrder
  }

  export type UsersWhereUniqueInput = {
    id?: number
  }

  export type AreaOfWorksCreateInput = {
    new_unit?: string | null
    existing_unit?: string | null
    unit_alias?: string | null
    work_type?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    ProjectProposals: ProjectProposalsCreateNestedOneWithoutAreaOfWorksInput
    UnitLocations: UnitLocationsCreateNestedOneWithoutAreaOfWorksInput
    ScopeOfWorkPropertyUnits?: ScopeOfWorkPropertyUnitsCreateNestedManyWithoutAreaOfWorksInput
    ScopeOfWorks?: ScopeOfWorksCreateNestedManyWithoutAreaOfWorksInput
  }

  export type AreaOfWorksUncheckedCreateInput = {
    id?: number
    project_proposal_id: number
    unit_location_id: number
    new_unit?: string | null
    existing_unit?: string | null
    unit_alias?: string | null
    work_type?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    ScopeOfWorkPropertyUnits?: ScopeOfWorkPropertyUnitsUncheckedCreateNestedManyWithoutAreaOfWorksInput
    ScopeOfWorks?: ScopeOfWorksUncheckedCreateNestedManyWithoutAreaOfWorksInput
  }

  export type AreaOfWorksUpdateInput = {
    new_unit?: NullableStringFieldUpdateOperationsInput | string | null
    existing_unit?: NullableStringFieldUpdateOperationsInput | string | null
    unit_alias?: NullableStringFieldUpdateOperationsInput | string | null
    work_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    ProjectProposals?: ProjectProposalsUpdateOneRequiredWithoutAreaOfWorksInput
    UnitLocations?: UnitLocationsUpdateOneRequiredWithoutAreaOfWorksInput
    ScopeOfWorkPropertyUnits?: ScopeOfWorkPropertyUnitsUpdateManyWithoutAreaOfWorksInput
    ScopeOfWorks?: ScopeOfWorksUpdateManyWithoutAreaOfWorksInput
  }

  export type AreaOfWorksUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    project_proposal_id?: IntFieldUpdateOperationsInput | number
    unit_location_id?: IntFieldUpdateOperationsInput | number
    new_unit?: NullableStringFieldUpdateOperationsInput | string | null
    existing_unit?: NullableStringFieldUpdateOperationsInput | string | null
    unit_alias?: NullableStringFieldUpdateOperationsInput | string | null
    work_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    ScopeOfWorkPropertyUnits?: ScopeOfWorkPropertyUnitsUncheckedUpdateManyWithoutAreaOfWorksInput
    ScopeOfWorks?: ScopeOfWorksUncheckedUpdateManyWithoutAreaOfWorksInput
  }

  export type AreaOfWorksUpdateManyMutationInput = {
    new_unit?: NullableStringFieldUpdateOperationsInput | string | null
    existing_unit?: NullableStringFieldUpdateOperationsInput | string | null
    unit_alias?: NullableStringFieldUpdateOperationsInput | string | null
    work_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AreaOfWorksUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    project_proposal_id?: IntFieldUpdateOperationsInput | number
    unit_location_id?: IntFieldUpdateOperationsInput | number
    new_unit?: NullableStringFieldUpdateOperationsInput | string | null
    existing_unit?: NullableStringFieldUpdateOperationsInput | string | null
    unit_alias?: NullableStringFieldUpdateOperationsInput | string | null
    work_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AttributesCreateInput = {
    name?: string | null
    slug?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    Attributes?: AttributesCreateNestedOneWithoutOther_AttributesInput
    other_Attributes?: AttributesCreateNestedManyWithoutAttributesInput
    AttributeUnits?: AttributeUnitsCreateNestedManyWithoutAttributesInput
    ProductAttributeUnits?: ProductAttributeUnitsCreateNestedManyWithoutAttributesInput
    PropertyUnitAttributes?: PropertyUnitAttributesCreateNestedManyWithoutAttributesInput
  }

  export type AttributesUncheckedCreateInput = {
    id?: number
    parent_id?: number | null
    name?: string | null
    slug?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    other_Attributes?: AttributesUncheckedCreateNestedManyWithoutAttributesInput
    AttributeUnits?: AttributeUnitsUncheckedCreateNestedManyWithoutAttributesInput
    ProductAttributeUnits?: ProductAttributeUnitsUncheckedCreateNestedManyWithoutAttributesInput
    PropertyUnitAttributes?: PropertyUnitAttributesUncheckedCreateNestedManyWithoutAttributesInput
  }

  export type AttributesUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    Attributes?: AttributesUpdateOneWithoutOther_AttributesInput
    other_Attributes?: AttributesUpdateManyWithoutAttributesInput
    AttributeUnits?: AttributeUnitsUpdateManyWithoutAttributesInput
    ProductAttributeUnits?: ProductAttributeUnitsUpdateManyWithoutAttributesInput
    PropertyUnitAttributes?: PropertyUnitAttributesUpdateManyWithoutAttributesInput
  }

  export type AttributesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    other_Attributes?: AttributesUncheckedUpdateManyWithoutAttributesInput
    AttributeUnits?: AttributeUnitsUncheckedUpdateManyWithoutAttributesInput
    ProductAttributeUnits?: ProductAttributeUnitsUncheckedUpdateManyWithoutAttributesInput
    PropertyUnitAttributes?: PropertyUnitAttributesUncheckedUpdateManyWithoutAttributesInput
  }

  export type AttributesUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AttributesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AttributeUnitsCreateInput = {
    unit_name?: string | null
    slug?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    Attributes?: AttributesCreateNestedOneWithoutAttributeUnitsInput
    ProductAttributeUnits?: ProductAttributeUnitsCreateNestedManyWithoutAttributeUnitsInput
    PropertyUnitAttributes?: PropertyUnitAttributesCreateNestedManyWithoutAttributeUnitsInput
  }

  export type AttributeUnitsUncheckedCreateInput = {
    id?: number
    attribute_parent_id?: number | null
    unit_name?: string | null
    slug?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    ProductAttributeUnits?: ProductAttributeUnitsUncheckedCreateNestedManyWithoutAttributeUnitsInput
    PropertyUnitAttributes?: PropertyUnitAttributesUncheckedCreateNestedManyWithoutAttributeUnitsInput
  }

  export type AttributeUnitsUpdateInput = {
    unit_name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    Attributes?: AttributesUpdateOneWithoutAttributeUnitsInput
    ProductAttributeUnits?: ProductAttributeUnitsUpdateManyWithoutAttributeUnitsInput
    PropertyUnitAttributes?: PropertyUnitAttributesUpdateManyWithoutAttributeUnitsInput
  }

  export type AttributeUnitsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    attribute_parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    unit_name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    ProductAttributeUnits?: ProductAttributeUnitsUncheckedUpdateManyWithoutAttributeUnitsInput
    PropertyUnitAttributes?: PropertyUnitAttributesUncheckedUpdateManyWithoutAttributeUnitsInput
  }

  export type AttributeUnitsUpdateManyMutationInput = {
    unit_name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AttributeUnitsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    attribute_parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    unit_name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type Backend_UsersCreateInput = {
    first_name?: string | null
    last_name?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    Users: UsersCreateNestedOneWithoutBackend_UsersInput
  }

  export type Backend_UsersUncheckedCreateInput = {
    id?: number
    user_id: number
    first_name?: string | null
    last_name?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
  }

  export type Backend_UsersUpdateInput = {
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    Users?: UsersUpdateOneRequiredWithoutBackend_UsersInput
  }

  export type Backend_UsersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type Backend_UsersUpdateManyMutationInput = {
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type Backend_UsersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CitiesCreateInput = {
    name: string
    status?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    States: StatesCreateNestedOneWithoutCitiesInput
    Property_Addresses?: Property_AddressesCreateNestedManyWithoutCitiesInput
  }

  export type CitiesUncheckedCreateInput = {
    id?: number
    state_id: number
    name: string
    status?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    Property_Addresses?: Property_AddressesUncheckedCreateNestedManyWithoutCitiesInput
  }

  export type CitiesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    States?: StatesUpdateOneRequiredWithoutCitiesInput
    Property_Addresses?: Property_AddressesUpdateManyWithoutCitiesInput
  }

  export type CitiesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    state_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    Property_Addresses?: Property_AddressesUncheckedUpdateManyWithoutCitiesInput
  }

  export type CitiesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CitiesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    state_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ContractorsCreateInput = {
    first_name?: string | null
    last_name?: string | null
    mobile?: string | null
    company_name?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    Users: UsersCreateNestedOneWithoutContractorsInput
  }

  export type ContractorsUncheckedCreateInput = {
    id?: number
    user_id: number
    first_name?: string | null
    last_name?: string | null
    mobile?: string | null
    company_name?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
  }

  export type ContractorsUpdateInput = {
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    Users?: UsersUpdateOneRequiredWithoutContractorsInput
  }

  export type ContractorsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ContractorsUpdateManyMutationInput = {
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ContractorsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CountriesCreateInput = {
    country_name: string
    country_code: string
    iso3?: string | null
    phone_code?: string | null
    status?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    States?: StatesCreateNestedManyWithoutCountriesInput
  }

  export type CountriesUncheckedCreateInput = {
    id?: number
    country_name: string
    country_code: string
    iso3?: string | null
    phone_code?: string | null
    status?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    States?: StatesUncheckedCreateNestedManyWithoutCountriesInput
  }

  export type CountriesUpdateInput = {
    country_name?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    iso3?: NullableStringFieldUpdateOperationsInput | string | null
    phone_code?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    States?: StatesUpdateManyWithoutCountriesInput
  }

  export type CountriesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    country_name?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    iso3?: NullableStringFieldUpdateOperationsInput | string | null
    phone_code?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    States?: StatesUncheckedUpdateManyWithoutCountriesInput
  }

  export type CountriesUpdateManyMutationInput = {
    country_name?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    iso3?: NullableStringFieldUpdateOperationsInput | string | null
    phone_code?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CountriesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    country_name?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    iso3?: NullableStringFieldUpdateOperationsInput | string | null
    phone_code?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProductAttributeUnitsCreateInput = {
    name?: string | null
    html_element_type?: string | null
    display_order?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    Attributes: AttributesCreateNestedOneWithoutProductAttributeUnitsInput
    AttributeUnits: AttributeUnitsCreateNestedOneWithoutProductAttributeUnitsInput
    Products: ProductsCreateNestedOneWithoutProductAttributeUnitsInput
    ProductAttributeUnitValues?: ProductAttributeUnitValuesCreateNestedManyWithoutProductAttributeUnitsInput
    ScopeOfWorks?: ScopeOfWorksCreateNestedManyWithoutProductAttributeUnitsInput
  }

  export type ProductAttributeUnitsUncheckedCreateInput = {
    id?: number
    name?: string | null
    product_id: number
    attribute_id: number
    attribute_unit_id: number
    html_element_type?: string | null
    display_order?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    ProductAttributeUnitValues?: ProductAttributeUnitValuesUncheckedCreateNestedManyWithoutProductAttributeUnitsInput
    ScopeOfWorks?: ScopeOfWorksUncheckedCreateNestedManyWithoutProductAttributeUnitsInput
  }

  export type ProductAttributeUnitsUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    html_element_type?: NullableStringFieldUpdateOperationsInput | string | null
    display_order?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    Attributes?: AttributesUpdateOneRequiredWithoutProductAttributeUnitsInput
    AttributeUnits?: AttributeUnitsUpdateOneRequiredWithoutProductAttributeUnitsInput
    Products?: ProductsUpdateOneRequiredWithoutProductAttributeUnitsInput
    ProductAttributeUnitValues?: ProductAttributeUnitValuesUpdateManyWithoutProductAttributeUnitsInput
    ScopeOfWorks?: ScopeOfWorksUpdateManyWithoutProductAttributeUnitsInput
  }

  export type ProductAttributeUnitsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    product_id?: IntFieldUpdateOperationsInput | number
    attribute_id?: IntFieldUpdateOperationsInput | number
    attribute_unit_id?: IntFieldUpdateOperationsInput | number
    html_element_type?: NullableStringFieldUpdateOperationsInput | string | null
    display_order?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    ProductAttributeUnitValues?: ProductAttributeUnitValuesUncheckedUpdateManyWithoutProductAttributeUnitsInput
    ScopeOfWorks?: ScopeOfWorksUncheckedUpdateManyWithoutProductAttributeUnitsInput
  }

  export type ProductAttributeUnitsUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    html_element_type?: NullableStringFieldUpdateOperationsInput | string | null
    display_order?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProductAttributeUnitsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    product_id?: IntFieldUpdateOperationsInput | number
    attribute_id?: IntFieldUpdateOperationsInput | number
    attribute_unit_id?: IntFieldUpdateOperationsInput | number
    html_element_type?: NullableStringFieldUpdateOperationsInput | string | null
    display_order?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProductAttributeUnitValuesCreateInput = {
    value?: string | null
    slug?: string | null
    custom?: boolean
    custom_html_element_type?: string | null
    is_default?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    ProductAttributeUnits: ProductAttributeUnitsCreateNestedOneWithoutProductAttributeUnitValuesInput
    ScopeOfWorks?: ScopeOfWorksCreateNestedManyWithoutProductAttributeUnitValuesInput
  }

  export type ProductAttributeUnitValuesUncheckedCreateInput = {
    id?: number
    value?: string | null
    slug?: string | null
    product_attribute_unit_id: number
    custom?: boolean
    custom_html_element_type?: string | null
    is_default?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    ScopeOfWorks?: ScopeOfWorksUncheckedCreateNestedManyWithoutProductAttributeUnitValuesInput
  }

  export type ProductAttributeUnitValuesUpdateInput = {
    value?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    custom?: BoolFieldUpdateOperationsInput | boolean
    custom_html_element_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_default?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    ProductAttributeUnits?: ProductAttributeUnitsUpdateOneRequiredWithoutProductAttributeUnitValuesInput
    ScopeOfWorks?: ScopeOfWorksUpdateManyWithoutProductAttributeUnitValuesInput
  }

  export type ProductAttributeUnitValuesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    product_attribute_unit_id?: IntFieldUpdateOperationsInput | number
    custom?: BoolFieldUpdateOperationsInput | boolean
    custom_html_element_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_default?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    ScopeOfWorks?: ScopeOfWorksUncheckedUpdateManyWithoutProductAttributeUnitValuesInput
  }

  export type ProductAttributeUnitValuesUpdateManyMutationInput = {
    value?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    custom?: BoolFieldUpdateOperationsInput | boolean
    custom_html_element_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_default?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProductAttributeUnitValuesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    product_attribute_unit_id?: IntFieldUpdateOperationsInput | number
    custom?: BoolFieldUpdateOperationsInput | boolean
    custom_html_element_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_default?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProductCategoriesCreateInput = {
    name?: string | null
    slug?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    PropertyUnitProductCategories?: PropertyUnitProductCategoriesCreateNestedManyWithoutProductCategoriesInput
  }

  export type ProductCategoriesUncheckedCreateInput = {
    id?: number
    name?: string | null
    slug?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    PropertyUnitProductCategories?: PropertyUnitProductCategoriesUncheckedCreateNestedManyWithoutProductCategoriesInput
  }

  export type ProductCategoriesUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    PropertyUnitProductCategories?: PropertyUnitProductCategoriesUpdateManyWithoutProductCategoriesInput
  }

  export type ProductCategoriesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    PropertyUnitProductCategories?: PropertyUnitProductCategoriesUncheckedUpdateManyWithoutProductCategoriesInput
  }

  export type ProductCategoriesUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProductCategoriesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProductPropertyUnitsCreateInput = {
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    Products: ProductsCreateNestedOneWithoutProductPropertyUnitsInput
    PropertyUnits: PropertyUnitsCreateNestedOneWithoutProductPropertyUnitsInput
  }

  export type ProductPropertyUnitsUncheckedCreateInput = {
    id?: number
    property_unit_id: number
    product_id: number
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
  }

  export type ProductPropertyUnitsUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    Products?: ProductsUpdateOneRequiredWithoutProductPropertyUnitsInput
    PropertyUnits?: PropertyUnitsUpdateOneRequiredWithoutProductPropertyUnitsInput
  }

  export type ProductPropertyUnitsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    property_unit_id?: IntFieldUpdateOperationsInput | number
    product_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProductPropertyUnitsUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProductPropertyUnitsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    property_unit_id?: IntFieldUpdateOperationsInput | number
    product_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProductsCreateInput = {
    name?: string | null
    slug?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    Products?: ProductsCreateNestedOneWithoutOther_ProductsInput
    ProductAttributeUnits?: ProductAttributeUnitsCreateNestedManyWithoutProductsInput
    ProductPropertyUnits?: ProductPropertyUnitsCreateNestedManyWithoutProductsInput
    other_Products?: ProductsCreateNestedManyWithoutProductsInput
    PropertyUnitProductCategoryProducts?: PropertyUnitProductCategoryProductsCreateNestedManyWithoutProductsInput
  }

  export type ProductsUncheckedCreateInput = {
    id?: number
    parent_id?: number | null
    name?: string | null
    slug?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    ProductAttributeUnits?: ProductAttributeUnitsUncheckedCreateNestedManyWithoutProductsInput
    ProductPropertyUnits?: ProductPropertyUnitsUncheckedCreateNestedManyWithoutProductsInput
    other_Products?: ProductsUncheckedCreateNestedManyWithoutProductsInput
    PropertyUnitProductCategoryProducts?: PropertyUnitProductCategoryProductsUncheckedCreateNestedManyWithoutProductsInput
  }

  export type ProductsUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    Products?: ProductsUpdateOneWithoutOther_ProductsInput
    ProductAttributeUnits?: ProductAttributeUnitsUpdateManyWithoutProductsInput
    ProductPropertyUnits?: ProductPropertyUnitsUpdateManyWithoutProductsInput
    other_Products?: ProductsUpdateManyWithoutProductsInput
    PropertyUnitProductCategoryProducts?: PropertyUnitProductCategoryProductsUpdateManyWithoutProductsInput
  }

  export type ProductsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    ProductAttributeUnits?: ProductAttributeUnitsUncheckedUpdateManyWithoutProductsInput
    ProductPropertyUnits?: ProductPropertyUnitsUncheckedUpdateManyWithoutProductsInput
    other_Products?: ProductsUncheckedUpdateManyWithoutProductsInput
    PropertyUnitProductCategoryProducts?: PropertyUnitProductCategoryProductsUncheckedUpdateManyWithoutProductsInput
  }

  export type ProductsUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProductsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProjectProposalsCreateInput = {
    name?: string | null
    proposal_status?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    Projects: ProjectsCreateNestedOneWithoutProjectProposalsInput
    AreaOfWorks?: AreaOfWorksCreateNestedManyWithoutProjectProposalsInput
    ScopeOfWorkPropertyUnits?: ScopeOfWorkPropertyUnitsCreateNestedManyWithoutProjectProposalsInput
    ScopeOfWorks?: ScopeOfWorksCreateNestedManyWithoutProjectProposalsInput
  }

  export type ProjectProposalsUncheckedCreateInput = {
    id?: number
    name?: string | null
    project_id: number
    proposal_status?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    AreaOfWorks?: AreaOfWorksUncheckedCreateNestedManyWithoutProjectProposalsInput
    ScopeOfWorkPropertyUnits?: ScopeOfWorkPropertyUnitsUncheckedCreateNestedManyWithoutProjectProposalsInput
    ScopeOfWorks?: ScopeOfWorksUncheckedCreateNestedManyWithoutProjectProposalsInput
  }

  export type ProjectProposalsUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    proposal_status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    Projects?: ProjectsUpdateOneRequiredWithoutProjectProposalsInput
    AreaOfWorks?: AreaOfWorksUpdateManyWithoutProjectProposalsInput
    ScopeOfWorkPropertyUnits?: ScopeOfWorkPropertyUnitsUpdateManyWithoutProjectProposalsInput
    ScopeOfWorks?: ScopeOfWorksUpdateManyWithoutProjectProposalsInput
  }

  export type ProjectProposalsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    project_id?: IntFieldUpdateOperationsInput | number
    proposal_status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    AreaOfWorks?: AreaOfWorksUncheckedUpdateManyWithoutProjectProposalsInput
    ScopeOfWorkPropertyUnits?: ScopeOfWorkPropertyUnitsUncheckedUpdateManyWithoutProjectProposalsInput
    ScopeOfWorks?: ScopeOfWorksUncheckedUpdateManyWithoutProjectProposalsInput
  }

  export type ProjectProposalsUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    proposal_status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProjectProposalsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    project_id?: IntFieldUpdateOperationsInput | number
    proposal_status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProjectsCreateInput = {
    name?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    start_date?: Date | string
    Property_Addresses: Property_AddressesCreateNestedOneWithoutProjectsInput
    ProjectProposals?: ProjectProposalsCreateNestedManyWithoutProjectsInput
    ProjectTypeAssociations?: ProjectTypeAssociationsCreateNestedManyWithoutProjectsInput
  }

  export type ProjectsUncheckedCreateInput = {
    id?: number
    name?: string | null
    property_address_id: number
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    start_date?: Date | string
    ProjectProposals?: ProjectProposalsUncheckedCreateNestedManyWithoutProjectsInput
    ProjectTypeAssociations?: ProjectTypeAssociationsUncheckedCreateNestedManyWithoutProjectsInput
  }

  export type ProjectsUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    Property_Addresses?: Property_AddressesUpdateOneRequiredWithoutProjectsInput
    ProjectProposals?: ProjectProposalsUpdateManyWithoutProjectsInput
    ProjectTypeAssociations?: ProjectTypeAssociationsUpdateManyWithoutProjectsInput
  }

  export type ProjectsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    property_address_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    ProjectProposals?: ProjectProposalsUncheckedUpdateManyWithoutProjectsInput
    ProjectTypeAssociations?: ProjectTypeAssociationsUncheckedUpdateManyWithoutProjectsInput
  }

  export type ProjectsUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    property_address_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectTypeAssociationsCreateInput = {
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    Projects: ProjectsCreateNestedOneWithoutProjectTypeAssociationsInput
    ProjectTypes: ProjectTypesCreateNestedOneWithoutProjectTypeAssociationsInput
  }

  export type ProjectTypeAssociationsUncheckedCreateInput = {
    id?: number
    project_id: number
    project_type_id: number
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
  }

  export type ProjectTypeAssociationsUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    Projects?: ProjectsUpdateOneRequiredWithoutProjectTypeAssociationsInput
    ProjectTypes?: ProjectTypesUpdateOneRequiredWithoutProjectTypeAssociationsInput
  }

  export type ProjectTypeAssociationsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    project_id?: IntFieldUpdateOperationsInput | number
    project_type_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProjectTypeAssociationsUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProjectTypeAssociationsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    project_id?: IntFieldUpdateOperationsInput | number
    project_type_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProjectTypesCreateInput = {
    type: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    ProjectTypeAssociations?: ProjectTypeAssociationsCreateNestedManyWithoutProjectTypesInput
  }

  export type ProjectTypesUncheckedCreateInput = {
    id?: number
    type: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    ProjectTypeAssociations?: ProjectTypeAssociationsUncheckedCreateNestedManyWithoutProjectTypesInput
  }

  export type ProjectTypesUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    ProjectTypeAssociations?: ProjectTypeAssociationsUpdateManyWithoutProjectTypesInput
  }

  export type ProjectTypesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    ProjectTypeAssociations?: ProjectTypeAssociationsUncheckedUpdateManyWithoutProjectTypesInput
  }

  export type ProjectTypesUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProjectTypesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PropertyLevelsCreateInput = {
    name: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    UnitLocations?: UnitLocationsCreateNestedManyWithoutPropertyLevelsInput
  }

  export type PropertyLevelsUncheckedCreateInput = {
    id?: number
    name: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    UnitLocations?: UnitLocationsUncheckedCreateNestedManyWithoutPropertyLevelsInput
  }

  export type PropertyLevelsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    UnitLocations?: UnitLocationsUpdateManyWithoutPropertyLevelsInput
  }

  export type PropertyLevelsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    UnitLocations?: UnitLocationsUncheckedUpdateManyWithoutPropertyLevelsInput
  }

  export type PropertyLevelsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PropertyLevelsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PropertyOwnersCreateInput = {
    first_name?: string | null
    last_name?: string | null
    mobile?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    Users: UsersCreateNestedOneWithoutPropertyOwnersInput
    Property_Addresses?: Property_AddressesCreateNestedManyWithoutPropertyOwnersInput
  }

  export type PropertyOwnersUncheckedCreateInput = {
    id?: number
    user_id: number
    first_name?: string | null
    last_name?: string | null
    mobile?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    Property_Addresses?: Property_AddressesUncheckedCreateNestedManyWithoutPropertyOwnersInput
  }

  export type PropertyOwnersUpdateInput = {
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    Users?: UsersUpdateOneRequiredWithoutPropertyOwnersInput
    Property_Addresses?: Property_AddressesUpdateManyWithoutPropertyOwnersInput
  }

  export type PropertyOwnersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    Property_Addresses?: Property_AddressesUncheckedUpdateManyWithoutPropertyOwnersInput
  }

  export type PropertyOwnersUpdateManyMutationInput = {
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PropertyOwnersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PropertySubTypesCreateInput = {
    name: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    Property_Types: Property_TypesCreateNestedOneWithoutPropertySubTypesInput
    Property_Addresses?: Property_AddressesCreateNestedManyWithoutPropertySubTypesInput
    UnitLocations?: UnitLocationsCreateNestedManyWithoutPropertySubTypesInput
  }

  export type PropertySubTypesUncheckedCreateInput = {
    id?: number
    property_type_id: number
    name: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    Property_Addresses?: Property_AddressesUncheckedCreateNestedManyWithoutPropertySubTypesInput
    UnitLocations?: UnitLocationsUncheckedCreateNestedManyWithoutPropertySubTypesInput
  }

  export type PropertySubTypesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    Property_Types?: Property_TypesUpdateOneRequiredWithoutPropertySubTypesInput
    Property_Addresses?: Property_AddressesUpdateManyWithoutPropertySubTypesInput
    UnitLocations?: UnitLocationsUpdateManyWithoutPropertySubTypesInput
  }

  export type PropertySubTypesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    property_type_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    Property_Addresses?: Property_AddressesUncheckedUpdateManyWithoutPropertySubTypesInput
    UnitLocations?: UnitLocationsUncheckedUpdateManyWithoutPropertySubTypesInput
  }

  export type PropertySubTypesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PropertySubTypesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    property_type_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PropertyUnitAttributesCreateInput = {
    html_element_type?: string | null
    display_order?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    Attributes: AttributesCreateNestedOneWithoutPropertyUnitAttributesInput
    AttributeUnits: AttributeUnitsCreateNestedOneWithoutPropertyUnitAttributesInput
    PropertyUnits: PropertyUnitsCreateNestedOneWithoutPropertyUnitAttributesInput
    ScopeOfWorkPropertyUnits?: ScopeOfWorkPropertyUnitsCreateNestedManyWithoutPropertyUnitAttributesInput
  }

  export type PropertyUnitAttributesUncheckedCreateInput = {
    id?: number
    property_unit_id: number
    attribute_id: number
    attribute_unit_id: number
    html_element_type?: string | null
    display_order?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    ScopeOfWorkPropertyUnits?: ScopeOfWorkPropertyUnitsUncheckedCreateNestedManyWithoutPropertyUnitAttributesInput
  }

  export type PropertyUnitAttributesUpdateInput = {
    html_element_type?: NullableStringFieldUpdateOperationsInput | string | null
    display_order?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    Attributes?: AttributesUpdateOneRequiredWithoutPropertyUnitAttributesInput
    AttributeUnits?: AttributeUnitsUpdateOneRequiredWithoutPropertyUnitAttributesInput
    PropertyUnits?: PropertyUnitsUpdateOneRequiredWithoutPropertyUnitAttributesInput
    ScopeOfWorkPropertyUnits?: ScopeOfWorkPropertyUnitsUpdateManyWithoutPropertyUnitAttributesInput
  }

  export type PropertyUnitAttributesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    property_unit_id?: IntFieldUpdateOperationsInput | number
    attribute_id?: IntFieldUpdateOperationsInput | number
    attribute_unit_id?: IntFieldUpdateOperationsInput | number
    html_element_type?: NullableStringFieldUpdateOperationsInput | string | null
    display_order?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    ScopeOfWorkPropertyUnits?: ScopeOfWorkPropertyUnitsUncheckedUpdateManyWithoutPropertyUnitAttributesInput
  }

  export type PropertyUnitAttributesUpdateManyMutationInput = {
    html_element_type?: NullableStringFieldUpdateOperationsInput | string | null
    display_order?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PropertyUnitAttributesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    property_unit_id?: IntFieldUpdateOperationsInput | number
    attribute_id?: IntFieldUpdateOperationsInput | number
    attribute_unit_id?: IntFieldUpdateOperationsInput | number
    html_element_type?: NullableStringFieldUpdateOperationsInput | string | null
    display_order?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PropertyUnitProductCategoriesCreateInput = {
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    ProductCategories: ProductCategoriesCreateNestedOneWithoutPropertyUnitProductCategoriesInput
    PropertyUnits: PropertyUnitsCreateNestedOneWithoutPropertyUnitProductCategoriesInput
    PropertyUnitProductCategoryProducts?: PropertyUnitProductCategoryProductsCreateNestedManyWithoutPropertyUnitProductCategoriesInput
  }

  export type PropertyUnitProductCategoriesUncheckedCreateInput = {
    id?: number
    property_unit_id: number
    product_category_id: number
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    PropertyUnitProductCategoryProducts?: PropertyUnitProductCategoryProductsUncheckedCreateNestedManyWithoutPropertyUnitProductCategoriesInput
  }

  export type PropertyUnitProductCategoriesUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    ProductCategories?: ProductCategoriesUpdateOneRequiredWithoutPropertyUnitProductCategoriesInput
    PropertyUnits?: PropertyUnitsUpdateOneRequiredWithoutPropertyUnitProductCategoriesInput
    PropertyUnitProductCategoryProducts?: PropertyUnitProductCategoryProductsUpdateManyWithoutPropertyUnitProductCategoriesInput
  }

  export type PropertyUnitProductCategoriesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    property_unit_id?: IntFieldUpdateOperationsInput | number
    product_category_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    PropertyUnitProductCategoryProducts?: PropertyUnitProductCategoryProductsUncheckedUpdateManyWithoutPropertyUnitProductCategoriesInput
  }

  export type PropertyUnitProductCategoriesUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PropertyUnitProductCategoriesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    property_unit_id?: IntFieldUpdateOperationsInput | number
    product_category_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PropertyUnitProductCategoryProductsCreateInput = {
    display_order?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    Products: ProductsCreateNestedOneWithoutPropertyUnitProductCategoryProductsInput
    PropertyUnitProductCategories: PropertyUnitProductCategoriesCreateNestedOneWithoutPropertyUnitProductCategoryProductsInput
  }

  export type PropertyUnitProductCategoryProductsUncheckedCreateInput = {
    id?: number
    property_unit_product_category_id: number
    product_id: number
    display_order?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
  }

  export type PropertyUnitProductCategoryProductsUpdateInput = {
    display_order?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    Products?: ProductsUpdateOneRequiredWithoutPropertyUnitProductCategoryProductsInput
    PropertyUnitProductCategories?: PropertyUnitProductCategoriesUpdateOneRequiredWithoutPropertyUnitProductCategoryProductsInput
  }

  export type PropertyUnitProductCategoryProductsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    property_unit_product_category_id?: IntFieldUpdateOperationsInput | number
    product_id?: IntFieldUpdateOperationsInput | number
    display_order?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PropertyUnitProductCategoryProductsUpdateManyMutationInput = {
    display_order?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PropertyUnitProductCategoryProductsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    property_unit_product_category_id?: IntFieldUpdateOperationsInput | number
    product_id?: IntFieldUpdateOperationsInput | number
    display_order?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PropertyUnitsCreateInput = {
    name?: string | null
    slug?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    ProductPropertyUnits?: ProductPropertyUnitsCreateNestedManyWithoutPropertyUnitsInput
    PropertyUnitAttributes?: PropertyUnitAttributesCreateNestedManyWithoutPropertyUnitsInput
    PropertyUnitProductCategories?: PropertyUnitProductCategoriesCreateNestedManyWithoutPropertyUnitsInput
    UnitLocations?: UnitLocationsCreateNestedManyWithoutPropertyUnitsInput
  }

  export type PropertyUnitsUncheckedCreateInput = {
    id?: number
    name?: string | null
    slug?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    ProductPropertyUnits?: ProductPropertyUnitsUncheckedCreateNestedManyWithoutPropertyUnitsInput
    PropertyUnitAttributes?: PropertyUnitAttributesUncheckedCreateNestedManyWithoutPropertyUnitsInput
    PropertyUnitProductCategories?: PropertyUnitProductCategoriesUncheckedCreateNestedManyWithoutPropertyUnitsInput
    UnitLocations?: UnitLocationsUncheckedCreateNestedManyWithoutPropertyUnitsInput
  }

  export type PropertyUnitsUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    ProductPropertyUnits?: ProductPropertyUnitsUpdateManyWithoutPropertyUnitsInput
    PropertyUnitAttributes?: PropertyUnitAttributesUpdateManyWithoutPropertyUnitsInput
    PropertyUnitProductCategories?: PropertyUnitProductCategoriesUpdateManyWithoutPropertyUnitsInput
    UnitLocations?: UnitLocationsUpdateManyWithoutPropertyUnitsInput
  }

  export type PropertyUnitsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    ProductPropertyUnits?: ProductPropertyUnitsUncheckedUpdateManyWithoutPropertyUnitsInput
    PropertyUnitAttributes?: PropertyUnitAttributesUncheckedUpdateManyWithoutPropertyUnitsInput
    PropertyUnitProductCategories?: PropertyUnitProductCategoriesUncheckedUpdateManyWithoutPropertyUnitsInput
    UnitLocations?: UnitLocationsUncheckedUpdateManyWithoutPropertyUnitsInput
  }

  export type PropertyUnitsUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PropertyUnitsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type Property_AddressesCreateInput = {
    street?: string | null
    postal_code?: string | null
    construction_type?: string | null
    withBasement?: boolean
    storyId?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    Cities: CitiesCreateNestedOneWithoutProperty_AddressesInput
    PropertyOwners: PropertyOwnersCreateNestedOneWithoutProperty_AddressesInput
    PropertySubTypes: PropertySubTypesCreateNestedOneWithoutProperty_AddressesInput
    Projects?: ProjectsCreateNestedManyWithoutProperty_AddressesInput
  }

  export type Property_AddressesUncheckedCreateInput = {
    id?: number
    street?: string | null
    property_owner_id: number
    city_id: number
    property_sub_type_id: number
    postal_code?: string | null
    construction_type?: string | null
    withBasement?: boolean
    storyId?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    Projects?: ProjectsUncheckedCreateNestedManyWithoutProperty_AddressesInput
  }

  export type Property_AddressesUpdateInput = {
    street?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    construction_type?: NullableStringFieldUpdateOperationsInput | string | null
    withBasement?: BoolFieldUpdateOperationsInput | boolean
    storyId?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    Cities?: CitiesUpdateOneRequiredWithoutProperty_AddressesInput
    PropertyOwners?: PropertyOwnersUpdateOneRequiredWithoutProperty_AddressesInput
    PropertySubTypes?: PropertySubTypesUpdateOneRequiredWithoutProperty_AddressesInput
    Projects?: ProjectsUpdateManyWithoutProperty_AddressesInput
  }

  export type Property_AddressesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    street?: NullableStringFieldUpdateOperationsInput | string | null
    property_owner_id?: IntFieldUpdateOperationsInput | number
    city_id?: IntFieldUpdateOperationsInput | number
    property_sub_type_id?: IntFieldUpdateOperationsInput | number
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    construction_type?: NullableStringFieldUpdateOperationsInput | string | null
    withBasement?: BoolFieldUpdateOperationsInput | boolean
    storyId?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    Projects?: ProjectsUncheckedUpdateManyWithoutProperty_AddressesInput
  }

  export type Property_AddressesUpdateManyMutationInput = {
    street?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    construction_type?: NullableStringFieldUpdateOperationsInput | string | null
    withBasement?: BoolFieldUpdateOperationsInput | boolean
    storyId?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type Property_AddressesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    street?: NullableStringFieldUpdateOperationsInput | string | null
    property_owner_id?: IntFieldUpdateOperationsInput | number
    city_id?: IntFieldUpdateOperationsInput | number
    property_sub_type_id?: IntFieldUpdateOperationsInput | number
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    construction_type?: NullableStringFieldUpdateOperationsInput | string | null
    withBasement?: BoolFieldUpdateOperationsInput | boolean
    storyId?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type Property_TypesCreateInput = {
    name: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    PropertySubTypes?: PropertySubTypesCreateNestedManyWithoutProperty_TypesInput
  }

  export type Property_TypesUncheckedCreateInput = {
    id?: number
    name: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    PropertySubTypes?: PropertySubTypesUncheckedCreateNestedManyWithoutProperty_TypesInput
  }

  export type Property_TypesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    PropertySubTypes?: PropertySubTypesUpdateManyWithoutProperty_TypesInput
  }

  export type Property_TypesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    PropertySubTypes?: PropertySubTypesUncheckedUpdateManyWithoutProperty_TypesInput
  }

  export type Property_TypesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type Property_TypesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ScopeOfWorkPropertyUnitsCreateInput = {
    value?: string | null
    attribute_custom_name?: string | null
    attribute_custom_value?: string | null
    attribute_custom_unit?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    AreaOfWorks: AreaOfWorksCreateNestedOneWithoutScopeOfWorkPropertyUnitsInput
    ProjectProposals: ProjectProposalsCreateNestedOneWithoutScopeOfWorkPropertyUnitsInput
    PropertyUnitAttributes: PropertyUnitAttributesCreateNestedOneWithoutScopeOfWorkPropertyUnitsInput
  }

  export type ScopeOfWorkPropertyUnitsUncheckedCreateInput = {
    id?: number
    project_proposal_id: number
    area_of_work_id: number
    property_unit_attribute_id: number
    value?: string | null
    attribute_custom_name?: string | null
    attribute_custom_value?: string | null
    attribute_custom_unit?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
  }

  export type ScopeOfWorkPropertyUnitsUpdateInput = {
    value?: NullableStringFieldUpdateOperationsInput | string | null
    attribute_custom_name?: NullableStringFieldUpdateOperationsInput | string | null
    attribute_custom_value?: NullableStringFieldUpdateOperationsInput | string | null
    attribute_custom_unit?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    AreaOfWorks?: AreaOfWorksUpdateOneRequiredWithoutScopeOfWorkPropertyUnitsInput
    ProjectProposals?: ProjectProposalsUpdateOneRequiredWithoutScopeOfWorkPropertyUnitsInput
    PropertyUnitAttributes?: PropertyUnitAttributesUpdateOneRequiredWithoutScopeOfWorkPropertyUnitsInput
  }

  export type ScopeOfWorkPropertyUnitsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    project_proposal_id?: IntFieldUpdateOperationsInput | number
    area_of_work_id?: IntFieldUpdateOperationsInput | number
    property_unit_attribute_id?: IntFieldUpdateOperationsInput | number
    value?: NullableStringFieldUpdateOperationsInput | string | null
    attribute_custom_name?: NullableStringFieldUpdateOperationsInput | string | null
    attribute_custom_value?: NullableStringFieldUpdateOperationsInput | string | null
    attribute_custom_unit?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ScopeOfWorkPropertyUnitsUpdateManyMutationInput = {
    value?: NullableStringFieldUpdateOperationsInput | string | null
    attribute_custom_name?: NullableStringFieldUpdateOperationsInput | string | null
    attribute_custom_value?: NullableStringFieldUpdateOperationsInput | string | null
    attribute_custom_unit?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ScopeOfWorkPropertyUnitsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    project_proposal_id?: IntFieldUpdateOperationsInput | number
    area_of_work_id?: IntFieldUpdateOperationsInput | number
    property_unit_attribute_id?: IntFieldUpdateOperationsInput | number
    value?: NullableStringFieldUpdateOperationsInput | string | null
    attribute_custom_name?: NullableStringFieldUpdateOperationsInput | string | null
    attribute_custom_value?: NullableStringFieldUpdateOperationsInput | string | null
    attribute_custom_unit?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ScopeOfWorksCreateInput = {
    attribute_custom_name?: string | null
    attribute_custom_value?: string | null
    attribute_custom_unit?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    AreaOfWorks: AreaOfWorksCreateNestedOneWithoutScopeOfWorksInput
    ProductAttributeUnits: ProductAttributeUnitsCreateNestedOneWithoutScopeOfWorksInput
    ProductAttributeUnitValues: ProductAttributeUnitValuesCreateNestedOneWithoutScopeOfWorksInput
    ProjectProposals: ProjectProposalsCreateNestedOneWithoutScopeOfWorksInput
  }

  export type ScopeOfWorksUncheckedCreateInput = {
    id?: number
    project_proposal_id: number
    area_of_work_id: number
    product_attribute_unit_id: number
    product_attribute_unit_value_id: number
    attribute_custom_name?: string | null
    attribute_custom_value?: string | null
    attribute_custom_unit?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
  }

  export type ScopeOfWorksUpdateInput = {
    attribute_custom_name?: NullableStringFieldUpdateOperationsInput | string | null
    attribute_custom_value?: NullableStringFieldUpdateOperationsInput | string | null
    attribute_custom_unit?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    AreaOfWorks?: AreaOfWorksUpdateOneRequiredWithoutScopeOfWorksInput
    ProductAttributeUnits?: ProductAttributeUnitsUpdateOneRequiredWithoutScopeOfWorksInput
    ProductAttributeUnitValues?: ProductAttributeUnitValuesUpdateOneRequiredWithoutScopeOfWorksInput
    ProjectProposals?: ProjectProposalsUpdateOneRequiredWithoutScopeOfWorksInput
  }

  export type ScopeOfWorksUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    project_proposal_id?: IntFieldUpdateOperationsInput | number
    area_of_work_id?: IntFieldUpdateOperationsInput | number
    product_attribute_unit_id?: IntFieldUpdateOperationsInput | number
    product_attribute_unit_value_id?: IntFieldUpdateOperationsInput | number
    attribute_custom_name?: NullableStringFieldUpdateOperationsInput | string | null
    attribute_custom_value?: NullableStringFieldUpdateOperationsInput | string | null
    attribute_custom_unit?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ScopeOfWorksUpdateManyMutationInput = {
    attribute_custom_name?: NullableStringFieldUpdateOperationsInput | string | null
    attribute_custom_value?: NullableStringFieldUpdateOperationsInput | string | null
    attribute_custom_unit?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ScopeOfWorksUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    project_proposal_id?: IntFieldUpdateOperationsInput | number
    area_of_work_id?: IntFieldUpdateOperationsInput | number
    product_attribute_unit_id?: IntFieldUpdateOperationsInput | number
    product_attribute_unit_value_id?: IntFieldUpdateOperationsInput | number
    attribute_custom_name?: NullableStringFieldUpdateOperationsInput | string | null
    attribute_custom_value?: NullableStringFieldUpdateOperationsInput | string | null
    attribute_custom_unit?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SequelizeMetaCreateInput = {
    name: string
  }

  export type SequelizeMetaUncheckedCreateInput = {
    name: string
  }

  export type SequelizeMetaUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SequelizeMetaUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SequelizeMetaUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SequelizeMetaUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type StatesCreateInput = {
    name?: string | null
    state_code: string
    status?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    Countries: CountriesCreateNestedOneWithoutStatesInput
    Cities?: CitiesCreateNestedManyWithoutStatesInput
  }

  export type StatesUncheckedCreateInput = {
    id?: number
    country_id: number
    name?: string | null
    state_code: string
    status?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    Cities?: CitiesUncheckedCreateNestedManyWithoutStatesInput
  }

  export type StatesUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    state_code?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    Countries?: CountriesUpdateOneRequiredWithoutStatesInput
    Cities?: CitiesUpdateManyWithoutStatesInput
  }

  export type StatesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    country_id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    state_code?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    Cities?: CitiesUncheckedUpdateManyWithoutStatesInput
  }

  export type StatesUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    state_code?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type StatesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    country_id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    state_code?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UnitLocationsCreateInput = {
    unit_name?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    PropertyLevels: PropertyLevelsCreateNestedOneWithoutUnitLocationsInput
    PropertySubTypes: PropertySubTypesCreateNestedOneWithoutUnitLocationsInput
    PropertyUnits: PropertyUnitsCreateNestedOneWithoutUnitLocationsInput
    AreaOfWorks?: AreaOfWorksCreateNestedManyWithoutUnitLocationsInput
  }

  export type UnitLocationsUncheckedCreateInput = {
    id?: number
    unit_name?: string | null
    property_sub_type_id: number
    property_level_id: number
    property_unit_id: number
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    AreaOfWorks?: AreaOfWorksUncheckedCreateNestedManyWithoutUnitLocationsInput
  }

  export type UnitLocationsUpdateInput = {
    unit_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    PropertyLevels?: PropertyLevelsUpdateOneRequiredWithoutUnitLocationsInput
    PropertySubTypes?: PropertySubTypesUpdateOneRequiredWithoutUnitLocationsInput
    PropertyUnits?: PropertyUnitsUpdateOneRequiredWithoutUnitLocationsInput
    AreaOfWorks?: AreaOfWorksUpdateManyWithoutUnitLocationsInput
  }

  export type UnitLocationsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    unit_name?: NullableStringFieldUpdateOperationsInput | string | null
    property_sub_type_id?: IntFieldUpdateOperationsInput | number
    property_level_id?: IntFieldUpdateOperationsInput | number
    property_unit_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    AreaOfWorks?: AreaOfWorksUncheckedUpdateManyWithoutUnitLocationsInput
  }

  export type UnitLocationsUpdateManyMutationInput = {
    unit_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UnitLocationsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    unit_name?: NullableStringFieldUpdateOperationsInput | string | null
    property_sub_type_id?: IntFieldUpdateOperationsInput | number
    property_level_id?: IntFieldUpdateOperationsInput | number
    property_unit_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UsersCreateInput = {
    user_type: string
    email: string
    status?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    username?: string | null
    email_verified?: boolean
    name?: string | null
    Backend_Users?: Backend_UsersCreateNestedManyWithoutUsersInput
    Contractors?: ContractorsCreateNestedManyWithoutUsersInput
    PropertyOwners?: PropertyOwnersCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateInput = {
    id?: number
    user_type: string
    email: string
    status?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    username?: string | null
    email_verified?: boolean
    name?: string | null
    Backend_Users?: Backend_UsersUncheckedCreateNestedManyWithoutUsersInput
    Contractors?: ContractorsUncheckedCreateNestedManyWithoutUsersInput
    PropertyOwners?: PropertyOwnersUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersUpdateInput = {
    user_type?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    name?: NullableStringFieldUpdateOperationsInput | string | null
    Backend_Users?: Backend_UsersUpdateManyWithoutUsersInput
    Contractors?: ContractorsUpdateManyWithoutUsersInput
    PropertyOwners?: PropertyOwnersUpdateManyWithoutUsersInput
  }

  export type UsersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_type?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    name?: NullableStringFieldUpdateOperationsInput | string | null
    Backend_Users?: Backend_UsersUncheckedUpdateManyWithoutUsersInput
    Contractors?: ContractorsUncheckedUpdateManyWithoutUsersInput
    PropertyOwners?: PropertyOwnersUncheckedUpdateManyWithoutUsersInput
  }

  export type UsersUpdateManyMutationInput = {
    user_type?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UsersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_type?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type ProjectProposalsRelationFilter = {
    is?: ProjectProposalsWhereInput
    isNot?: ProjectProposalsWhereInput
  }

  export type UnitLocationsRelationFilter = {
    is?: UnitLocationsWhereInput
    isNot?: UnitLocationsWhereInput
  }

  export type ScopeOfWorkPropertyUnitsListRelationFilter = {
    every?: ScopeOfWorkPropertyUnitsWhereInput
    some?: ScopeOfWorkPropertyUnitsWhereInput
    none?: ScopeOfWorkPropertyUnitsWhereInput
  }

  export type ScopeOfWorksListRelationFilter = {
    every?: ScopeOfWorksWhereInput
    some?: ScopeOfWorksWhereInput
    none?: ScopeOfWorksWhereInput
  }

  export type AttributesRelationFilter = {
    is?: AttributesWhereInput | null
    isNot?: AttributesWhereInput | null
  }

  export type AttributesListRelationFilter = {
    every?: AttributesWhereInput
    some?: AttributesWhereInput
    none?: AttributesWhereInput
  }

  export type AttributeUnitsListRelationFilter = {
    every?: AttributeUnitsWhereInput
    some?: AttributeUnitsWhereInput
    none?: AttributeUnitsWhereInput
  }

  export type ProductAttributeUnitsListRelationFilter = {
    every?: ProductAttributeUnitsWhereInput
    some?: ProductAttributeUnitsWhereInput
    none?: ProductAttributeUnitsWhereInput
  }

  export type PropertyUnitAttributesListRelationFilter = {
    every?: PropertyUnitAttributesWhereInput
    some?: PropertyUnitAttributesWhereInput
    none?: PropertyUnitAttributesWhereInput
  }

  export type UsersRelationFilter = {
    is?: UsersWhereInput
    isNot?: UsersWhereInput
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type StatesRelationFilter = {
    is?: StatesWhereInput
    isNot?: StatesWhereInput
  }

  export type Property_AddressesListRelationFilter = {
    every?: Property_AddressesWhereInput
    some?: Property_AddressesWhereInput
    none?: Property_AddressesWhereInput
  }

  export type CitiesState_id_nameCompoundUniqueInput = {
    state_id: number
    name: string
  }

  export type StatesListRelationFilter = {
    every?: StatesWhereInput
    some?: StatesWhereInput
    none?: StatesWhereInput
  }

  export type AttributeUnitsRelationFilter = {
    is?: AttributeUnitsWhereInput
    isNot?: AttributeUnitsWhereInput
  }

  export type ProductsRelationFilter = {
    is?: ProductsWhereInput | null
    isNot?: ProductsWhereInput | null
  }

  export type ProductAttributeUnitValuesListRelationFilter = {
    every?: ProductAttributeUnitValuesWhereInput
    some?: ProductAttributeUnitValuesWhereInput
    none?: ProductAttributeUnitValuesWhereInput
  }

  export type ProductAttributeUnitsRelationFilter = {
    is?: ProductAttributeUnitsWhereInput
    isNot?: ProductAttributeUnitsWhereInput
  }

  export type ProductAttributeUnitValuesProduct_attribute_unit_id_slugCompoundUniqueInput = {
    product_attribute_unit_id: number
    slug: string
  }

  export type PropertyUnitProductCategoriesListRelationFilter = {
    every?: PropertyUnitProductCategoriesWhereInput
    some?: PropertyUnitProductCategoriesWhereInput
    none?: PropertyUnitProductCategoriesWhereInput
  }

  export type PropertyUnitsRelationFilter = {
    is?: PropertyUnitsWhereInput
    isNot?: PropertyUnitsWhereInput
  }

  export type ProductPropertyUnitsProduct_property_unit_slugCompoundUniqueInput = {
    product_id: number
    property_unit_id: number
  }

  export type ProductPropertyUnitsListRelationFilter = {
    every?: ProductPropertyUnitsWhereInput
    some?: ProductPropertyUnitsWhereInput
    none?: ProductPropertyUnitsWhereInput
  }

  export type ProductsListRelationFilter = {
    every?: ProductsWhereInput
    some?: ProductsWhereInput
    none?: ProductsWhereInput
  }

  export type PropertyUnitProductCategoryProductsListRelationFilter = {
    every?: PropertyUnitProductCategoryProductsWhereInput
    some?: PropertyUnitProductCategoryProductsWhereInput
    none?: PropertyUnitProductCategoryProductsWhereInput
  }

  export type ProjectsRelationFilter = {
    is?: ProjectsWhereInput
    isNot?: ProjectsWhereInput
  }

  export type AreaOfWorksListRelationFilter = {
    every?: AreaOfWorksWhereInput
    some?: AreaOfWorksWhereInput
    none?: AreaOfWorksWhereInput
  }

  export type Property_AddressesRelationFilter = {
    is?: Property_AddressesWhereInput
    isNot?: Property_AddressesWhereInput
  }

  export type ProjectProposalsListRelationFilter = {
    every?: ProjectProposalsWhereInput
    some?: ProjectProposalsWhereInput
    none?: ProjectProposalsWhereInput
  }

  export type ProjectTypeAssociationsListRelationFilter = {
    every?: ProjectTypeAssociationsWhereInput
    some?: ProjectTypeAssociationsWhereInput
    none?: ProjectTypeAssociationsWhereInput
  }

  export type ProjectTypesRelationFilter = {
    is?: ProjectTypesWhereInput
    isNot?: ProjectTypesWhereInput
  }

  export type UnitLocationsListRelationFilter = {
    every?: UnitLocationsWhereInput
    some?: UnitLocationsWhereInput
    none?: UnitLocationsWhereInput
  }

  export type Property_TypesRelationFilter = {
    is?: Property_TypesWhereInput
    isNot?: Property_TypesWhereInput
  }

  export type ProductCategoriesRelationFilter = {
    is?: ProductCategoriesWhereInput
    isNot?: ProductCategoriesWhereInput
  }

  export type PropertyUnitProductCategoriesRelationFilter = {
    is?: PropertyUnitProductCategoriesWhereInput
    isNot?: PropertyUnitProductCategoriesWhereInput
  }

  export type CitiesRelationFilter = {
    is?: CitiesWhereInput
    isNot?: CitiesWhereInput
  }

  export type PropertyOwnersRelationFilter = {
    is?: PropertyOwnersWhereInput
    isNot?: PropertyOwnersWhereInput
  }

  export type PropertySubTypesRelationFilter = {
    is?: PropertySubTypesWhereInput
    isNot?: PropertySubTypesWhereInput
  }

  export type ProjectsListRelationFilter = {
    every?: ProjectsWhereInput
    some?: ProjectsWhereInput
    none?: ProjectsWhereInput
  }

  export type PropertySubTypesListRelationFilter = {
    every?: PropertySubTypesWhereInput
    some?: PropertySubTypesWhereInput
    none?: PropertySubTypesWhereInput
  }

  export type AreaOfWorksRelationFilter = {
    is?: AreaOfWorksWhereInput
    isNot?: AreaOfWorksWhereInput
  }

  export type PropertyUnitAttributesRelationFilter = {
    is?: PropertyUnitAttributesWhereInput
    isNot?: PropertyUnitAttributesWhereInput
  }

  export type ProductAttributeUnitValuesRelationFilter = {
    is?: ProductAttributeUnitValuesWhereInput
    isNot?: ProductAttributeUnitValuesWhereInput
  }

  export type CountriesRelationFilter = {
    is?: CountriesWhereInput
    isNot?: CountriesWhereInput
  }

  export type CitiesListRelationFilter = {
    every?: CitiesWhereInput
    some?: CitiesWhereInput
    none?: CitiesWhereInput
  }

  export type StatesCountry_id_state_codeCompoundUniqueInput = {
    country_id: number
    state_code: string
  }

  export type PropertyLevelsRelationFilter = {
    is?: PropertyLevelsWhereInput
    isNot?: PropertyLevelsWhereInput
  }

  export type UnitLocationsProduct_property_unit_slugCompoundUniqueInput = {
    property_level_id: number
    property_unit_id: number
    property_sub_type_id: number
  }

  export type Backend_UsersListRelationFilter = {
    every?: Backend_UsersWhereInput
    some?: Backend_UsersWhereInput
    none?: Backend_UsersWhereInput
  }

  export type ContractorsListRelationFilter = {
    every?: ContractorsWhereInput
    some?: ContractorsWhereInput
    none?: ContractorsWhereInput
  }

  export type PropertyOwnersListRelationFilter = {
    every?: PropertyOwnersWhereInput
    some?: PropertyOwnersWhereInput
    none?: PropertyOwnersWhereInput
  }

  export type ProjectProposalsCreateNestedOneWithoutAreaOfWorksInput = {
    create?: XOR<ProjectProposalsCreateWithoutAreaOfWorksInput, ProjectProposalsUncheckedCreateWithoutAreaOfWorksInput>
    connectOrCreate?: ProjectProposalsCreateOrConnectWithoutAreaOfWorksInput
    connect?: ProjectProposalsWhereUniqueInput
  }

  export type UnitLocationsCreateNestedOneWithoutAreaOfWorksInput = {
    create?: XOR<UnitLocationsCreateWithoutAreaOfWorksInput, UnitLocationsUncheckedCreateWithoutAreaOfWorksInput>
    connectOrCreate?: UnitLocationsCreateOrConnectWithoutAreaOfWorksInput
    connect?: UnitLocationsWhereUniqueInput
  }

  export type ScopeOfWorkPropertyUnitsCreateNestedManyWithoutAreaOfWorksInput = {
    create?: XOR<Enumerable<ScopeOfWorkPropertyUnitsCreateWithoutAreaOfWorksInput>, Enumerable<ScopeOfWorkPropertyUnitsUncheckedCreateWithoutAreaOfWorksInput>>
    connectOrCreate?: Enumerable<ScopeOfWorkPropertyUnitsCreateOrConnectWithoutAreaOfWorksInput>
    connect?: Enumerable<ScopeOfWorkPropertyUnitsWhereUniqueInput>
  }

  export type ScopeOfWorksCreateNestedManyWithoutAreaOfWorksInput = {
    create?: XOR<Enumerable<ScopeOfWorksCreateWithoutAreaOfWorksInput>, Enumerable<ScopeOfWorksUncheckedCreateWithoutAreaOfWorksInput>>
    connectOrCreate?: Enumerable<ScopeOfWorksCreateOrConnectWithoutAreaOfWorksInput>
    connect?: Enumerable<ScopeOfWorksWhereUniqueInput>
  }

  export type ScopeOfWorkPropertyUnitsUncheckedCreateNestedManyWithoutAreaOfWorksInput = {
    create?: XOR<Enumerable<ScopeOfWorkPropertyUnitsCreateWithoutAreaOfWorksInput>, Enumerable<ScopeOfWorkPropertyUnitsUncheckedCreateWithoutAreaOfWorksInput>>
    connectOrCreate?: Enumerable<ScopeOfWorkPropertyUnitsCreateOrConnectWithoutAreaOfWorksInput>
    connect?: Enumerable<ScopeOfWorkPropertyUnitsWhereUniqueInput>
  }

  export type ScopeOfWorksUncheckedCreateNestedManyWithoutAreaOfWorksInput = {
    create?: XOR<Enumerable<ScopeOfWorksCreateWithoutAreaOfWorksInput>, Enumerable<ScopeOfWorksUncheckedCreateWithoutAreaOfWorksInput>>
    connectOrCreate?: Enumerable<ScopeOfWorksCreateOrConnectWithoutAreaOfWorksInput>
    connect?: Enumerable<ScopeOfWorksWhereUniqueInput>
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProjectProposalsUpdateOneRequiredWithoutAreaOfWorksInput = {
    create?: XOR<ProjectProposalsCreateWithoutAreaOfWorksInput, ProjectProposalsUncheckedCreateWithoutAreaOfWorksInput>
    connectOrCreate?: ProjectProposalsCreateOrConnectWithoutAreaOfWorksInput
    upsert?: ProjectProposalsUpsertWithoutAreaOfWorksInput
    connect?: ProjectProposalsWhereUniqueInput
    update?: XOR<ProjectProposalsUpdateWithoutAreaOfWorksInput, ProjectProposalsUncheckedUpdateWithoutAreaOfWorksInput>
  }

  export type UnitLocationsUpdateOneRequiredWithoutAreaOfWorksInput = {
    create?: XOR<UnitLocationsCreateWithoutAreaOfWorksInput, UnitLocationsUncheckedCreateWithoutAreaOfWorksInput>
    connectOrCreate?: UnitLocationsCreateOrConnectWithoutAreaOfWorksInput
    upsert?: UnitLocationsUpsertWithoutAreaOfWorksInput
    connect?: UnitLocationsWhereUniqueInput
    update?: XOR<UnitLocationsUpdateWithoutAreaOfWorksInput, UnitLocationsUncheckedUpdateWithoutAreaOfWorksInput>
  }

  export type ScopeOfWorkPropertyUnitsUpdateManyWithoutAreaOfWorksInput = {
    create?: XOR<Enumerable<ScopeOfWorkPropertyUnitsCreateWithoutAreaOfWorksInput>, Enumerable<ScopeOfWorkPropertyUnitsUncheckedCreateWithoutAreaOfWorksInput>>
    connectOrCreate?: Enumerable<ScopeOfWorkPropertyUnitsCreateOrConnectWithoutAreaOfWorksInput>
    upsert?: Enumerable<ScopeOfWorkPropertyUnitsUpsertWithWhereUniqueWithoutAreaOfWorksInput>
    connect?: Enumerable<ScopeOfWorkPropertyUnitsWhereUniqueInput>
    set?: Enumerable<ScopeOfWorkPropertyUnitsWhereUniqueInput>
    disconnect?: Enumerable<ScopeOfWorkPropertyUnitsWhereUniqueInput>
    delete?: Enumerable<ScopeOfWorkPropertyUnitsWhereUniqueInput>
    update?: Enumerable<ScopeOfWorkPropertyUnitsUpdateWithWhereUniqueWithoutAreaOfWorksInput>
    updateMany?: Enumerable<ScopeOfWorkPropertyUnitsUpdateManyWithWhereWithoutAreaOfWorksInput>
    deleteMany?: Enumerable<ScopeOfWorkPropertyUnitsScalarWhereInput>
  }

  export type ScopeOfWorksUpdateManyWithoutAreaOfWorksInput = {
    create?: XOR<Enumerable<ScopeOfWorksCreateWithoutAreaOfWorksInput>, Enumerable<ScopeOfWorksUncheckedCreateWithoutAreaOfWorksInput>>
    connectOrCreate?: Enumerable<ScopeOfWorksCreateOrConnectWithoutAreaOfWorksInput>
    upsert?: Enumerable<ScopeOfWorksUpsertWithWhereUniqueWithoutAreaOfWorksInput>
    connect?: Enumerable<ScopeOfWorksWhereUniqueInput>
    set?: Enumerable<ScopeOfWorksWhereUniqueInput>
    disconnect?: Enumerable<ScopeOfWorksWhereUniqueInput>
    delete?: Enumerable<ScopeOfWorksWhereUniqueInput>
    update?: Enumerable<ScopeOfWorksUpdateWithWhereUniqueWithoutAreaOfWorksInput>
    updateMany?: Enumerable<ScopeOfWorksUpdateManyWithWhereWithoutAreaOfWorksInput>
    deleteMany?: Enumerable<ScopeOfWorksScalarWhereInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ScopeOfWorkPropertyUnitsUncheckedUpdateManyWithoutAreaOfWorksInput = {
    create?: XOR<Enumerable<ScopeOfWorkPropertyUnitsCreateWithoutAreaOfWorksInput>, Enumerable<ScopeOfWorkPropertyUnitsUncheckedCreateWithoutAreaOfWorksInput>>
    connectOrCreate?: Enumerable<ScopeOfWorkPropertyUnitsCreateOrConnectWithoutAreaOfWorksInput>
    upsert?: Enumerable<ScopeOfWorkPropertyUnitsUpsertWithWhereUniqueWithoutAreaOfWorksInput>
    connect?: Enumerable<ScopeOfWorkPropertyUnitsWhereUniqueInput>
    set?: Enumerable<ScopeOfWorkPropertyUnitsWhereUniqueInput>
    disconnect?: Enumerable<ScopeOfWorkPropertyUnitsWhereUniqueInput>
    delete?: Enumerable<ScopeOfWorkPropertyUnitsWhereUniqueInput>
    update?: Enumerable<ScopeOfWorkPropertyUnitsUpdateWithWhereUniqueWithoutAreaOfWorksInput>
    updateMany?: Enumerable<ScopeOfWorkPropertyUnitsUpdateManyWithWhereWithoutAreaOfWorksInput>
    deleteMany?: Enumerable<ScopeOfWorkPropertyUnitsScalarWhereInput>
  }

  export type ScopeOfWorksUncheckedUpdateManyWithoutAreaOfWorksInput = {
    create?: XOR<Enumerable<ScopeOfWorksCreateWithoutAreaOfWorksInput>, Enumerable<ScopeOfWorksUncheckedCreateWithoutAreaOfWorksInput>>
    connectOrCreate?: Enumerable<ScopeOfWorksCreateOrConnectWithoutAreaOfWorksInput>
    upsert?: Enumerable<ScopeOfWorksUpsertWithWhereUniqueWithoutAreaOfWorksInput>
    connect?: Enumerable<ScopeOfWorksWhereUniqueInput>
    set?: Enumerable<ScopeOfWorksWhereUniqueInput>
    disconnect?: Enumerable<ScopeOfWorksWhereUniqueInput>
    delete?: Enumerable<ScopeOfWorksWhereUniqueInput>
    update?: Enumerable<ScopeOfWorksUpdateWithWhereUniqueWithoutAreaOfWorksInput>
    updateMany?: Enumerable<ScopeOfWorksUpdateManyWithWhereWithoutAreaOfWorksInput>
    deleteMany?: Enumerable<ScopeOfWorksScalarWhereInput>
  }

  export type AttributesCreateNestedOneWithoutOther_AttributesInput = {
    create?: XOR<AttributesCreateWithoutOther_AttributesInput, AttributesUncheckedCreateWithoutOther_AttributesInput>
    connectOrCreate?: AttributesCreateOrConnectWithoutOther_AttributesInput
    connect?: AttributesWhereUniqueInput
  }

  export type AttributesCreateNestedManyWithoutAttributesInput = {
    create?: XOR<Enumerable<AttributesCreateWithoutAttributesInput>, Enumerable<AttributesUncheckedCreateWithoutAttributesInput>>
    connectOrCreate?: Enumerable<AttributesCreateOrConnectWithoutAttributesInput>
    connect?: Enumerable<AttributesWhereUniqueInput>
  }

  export type AttributeUnitsCreateNestedManyWithoutAttributesInput = {
    create?: XOR<Enumerable<AttributeUnitsCreateWithoutAttributesInput>, Enumerable<AttributeUnitsUncheckedCreateWithoutAttributesInput>>
    connectOrCreate?: Enumerable<AttributeUnitsCreateOrConnectWithoutAttributesInput>
    connect?: Enumerable<AttributeUnitsWhereUniqueInput>
  }

  export type ProductAttributeUnitsCreateNestedManyWithoutAttributesInput = {
    create?: XOR<Enumerable<ProductAttributeUnitsCreateWithoutAttributesInput>, Enumerable<ProductAttributeUnitsUncheckedCreateWithoutAttributesInput>>
    connectOrCreate?: Enumerable<ProductAttributeUnitsCreateOrConnectWithoutAttributesInput>
    connect?: Enumerable<ProductAttributeUnitsWhereUniqueInput>
  }

  export type PropertyUnitAttributesCreateNestedManyWithoutAttributesInput = {
    create?: XOR<Enumerable<PropertyUnitAttributesCreateWithoutAttributesInput>, Enumerable<PropertyUnitAttributesUncheckedCreateWithoutAttributesInput>>
    connectOrCreate?: Enumerable<PropertyUnitAttributesCreateOrConnectWithoutAttributesInput>
    connect?: Enumerable<PropertyUnitAttributesWhereUniqueInput>
  }

  export type AttributesUncheckedCreateNestedManyWithoutAttributesInput = {
    create?: XOR<Enumerable<AttributesCreateWithoutAttributesInput>, Enumerable<AttributesUncheckedCreateWithoutAttributesInput>>
    connectOrCreate?: Enumerable<AttributesCreateOrConnectWithoutAttributesInput>
    connect?: Enumerable<AttributesWhereUniqueInput>
  }

  export type AttributeUnitsUncheckedCreateNestedManyWithoutAttributesInput = {
    create?: XOR<Enumerable<AttributeUnitsCreateWithoutAttributesInput>, Enumerable<AttributeUnitsUncheckedCreateWithoutAttributesInput>>
    connectOrCreate?: Enumerable<AttributeUnitsCreateOrConnectWithoutAttributesInput>
    connect?: Enumerable<AttributeUnitsWhereUniqueInput>
  }

  export type ProductAttributeUnitsUncheckedCreateNestedManyWithoutAttributesInput = {
    create?: XOR<Enumerable<ProductAttributeUnitsCreateWithoutAttributesInput>, Enumerable<ProductAttributeUnitsUncheckedCreateWithoutAttributesInput>>
    connectOrCreate?: Enumerable<ProductAttributeUnitsCreateOrConnectWithoutAttributesInput>
    connect?: Enumerable<ProductAttributeUnitsWhereUniqueInput>
  }

  export type PropertyUnitAttributesUncheckedCreateNestedManyWithoutAttributesInput = {
    create?: XOR<Enumerable<PropertyUnitAttributesCreateWithoutAttributesInput>, Enumerable<PropertyUnitAttributesUncheckedCreateWithoutAttributesInput>>
    connectOrCreate?: Enumerable<PropertyUnitAttributesCreateOrConnectWithoutAttributesInput>
    connect?: Enumerable<PropertyUnitAttributesWhereUniqueInput>
  }

  export type AttributesUpdateOneWithoutOther_AttributesInput = {
    create?: XOR<AttributesCreateWithoutOther_AttributesInput, AttributesUncheckedCreateWithoutOther_AttributesInput>
    connectOrCreate?: AttributesCreateOrConnectWithoutOther_AttributesInput
    upsert?: AttributesUpsertWithoutOther_AttributesInput
    connect?: AttributesWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<AttributesUpdateWithoutOther_AttributesInput, AttributesUncheckedUpdateWithoutOther_AttributesInput>
  }

  export type AttributesUpdateManyWithoutAttributesInput = {
    create?: XOR<Enumerable<AttributesCreateWithoutAttributesInput>, Enumerable<AttributesUncheckedCreateWithoutAttributesInput>>
    connectOrCreate?: Enumerable<AttributesCreateOrConnectWithoutAttributesInput>
    upsert?: Enumerable<AttributesUpsertWithWhereUniqueWithoutAttributesInput>
    connect?: Enumerable<AttributesWhereUniqueInput>
    set?: Enumerable<AttributesWhereUniqueInput>
    disconnect?: Enumerable<AttributesWhereUniqueInput>
    delete?: Enumerable<AttributesWhereUniqueInput>
    update?: Enumerable<AttributesUpdateWithWhereUniqueWithoutAttributesInput>
    updateMany?: Enumerable<AttributesUpdateManyWithWhereWithoutAttributesInput>
    deleteMany?: Enumerable<AttributesScalarWhereInput>
  }

  export type AttributeUnitsUpdateManyWithoutAttributesInput = {
    create?: XOR<Enumerable<AttributeUnitsCreateWithoutAttributesInput>, Enumerable<AttributeUnitsUncheckedCreateWithoutAttributesInput>>
    connectOrCreate?: Enumerable<AttributeUnitsCreateOrConnectWithoutAttributesInput>
    upsert?: Enumerable<AttributeUnitsUpsertWithWhereUniqueWithoutAttributesInput>
    connect?: Enumerable<AttributeUnitsWhereUniqueInput>
    set?: Enumerable<AttributeUnitsWhereUniqueInput>
    disconnect?: Enumerable<AttributeUnitsWhereUniqueInput>
    delete?: Enumerable<AttributeUnitsWhereUniqueInput>
    update?: Enumerable<AttributeUnitsUpdateWithWhereUniqueWithoutAttributesInput>
    updateMany?: Enumerable<AttributeUnitsUpdateManyWithWhereWithoutAttributesInput>
    deleteMany?: Enumerable<AttributeUnitsScalarWhereInput>
  }

  export type ProductAttributeUnitsUpdateManyWithoutAttributesInput = {
    create?: XOR<Enumerable<ProductAttributeUnitsCreateWithoutAttributesInput>, Enumerable<ProductAttributeUnitsUncheckedCreateWithoutAttributesInput>>
    connectOrCreate?: Enumerable<ProductAttributeUnitsCreateOrConnectWithoutAttributesInput>
    upsert?: Enumerable<ProductAttributeUnitsUpsertWithWhereUniqueWithoutAttributesInput>
    connect?: Enumerable<ProductAttributeUnitsWhereUniqueInput>
    set?: Enumerable<ProductAttributeUnitsWhereUniqueInput>
    disconnect?: Enumerable<ProductAttributeUnitsWhereUniqueInput>
    delete?: Enumerable<ProductAttributeUnitsWhereUniqueInput>
    update?: Enumerable<ProductAttributeUnitsUpdateWithWhereUniqueWithoutAttributesInput>
    updateMany?: Enumerable<ProductAttributeUnitsUpdateManyWithWhereWithoutAttributesInput>
    deleteMany?: Enumerable<ProductAttributeUnitsScalarWhereInput>
  }

  export type PropertyUnitAttributesUpdateManyWithoutAttributesInput = {
    create?: XOR<Enumerable<PropertyUnitAttributesCreateWithoutAttributesInput>, Enumerable<PropertyUnitAttributesUncheckedCreateWithoutAttributesInput>>
    connectOrCreate?: Enumerable<PropertyUnitAttributesCreateOrConnectWithoutAttributesInput>
    upsert?: Enumerable<PropertyUnitAttributesUpsertWithWhereUniqueWithoutAttributesInput>
    connect?: Enumerable<PropertyUnitAttributesWhereUniqueInput>
    set?: Enumerable<PropertyUnitAttributesWhereUniqueInput>
    disconnect?: Enumerable<PropertyUnitAttributesWhereUniqueInput>
    delete?: Enumerable<PropertyUnitAttributesWhereUniqueInput>
    update?: Enumerable<PropertyUnitAttributesUpdateWithWhereUniqueWithoutAttributesInput>
    updateMany?: Enumerable<PropertyUnitAttributesUpdateManyWithWhereWithoutAttributesInput>
    deleteMany?: Enumerable<PropertyUnitAttributesScalarWhereInput>
  }

  export type AttributesUncheckedUpdateManyWithoutAttributesInput = {
    create?: XOR<Enumerable<AttributesCreateWithoutAttributesInput>, Enumerable<AttributesUncheckedCreateWithoutAttributesInput>>
    connectOrCreate?: Enumerable<AttributesCreateOrConnectWithoutAttributesInput>
    upsert?: Enumerable<AttributesUpsertWithWhereUniqueWithoutAttributesInput>
    connect?: Enumerable<AttributesWhereUniqueInput>
    set?: Enumerable<AttributesWhereUniqueInput>
    disconnect?: Enumerable<AttributesWhereUniqueInput>
    delete?: Enumerable<AttributesWhereUniqueInput>
    update?: Enumerable<AttributesUpdateWithWhereUniqueWithoutAttributesInput>
    updateMany?: Enumerable<AttributesUpdateManyWithWhereWithoutAttributesInput>
    deleteMany?: Enumerable<AttributesScalarWhereInput>
  }

  export type AttributeUnitsUncheckedUpdateManyWithoutAttributesInput = {
    create?: XOR<Enumerable<AttributeUnitsCreateWithoutAttributesInput>, Enumerable<AttributeUnitsUncheckedCreateWithoutAttributesInput>>
    connectOrCreate?: Enumerable<AttributeUnitsCreateOrConnectWithoutAttributesInput>
    upsert?: Enumerable<AttributeUnitsUpsertWithWhereUniqueWithoutAttributesInput>
    connect?: Enumerable<AttributeUnitsWhereUniqueInput>
    set?: Enumerable<AttributeUnitsWhereUniqueInput>
    disconnect?: Enumerable<AttributeUnitsWhereUniqueInput>
    delete?: Enumerable<AttributeUnitsWhereUniqueInput>
    update?: Enumerable<AttributeUnitsUpdateWithWhereUniqueWithoutAttributesInput>
    updateMany?: Enumerable<AttributeUnitsUpdateManyWithWhereWithoutAttributesInput>
    deleteMany?: Enumerable<AttributeUnitsScalarWhereInput>
  }

  export type ProductAttributeUnitsUncheckedUpdateManyWithoutAttributesInput = {
    create?: XOR<Enumerable<ProductAttributeUnitsCreateWithoutAttributesInput>, Enumerable<ProductAttributeUnitsUncheckedCreateWithoutAttributesInput>>
    connectOrCreate?: Enumerable<ProductAttributeUnitsCreateOrConnectWithoutAttributesInput>
    upsert?: Enumerable<ProductAttributeUnitsUpsertWithWhereUniqueWithoutAttributesInput>
    connect?: Enumerable<ProductAttributeUnitsWhereUniqueInput>
    set?: Enumerable<ProductAttributeUnitsWhereUniqueInput>
    disconnect?: Enumerable<ProductAttributeUnitsWhereUniqueInput>
    delete?: Enumerable<ProductAttributeUnitsWhereUniqueInput>
    update?: Enumerable<ProductAttributeUnitsUpdateWithWhereUniqueWithoutAttributesInput>
    updateMany?: Enumerable<ProductAttributeUnitsUpdateManyWithWhereWithoutAttributesInput>
    deleteMany?: Enumerable<ProductAttributeUnitsScalarWhereInput>
  }

  export type PropertyUnitAttributesUncheckedUpdateManyWithoutAttributesInput = {
    create?: XOR<Enumerable<PropertyUnitAttributesCreateWithoutAttributesInput>, Enumerable<PropertyUnitAttributesUncheckedCreateWithoutAttributesInput>>
    connectOrCreate?: Enumerable<PropertyUnitAttributesCreateOrConnectWithoutAttributesInput>
    upsert?: Enumerable<PropertyUnitAttributesUpsertWithWhereUniqueWithoutAttributesInput>
    connect?: Enumerable<PropertyUnitAttributesWhereUniqueInput>
    set?: Enumerable<PropertyUnitAttributesWhereUniqueInput>
    disconnect?: Enumerable<PropertyUnitAttributesWhereUniqueInput>
    delete?: Enumerable<PropertyUnitAttributesWhereUniqueInput>
    update?: Enumerable<PropertyUnitAttributesUpdateWithWhereUniqueWithoutAttributesInput>
    updateMany?: Enumerable<PropertyUnitAttributesUpdateManyWithWhereWithoutAttributesInput>
    deleteMany?: Enumerable<PropertyUnitAttributesScalarWhereInput>
  }

  export type AttributesCreateNestedOneWithoutAttributeUnitsInput = {
    create?: XOR<AttributesCreateWithoutAttributeUnitsInput, AttributesUncheckedCreateWithoutAttributeUnitsInput>
    connectOrCreate?: AttributesCreateOrConnectWithoutAttributeUnitsInput
    connect?: AttributesWhereUniqueInput
  }

  export type ProductAttributeUnitsCreateNestedManyWithoutAttributeUnitsInput = {
    create?: XOR<Enumerable<ProductAttributeUnitsCreateWithoutAttributeUnitsInput>, Enumerable<ProductAttributeUnitsUncheckedCreateWithoutAttributeUnitsInput>>
    connectOrCreate?: Enumerable<ProductAttributeUnitsCreateOrConnectWithoutAttributeUnitsInput>
    connect?: Enumerable<ProductAttributeUnitsWhereUniqueInput>
  }

  export type PropertyUnitAttributesCreateNestedManyWithoutAttributeUnitsInput = {
    create?: XOR<Enumerable<PropertyUnitAttributesCreateWithoutAttributeUnitsInput>, Enumerable<PropertyUnitAttributesUncheckedCreateWithoutAttributeUnitsInput>>
    connectOrCreate?: Enumerable<PropertyUnitAttributesCreateOrConnectWithoutAttributeUnitsInput>
    connect?: Enumerable<PropertyUnitAttributesWhereUniqueInput>
  }

  export type ProductAttributeUnitsUncheckedCreateNestedManyWithoutAttributeUnitsInput = {
    create?: XOR<Enumerable<ProductAttributeUnitsCreateWithoutAttributeUnitsInput>, Enumerable<ProductAttributeUnitsUncheckedCreateWithoutAttributeUnitsInput>>
    connectOrCreate?: Enumerable<ProductAttributeUnitsCreateOrConnectWithoutAttributeUnitsInput>
    connect?: Enumerable<ProductAttributeUnitsWhereUniqueInput>
  }

  export type PropertyUnitAttributesUncheckedCreateNestedManyWithoutAttributeUnitsInput = {
    create?: XOR<Enumerable<PropertyUnitAttributesCreateWithoutAttributeUnitsInput>, Enumerable<PropertyUnitAttributesUncheckedCreateWithoutAttributeUnitsInput>>
    connectOrCreate?: Enumerable<PropertyUnitAttributesCreateOrConnectWithoutAttributeUnitsInput>
    connect?: Enumerable<PropertyUnitAttributesWhereUniqueInput>
  }

  export type AttributesUpdateOneWithoutAttributeUnitsInput = {
    create?: XOR<AttributesCreateWithoutAttributeUnitsInput, AttributesUncheckedCreateWithoutAttributeUnitsInput>
    connectOrCreate?: AttributesCreateOrConnectWithoutAttributeUnitsInput
    upsert?: AttributesUpsertWithoutAttributeUnitsInput
    connect?: AttributesWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<AttributesUpdateWithoutAttributeUnitsInput, AttributesUncheckedUpdateWithoutAttributeUnitsInput>
  }

  export type ProductAttributeUnitsUpdateManyWithoutAttributeUnitsInput = {
    create?: XOR<Enumerable<ProductAttributeUnitsCreateWithoutAttributeUnitsInput>, Enumerable<ProductAttributeUnitsUncheckedCreateWithoutAttributeUnitsInput>>
    connectOrCreate?: Enumerable<ProductAttributeUnitsCreateOrConnectWithoutAttributeUnitsInput>
    upsert?: Enumerable<ProductAttributeUnitsUpsertWithWhereUniqueWithoutAttributeUnitsInput>
    connect?: Enumerable<ProductAttributeUnitsWhereUniqueInput>
    set?: Enumerable<ProductAttributeUnitsWhereUniqueInput>
    disconnect?: Enumerable<ProductAttributeUnitsWhereUniqueInput>
    delete?: Enumerable<ProductAttributeUnitsWhereUniqueInput>
    update?: Enumerable<ProductAttributeUnitsUpdateWithWhereUniqueWithoutAttributeUnitsInput>
    updateMany?: Enumerable<ProductAttributeUnitsUpdateManyWithWhereWithoutAttributeUnitsInput>
    deleteMany?: Enumerable<ProductAttributeUnitsScalarWhereInput>
  }

  export type PropertyUnitAttributesUpdateManyWithoutAttributeUnitsInput = {
    create?: XOR<Enumerable<PropertyUnitAttributesCreateWithoutAttributeUnitsInput>, Enumerable<PropertyUnitAttributesUncheckedCreateWithoutAttributeUnitsInput>>
    connectOrCreate?: Enumerable<PropertyUnitAttributesCreateOrConnectWithoutAttributeUnitsInput>
    upsert?: Enumerable<PropertyUnitAttributesUpsertWithWhereUniqueWithoutAttributeUnitsInput>
    connect?: Enumerable<PropertyUnitAttributesWhereUniqueInput>
    set?: Enumerable<PropertyUnitAttributesWhereUniqueInput>
    disconnect?: Enumerable<PropertyUnitAttributesWhereUniqueInput>
    delete?: Enumerable<PropertyUnitAttributesWhereUniqueInput>
    update?: Enumerable<PropertyUnitAttributesUpdateWithWhereUniqueWithoutAttributeUnitsInput>
    updateMany?: Enumerable<PropertyUnitAttributesUpdateManyWithWhereWithoutAttributeUnitsInput>
    deleteMany?: Enumerable<PropertyUnitAttributesScalarWhereInput>
  }

  export type ProductAttributeUnitsUncheckedUpdateManyWithoutAttributeUnitsInput = {
    create?: XOR<Enumerable<ProductAttributeUnitsCreateWithoutAttributeUnitsInput>, Enumerable<ProductAttributeUnitsUncheckedCreateWithoutAttributeUnitsInput>>
    connectOrCreate?: Enumerable<ProductAttributeUnitsCreateOrConnectWithoutAttributeUnitsInput>
    upsert?: Enumerable<ProductAttributeUnitsUpsertWithWhereUniqueWithoutAttributeUnitsInput>
    connect?: Enumerable<ProductAttributeUnitsWhereUniqueInput>
    set?: Enumerable<ProductAttributeUnitsWhereUniqueInput>
    disconnect?: Enumerable<ProductAttributeUnitsWhereUniqueInput>
    delete?: Enumerable<ProductAttributeUnitsWhereUniqueInput>
    update?: Enumerable<ProductAttributeUnitsUpdateWithWhereUniqueWithoutAttributeUnitsInput>
    updateMany?: Enumerable<ProductAttributeUnitsUpdateManyWithWhereWithoutAttributeUnitsInput>
    deleteMany?: Enumerable<ProductAttributeUnitsScalarWhereInput>
  }

  export type PropertyUnitAttributesUncheckedUpdateManyWithoutAttributeUnitsInput = {
    create?: XOR<Enumerable<PropertyUnitAttributesCreateWithoutAttributeUnitsInput>, Enumerable<PropertyUnitAttributesUncheckedCreateWithoutAttributeUnitsInput>>
    connectOrCreate?: Enumerable<PropertyUnitAttributesCreateOrConnectWithoutAttributeUnitsInput>
    upsert?: Enumerable<PropertyUnitAttributesUpsertWithWhereUniqueWithoutAttributeUnitsInput>
    connect?: Enumerable<PropertyUnitAttributesWhereUniqueInput>
    set?: Enumerable<PropertyUnitAttributesWhereUniqueInput>
    disconnect?: Enumerable<PropertyUnitAttributesWhereUniqueInput>
    delete?: Enumerable<PropertyUnitAttributesWhereUniqueInput>
    update?: Enumerable<PropertyUnitAttributesUpdateWithWhereUniqueWithoutAttributeUnitsInput>
    updateMany?: Enumerable<PropertyUnitAttributesUpdateManyWithWhereWithoutAttributeUnitsInput>
    deleteMany?: Enumerable<PropertyUnitAttributesScalarWhereInput>
  }

  export type UsersCreateNestedOneWithoutBackend_UsersInput = {
    create?: XOR<UsersCreateWithoutBackend_UsersInput, UsersUncheckedCreateWithoutBackend_UsersInput>
    connectOrCreate?: UsersCreateOrConnectWithoutBackend_UsersInput
    connect?: UsersWhereUniqueInput
  }

  export type UsersUpdateOneRequiredWithoutBackend_UsersInput = {
    create?: XOR<UsersCreateWithoutBackend_UsersInput, UsersUncheckedCreateWithoutBackend_UsersInput>
    connectOrCreate?: UsersCreateOrConnectWithoutBackend_UsersInput
    upsert?: UsersUpsertWithoutBackend_UsersInput
    connect?: UsersWhereUniqueInput
    update?: XOR<UsersUpdateWithoutBackend_UsersInput, UsersUncheckedUpdateWithoutBackend_UsersInput>
  }

  export type StatesCreateNestedOneWithoutCitiesInput = {
    create?: XOR<StatesCreateWithoutCitiesInput, StatesUncheckedCreateWithoutCitiesInput>
    connectOrCreate?: StatesCreateOrConnectWithoutCitiesInput
    connect?: StatesWhereUniqueInput
  }

  export type Property_AddressesCreateNestedManyWithoutCitiesInput = {
    create?: XOR<Enumerable<Property_AddressesCreateWithoutCitiesInput>, Enumerable<Property_AddressesUncheckedCreateWithoutCitiesInput>>
    connectOrCreate?: Enumerable<Property_AddressesCreateOrConnectWithoutCitiesInput>
    connect?: Enumerable<Property_AddressesWhereUniqueInput>
  }

  export type Property_AddressesUncheckedCreateNestedManyWithoutCitiesInput = {
    create?: XOR<Enumerable<Property_AddressesCreateWithoutCitiesInput>, Enumerable<Property_AddressesUncheckedCreateWithoutCitiesInput>>
    connectOrCreate?: Enumerable<Property_AddressesCreateOrConnectWithoutCitiesInput>
    connect?: Enumerable<Property_AddressesWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type StatesUpdateOneRequiredWithoutCitiesInput = {
    create?: XOR<StatesCreateWithoutCitiesInput, StatesUncheckedCreateWithoutCitiesInput>
    connectOrCreate?: StatesCreateOrConnectWithoutCitiesInput
    upsert?: StatesUpsertWithoutCitiesInput
    connect?: StatesWhereUniqueInput
    update?: XOR<StatesUpdateWithoutCitiesInput, StatesUncheckedUpdateWithoutCitiesInput>
  }

  export type Property_AddressesUpdateManyWithoutCitiesInput = {
    create?: XOR<Enumerable<Property_AddressesCreateWithoutCitiesInput>, Enumerable<Property_AddressesUncheckedCreateWithoutCitiesInput>>
    connectOrCreate?: Enumerable<Property_AddressesCreateOrConnectWithoutCitiesInput>
    upsert?: Enumerable<Property_AddressesUpsertWithWhereUniqueWithoutCitiesInput>
    connect?: Enumerable<Property_AddressesWhereUniqueInput>
    set?: Enumerable<Property_AddressesWhereUniqueInput>
    disconnect?: Enumerable<Property_AddressesWhereUniqueInput>
    delete?: Enumerable<Property_AddressesWhereUniqueInput>
    update?: Enumerable<Property_AddressesUpdateWithWhereUniqueWithoutCitiesInput>
    updateMany?: Enumerable<Property_AddressesUpdateManyWithWhereWithoutCitiesInput>
    deleteMany?: Enumerable<Property_AddressesScalarWhereInput>
  }

  export type Property_AddressesUncheckedUpdateManyWithoutCitiesInput = {
    create?: XOR<Enumerable<Property_AddressesCreateWithoutCitiesInput>, Enumerable<Property_AddressesUncheckedCreateWithoutCitiesInput>>
    connectOrCreate?: Enumerable<Property_AddressesCreateOrConnectWithoutCitiesInput>
    upsert?: Enumerable<Property_AddressesUpsertWithWhereUniqueWithoutCitiesInput>
    connect?: Enumerable<Property_AddressesWhereUniqueInput>
    set?: Enumerable<Property_AddressesWhereUniqueInput>
    disconnect?: Enumerable<Property_AddressesWhereUniqueInput>
    delete?: Enumerable<Property_AddressesWhereUniqueInput>
    update?: Enumerable<Property_AddressesUpdateWithWhereUniqueWithoutCitiesInput>
    updateMany?: Enumerable<Property_AddressesUpdateManyWithWhereWithoutCitiesInput>
    deleteMany?: Enumerable<Property_AddressesScalarWhereInput>
  }

  export type UsersCreateNestedOneWithoutContractorsInput = {
    create?: XOR<UsersCreateWithoutContractorsInput, UsersUncheckedCreateWithoutContractorsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutContractorsInput
    connect?: UsersWhereUniqueInput
  }

  export type UsersUpdateOneRequiredWithoutContractorsInput = {
    create?: XOR<UsersCreateWithoutContractorsInput, UsersUncheckedCreateWithoutContractorsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutContractorsInput
    upsert?: UsersUpsertWithoutContractorsInput
    connect?: UsersWhereUniqueInput
    update?: XOR<UsersUpdateWithoutContractorsInput, UsersUncheckedUpdateWithoutContractorsInput>
  }

  export type StatesCreateNestedManyWithoutCountriesInput = {
    create?: XOR<Enumerable<StatesCreateWithoutCountriesInput>, Enumerable<StatesUncheckedCreateWithoutCountriesInput>>
    connectOrCreate?: Enumerable<StatesCreateOrConnectWithoutCountriesInput>
    connect?: Enumerable<StatesWhereUniqueInput>
  }

  export type StatesUncheckedCreateNestedManyWithoutCountriesInput = {
    create?: XOR<Enumerable<StatesCreateWithoutCountriesInput>, Enumerable<StatesUncheckedCreateWithoutCountriesInput>>
    connectOrCreate?: Enumerable<StatesCreateOrConnectWithoutCountriesInput>
    connect?: Enumerable<StatesWhereUniqueInput>
  }

  export type StatesUpdateManyWithoutCountriesInput = {
    create?: XOR<Enumerable<StatesCreateWithoutCountriesInput>, Enumerable<StatesUncheckedCreateWithoutCountriesInput>>
    connectOrCreate?: Enumerable<StatesCreateOrConnectWithoutCountriesInput>
    upsert?: Enumerable<StatesUpsertWithWhereUniqueWithoutCountriesInput>
    connect?: Enumerable<StatesWhereUniqueInput>
    set?: Enumerable<StatesWhereUniqueInput>
    disconnect?: Enumerable<StatesWhereUniqueInput>
    delete?: Enumerable<StatesWhereUniqueInput>
    update?: Enumerable<StatesUpdateWithWhereUniqueWithoutCountriesInput>
    updateMany?: Enumerable<StatesUpdateManyWithWhereWithoutCountriesInput>
    deleteMany?: Enumerable<StatesScalarWhereInput>
  }

  export type StatesUncheckedUpdateManyWithoutCountriesInput = {
    create?: XOR<Enumerable<StatesCreateWithoutCountriesInput>, Enumerable<StatesUncheckedCreateWithoutCountriesInput>>
    connectOrCreate?: Enumerable<StatesCreateOrConnectWithoutCountriesInput>
    upsert?: Enumerable<StatesUpsertWithWhereUniqueWithoutCountriesInput>
    connect?: Enumerable<StatesWhereUniqueInput>
    set?: Enumerable<StatesWhereUniqueInput>
    disconnect?: Enumerable<StatesWhereUniqueInput>
    delete?: Enumerable<StatesWhereUniqueInput>
    update?: Enumerable<StatesUpdateWithWhereUniqueWithoutCountriesInput>
    updateMany?: Enumerable<StatesUpdateManyWithWhereWithoutCountriesInput>
    deleteMany?: Enumerable<StatesScalarWhereInput>
  }

  export type AttributesCreateNestedOneWithoutProductAttributeUnitsInput = {
    create?: XOR<AttributesCreateWithoutProductAttributeUnitsInput, AttributesUncheckedCreateWithoutProductAttributeUnitsInput>
    connectOrCreate?: AttributesCreateOrConnectWithoutProductAttributeUnitsInput
    connect?: AttributesWhereUniqueInput
  }

  export type AttributeUnitsCreateNestedOneWithoutProductAttributeUnitsInput = {
    create?: XOR<AttributeUnitsCreateWithoutProductAttributeUnitsInput, AttributeUnitsUncheckedCreateWithoutProductAttributeUnitsInput>
    connectOrCreate?: AttributeUnitsCreateOrConnectWithoutProductAttributeUnitsInput
    connect?: AttributeUnitsWhereUniqueInput
  }

  export type ProductsCreateNestedOneWithoutProductAttributeUnitsInput = {
    create?: XOR<ProductsCreateWithoutProductAttributeUnitsInput, ProductsUncheckedCreateWithoutProductAttributeUnitsInput>
    connectOrCreate?: ProductsCreateOrConnectWithoutProductAttributeUnitsInput
    connect?: ProductsWhereUniqueInput
  }

  export type ProductAttributeUnitValuesCreateNestedManyWithoutProductAttributeUnitsInput = {
    create?: XOR<Enumerable<ProductAttributeUnitValuesCreateWithoutProductAttributeUnitsInput>, Enumerable<ProductAttributeUnitValuesUncheckedCreateWithoutProductAttributeUnitsInput>>
    connectOrCreate?: Enumerable<ProductAttributeUnitValuesCreateOrConnectWithoutProductAttributeUnitsInput>
    connect?: Enumerable<ProductAttributeUnitValuesWhereUniqueInput>
  }

  export type ScopeOfWorksCreateNestedManyWithoutProductAttributeUnitsInput = {
    create?: XOR<Enumerable<ScopeOfWorksCreateWithoutProductAttributeUnitsInput>, Enumerable<ScopeOfWorksUncheckedCreateWithoutProductAttributeUnitsInput>>
    connectOrCreate?: Enumerable<ScopeOfWorksCreateOrConnectWithoutProductAttributeUnitsInput>
    connect?: Enumerable<ScopeOfWorksWhereUniqueInput>
  }

  export type ProductAttributeUnitValuesUncheckedCreateNestedManyWithoutProductAttributeUnitsInput = {
    create?: XOR<Enumerable<ProductAttributeUnitValuesCreateWithoutProductAttributeUnitsInput>, Enumerable<ProductAttributeUnitValuesUncheckedCreateWithoutProductAttributeUnitsInput>>
    connectOrCreate?: Enumerable<ProductAttributeUnitValuesCreateOrConnectWithoutProductAttributeUnitsInput>
    connect?: Enumerable<ProductAttributeUnitValuesWhereUniqueInput>
  }

  export type ScopeOfWorksUncheckedCreateNestedManyWithoutProductAttributeUnitsInput = {
    create?: XOR<Enumerable<ScopeOfWorksCreateWithoutProductAttributeUnitsInput>, Enumerable<ScopeOfWorksUncheckedCreateWithoutProductAttributeUnitsInput>>
    connectOrCreate?: Enumerable<ScopeOfWorksCreateOrConnectWithoutProductAttributeUnitsInput>
    connect?: Enumerable<ScopeOfWorksWhereUniqueInput>
  }

  export type AttributesUpdateOneRequiredWithoutProductAttributeUnitsInput = {
    create?: XOR<AttributesCreateWithoutProductAttributeUnitsInput, AttributesUncheckedCreateWithoutProductAttributeUnitsInput>
    connectOrCreate?: AttributesCreateOrConnectWithoutProductAttributeUnitsInput
    upsert?: AttributesUpsertWithoutProductAttributeUnitsInput
    connect?: AttributesWhereUniqueInput
    update?: XOR<AttributesUpdateWithoutProductAttributeUnitsInput, AttributesUncheckedUpdateWithoutProductAttributeUnitsInput>
  }

  export type AttributeUnitsUpdateOneRequiredWithoutProductAttributeUnitsInput = {
    create?: XOR<AttributeUnitsCreateWithoutProductAttributeUnitsInput, AttributeUnitsUncheckedCreateWithoutProductAttributeUnitsInput>
    connectOrCreate?: AttributeUnitsCreateOrConnectWithoutProductAttributeUnitsInput
    upsert?: AttributeUnitsUpsertWithoutProductAttributeUnitsInput
    connect?: AttributeUnitsWhereUniqueInput
    update?: XOR<AttributeUnitsUpdateWithoutProductAttributeUnitsInput, AttributeUnitsUncheckedUpdateWithoutProductAttributeUnitsInput>
  }

  export type ProductsUpdateOneRequiredWithoutProductAttributeUnitsInput = {
    create?: XOR<ProductsCreateWithoutProductAttributeUnitsInput, ProductsUncheckedCreateWithoutProductAttributeUnitsInput>
    connectOrCreate?: ProductsCreateOrConnectWithoutProductAttributeUnitsInput
    upsert?: ProductsUpsertWithoutProductAttributeUnitsInput
    connect?: ProductsWhereUniqueInput
    update?: XOR<ProductsUpdateWithoutProductAttributeUnitsInput, ProductsUncheckedUpdateWithoutProductAttributeUnitsInput>
  }

  export type ProductAttributeUnitValuesUpdateManyWithoutProductAttributeUnitsInput = {
    create?: XOR<Enumerable<ProductAttributeUnitValuesCreateWithoutProductAttributeUnitsInput>, Enumerable<ProductAttributeUnitValuesUncheckedCreateWithoutProductAttributeUnitsInput>>
    connectOrCreate?: Enumerable<ProductAttributeUnitValuesCreateOrConnectWithoutProductAttributeUnitsInput>
    upsert?: Enumerable<ProductAttributeUnitValuesUpsertWithWhereUniqueWithoutProductAttributeUnitsInput>
    connect?: Enumerable<ProductAttributeUnitValuesWhereUniqueInput>
    set?: Enumerable<ProductAttributeUnitValuesWhereUniqueInput>
    disconnect?: Enumerable<ProductAttributeUnitValuesWhereUniqueInput>
    delete?: Enumerable<ProductAttributeUnitValuesWhereUniqueInput>
    update?: Enumerable<ProductAttributeUnitValuesUpdateWithWhereUniqueWithoutProductAttributeUnitsInput>
    updateMany?: Enumerable<ProductAttributeUnitValuesUpdateManyWithWhereWithoutProductAttributeUnitsInput>
    deleteMany?: Enumerable<ProductAttributeUnitValuesScalarWhereInput>
  }

  export type ScopeOfWorksUpdateManyWithoutProductAttributeUnitsInput = {
    create?: XOR<Enumerable<ScopeOfWorksCreateWithoutProductAttributeUnitsInput>, Enumerable<ScopeOfWorksUncheckedCreateWithoutProductAttributeUnitsInput>>
    connectOrCreate?: Enumerable<ScopeOfWorksCreateOrConnectWithoutProductAttributeUnitsInput>
    upsert?: Enumerable<ScopeOfWorksUpsertWithWhereUniqueWithoutProductAttributeUnitsInput>
    connect?: Enumerable<ScopeOfWorksWhereUniqueInput>
    set?: Enumerable<ScopeOfWorksWhereUniqueInput>
    disconnect?: Enumerable<ScopeOfWorksWhereUniqueInput>
    delete?: Enumerable<ScopeOfWorksWhereUniqueInput>
    update?: Enumerable<ScopeOfWorksUpdateWithWhereUniqueWithoutProductAttributeUnitsInput>
    updateMany?: Enumerable<ScopeOfWorksUpdateManyWithWhereWithoutProductAttributeUnitsInput>
    deleteMany?: Enumerable<ScopeOfWorksScalarWhereInput>
  }

  export type ProductAttributeUnitValuesUncheckedUpdateManyWithoutProductAttributeUnitsInput = {
    create?: XOR<Enumerable<ProductAttributeUnitValuesCreateWithoutProductAttributeUnitsInput>, Enumerable<ProductAttributeUnitValuesUncheckedCreateWithoutProductAttributeUnitsInput>>
    connectOrCreate?: Enumerable<ProductAttributeUnitValuesCreateOrConnectWithoutProductAttributeUnitsInput>
    upsert?: Enumerable<ProductAttributeUnitValuesUpsertWithWhereUniqueWithoutProductAttributeUnitsInput>
    connect?: Enumerable<ProductAttributeUnitValuesWhereUniqueInput>
    set?: Enumerable<ProductAttributeUnitValuesWhereUniqueInput>
    disconnect?: Enumerable<ProductAttributeUnitValuesWhereUniqueInput>
    delete?: Enumerable<ProductAttributeUnitValuesWhereUniqueInput>
    update?: Enumerable<ProductAttributeUnitValuesUpdateWithWhereUniqueWithoutProductAttributeUnitsInput>
    updateMany?: Enumerable<ProductAttributeUnitValuesUpdateManyWithWhereWithoutProductAttributeUnitsInput>
    deleteMany?: Enumerable<ProductAttributeUnitValuesScalarWhereInput>
  }

  export type ScopeOfWorksUncheckedUpdateManyWithoutProductAttributeUnitsInput = {
    create?: XOR<Enumerable<ScopeOfWorksCreateWithoutProductAttributeUnitsInput>, Enumerable<ScopeOfWorksUncheckedCreateWithoutProductAttributeUnitsInput>>
    connectOrCreate?: Enumerable<ScopeOfWorksCreateOrConnectWithoutProductAttributeUnitsInput>
    upsert?: Enumerable<ScopeOfWorksUpsertWithWhereUniqueWithoutProductAttributeUnitsInput>
    connect?: Enumerable<ScopeOfWorksWhereUniqueInput>
    set?: Enumerable<ScopeOfWorksWhereUniqueInput>
    disconnect?: Enumerable<ScopeOfWorksWhereUniqueInput>
    delete?: Enumerable<ScopeOfWorksWhereUniqueInput>
    update?: Enumerable<ScopeOfWorksUpdateWithWhereUniqueWithoutProductAttributeUnitsInput>
    updateMany?: Enumerable<ScopeOfWorksUpdateManyWithWhereWithoutProductAttributeUnitsInput>
    deleteMany?: Enumerable<ScopeOfWorksScalarWhereInput>
  }

  export type ProductAttributeUnitsCreateNestedOneWithoutProductAttributeUnitValuesInput = {
    create?: XOR<ProductAttributeUnitsCreateWithoutProductAttributeUnitValuesInput, ProductAttributeUnitsUncheckedCreateWithoutProductAttributeUnitValuesInput>
    connectOrCreate?: ProductAttributeUnitsCreateOrConnectWithoutProductAttributeUnitValuesInput
    connect?: ProductAttributeUnitsWhereUniqueInput
  }

  export type ScopeOfWorksCreateNestedManyWithoutProductAttributeUnitValuesInput = {
    create?: XOR<Enumerable<ScopeOfWorksCreateWithoutProductAttributeUnitValuesInput>, Enumerable<ScopeOfWorksUncheckedCreateWithoutProductAttributeUnitValuesInput>>
    connectOrCreate?: Enumerable<ScopeOfWorksCreateOrConnectWithoutProductAttributeUnitValuesInput>
    connect?: Enumerable<ScopeOfWorksWhereUniqueInput>
  }

  export type ScopeOfWorksUncheckedCreateNestedManyWithoutProductAttributeUnitValuesInput = {
    create?: XOR<Enumerable<ScopeOfWorksCreateWithoutProductAttributeUnitValuesInput>, Enumerable<ScopeOfWorksUncheckedCreateWithoutProductAttributeUnitValuesInput>>
    connectOrCreate?: Enumerable<ScopeOfWorksCreateOrConnectWithoutProductAttributeUnitValuesInput>
    connect?: Enumerable<ScopeOfWorksWhereUniqueInput>
  }

  export type ProductAttributeUnitsUpdateOneRequiredWithoutProductAttributeUnitValuesInput = {
    create?: XOR<ProductAttributeUnitsCreateWithoutProductAttributeUnitValuesInput, ProductAttributeUnitsUncheckedCreateWithoutProductAttributeUnitValuesInput>
    connectOrCreate?: ProductAttributeUnitsCreateOrConnectWithoutProductAttributeUnitValuesInput
    upsert?: ProductAttributeUnitsUpsertWithoutProductAttributeUnitValuesInput
    connect?: ProductAttributeUnitsWhereUniqueInput
    update?: XOR<ProductAttributeUnitsUpdateWithoutProductAttributeUnitValuesInput, ProductAttributeUnitsUncheckedUpdateWithoutProductAttributeUnitValuesInput>
  }

  export type ScopeOfWorksUpdateManyWithoutProductAttributeUnitValuesInput = {
    create?: XOR<Enumerable<ScopeOfWorksCreateWithoutProductAttributeUnitValuesInput>, Enumerable<ScopeOfWorksUncheckedCreateWithoutProductAttributeUnitValuesInput>>
    connectOrCreate?: Enumerable<ScopeOfWorksCreateOrConnectWithoutProductAttributeUnitValuesInput>
    upsert?: Enumerable<ScopeOfWorksUpsertWithWhereUniqueWithoutProductAttributeUnitValuesInput>
    connect?: Enumerable<ScopeOfWorksWhereUniqueInput>
    set?: Enumerable<ScopeOfWorksWhereUniqueInput>
    disconnect?: Enumerable<ScopeOfWorksWhereUniqueInput>
    delete?: Enumerable<ScopeOfWorksWhereUniqueInput>
    update?: Enumerable<ScopeOfWorksUpdateWithWhereUniqueWithoutProductAttributeUnitValuesInput>
    updateMany?: Enumerable<ScopeOfWorksUpdateManyWithWhereWithoutProductAttributeUnitValuesInput>
    deleteMany?: Enumerable<ScopeOfWorksScalarWhereInput>
  }

  export type ScopeOfWorksUncheckedUpdateManyWithoutProductAttributeUnitValuesInput = {
    create?: XOR<Enumerable<ScopeOfWorksCreateWithoutProductAttributeUnitValuesInput>, Enumerable<ScopeOfWorksUncheckedCreateWithoutProductAttributeUnitValuesInput>>
    connectOrCreate?: Enumerable<ScopeOfWorksCreateOrConnectWithoutProductAttributeUnitValuesInput>
    upsert?: Enumerable<ScopeOfWorksUpsertWithWhereUniqueWithoutProductAttributeUnitValuesInput>
    connect?: Enumerable<ScopeOfWorksWhereUniqueInput>
    set?: Enumerable<ScopeOfWorksWhereUniqueInput>
    disconnect?: Enumerable<ScopeOfWorksWhereUniqueInput>
    delete?: Enumerable<ScopeOfWorksWhereUniqueInput>
    update?: Enumerable<ScopeOfWorksUpdateWithWhereUniqueWithoutProductAttributeUnitValuesInput>
    updateMany?: Enumerable<ScopeOfWorksUpdateManyWithWhereWithoutProductAttributeUnitValuesInput>
    deleteMany?: Enumerable<ScopeOfWorksScalarWhereInput>
  }

  export type PropertyUnitProductCategoriesCreateNestedManyWithoutProductCategoriesInput = {
    create?: XOR<Enumerable<PropertyUnitProductCategoriesCreateWithoutProductCategoriesInput>, Enumerable<PropertyUnitProductCategoriesUncheckedCreateWithoutProductCategoriesInput>>
    connectOrCreate?: Enumerable<PropertyUnitProductCategoriesCreateOrConnectWithoutProductCategoriesInput>
    connect?: Enumerable<PropertyUnitProductCategoriesWhereUniqueInput>
  }

  export type PropertyUnitProductCategoriesUncheckedCreateNestedManyWithoutProductCategoriesInput = {
    create?: XOR<Enumerable<PropertyUnitProductCategoriesCreateWithoutProductCategoriesInput>, Enumerable<PropertyUnitProductCategoriesUncheckedCreateWithoutProductCategoriesInput>>
    connectOrCreate?: Enumerable<PropertyUnitProductCategoriesCreateOrConnectWithoutProductCategoriesInput>
    connect?: Enumerable<PropertyUnitProductCategoriesWhereUniqueInput>
  }

  export type PropertyUnitProductCategoriesUpdateManyWithoutProductCategoriesInput = {
    create?: XOR<Enumerable<PropertyUnitProductCategoriesCreateWithoutProductCategoriesInput>, Enumerable<PropertyUnitProductCategoriesUncheckedCreateWithoutProductCategoriesInput>>
    connectOrCreate?: Enumerable<PropertyUnitProductCategoriesCreateOrConnectWithoutProductCategoriesInput>
    upsert?: Enumerable<PropertyUnitProductCategoriesUpsertWithWhereUniqueWithoutProductCategoriesInput>
    connect?: Enumerable<PropertyUnitProductCategoriesWhereUniqueInput>
    set?: Enumerable<PropertyUnitProductCategoriesWhereUniqueInput>
    disconnect?: Enumerable<PropertyUnitProductCategoriesWhereUniqueInput>
    delete?: Enumerable<PropertyUnitProductCategoriesWhereUniqueInput>
    update?: Enumerable<PropertyUnitProductCategoriesUpdateWithWhereUniqueWithoutProductCategoriesInput>
    updateMany?: Enumerable<PropertyUnitProductCategoriesUpdateManyWithWhereWithoutProductCategoriesInput>
    deleteMany?: Enumerable<PropertyUnitProductCategoriesScalarWhereInput>
  }

  export type PropertyUnitProductCategoriesUncheckedUpdateManyWithoutProductCategoriesInput = {
    create?: XOR<Enumerable<PropertyUnitProductCategoriesCreateWithoutProductCategoriesInput>, Enumerable<PropertyUnitProductCategoriesUncheckedCreateWithoutProductCategoriesInput>>
    connectOrCreate?: Enumerable<PropertyUnitProductCategoriesCreateOrConnectWithoutProductCategoriesInput>
    upsert?: Enumerable<PropertyUnitProductCategoriesUpsertWithWhereUniqueWithoutProductCategoriesInput>
    connect?: Enumerable<PropertyUnitProductCategoriesWhereUniqueInput>
    set?: Enumerable<PropertyUnitProductCategoriesWhereUniqueInput>
    disconnect?: Enumerable<PropertyUnitProductCategoriesWhereUniqueInput>
    delete?: Enumerable<PropertyUnitProductCategoriesWhereUniqueInput>
    update?: Enumerable<PropertyUnitProductCategoriesUpdateWithWhereUniqueWithoutProductCategoriesInput>
    updateMany?: Enumerable<PropertyUnitProductCategoriesUpdateManyWithWhereWithoutProductCategoriesInput>
    deleteMany?: Enumerable<PropertyUnitProductCategoriesScalarWhereInput>
  }

  export type ProductsCreateNestedOneWithoutProductPropertyUnitsInput = {
    create?: XOR<ProductsCreateWithoutProductPropertyUnitsInput, ProductsUncheckedCreateWithoutProductPropertyUnitsInput>
    connectOrCreate?: ProductsCreateOrConnectWithoutProductPropertyUnitsInput
    connect?: ProductsWhereUniqueInput
  }

  export type PropertyUnitsCreateNestedOneWithoutProductPropertyUnitsInput = {
    create?: XOR<PropertyUnitsCreateWithoutProductPropertyUnitsInput, PropertyUnitsUncheckedCreateWithoutProductPropertyUnitsInput>
    connectOrCreate?: PropertyUnitsCreateOrConnectWithoutProductPropertyUnitsInput
    connect?: PropertyUnitsWhereUniqueInput
  }

  export type ProductsUpdateOneRequiredWithoutProductPropertyUnitsInput = {
    create?: XOR<ProductsCreateWithoutProductPropertyUnitsInput, ProductsUncheckedCreateWithoutProductPropertyUnitsInput>
    connectOrCreate?: ProductsCreateOrConnectWithoutProductPropertyUnitsInput
    upsert?: ProductsUpsertWithoutProductPropertyUnitsInput
    connect?: ProductsWhereUniqueInput
    update?: XOR<ProductsUpdateWithoutProductPropertyUnitsInput, ProductsUncheckedUpdateWithoutProductPropertyUnitsInput>
  }

  export type PropertyUnitsUpdateOneRequiredWithoutProductPropertyUnitsInput = {
    create?: XOR<PropertyUnitsCreateWithoutProductPropertyUnitsInput, PropertyUnitsUncheckedCreateWithoutProductPropertyUnitsInput>
    connectOrCreate?: PropertyUnitsCreateOrConnectWithoutProductPropertyUnitsInput
    upsert?: PropertyUnitsUpsertWithoutProductPropertyUnitsInput
    connect?: PropertyUnitsWhereUniqueInput
    update?: XOR<PropertyUnitsUpdateWithoutProductPropertyUnitsInput, PropertyUnitsUncheckedUpdateWithoutProductPropertyUnitsInput>
  }

  export type ProductsCreateNestedOneWithoutOther_ProductsInput = {
    create?: XOR<ProductsCreateWithoutOther_ProductsInput, ProductsUncheckedCreateWithoutOther_ProductsInput>
    connectOrCreate?: ProductsCreateOrConnectWithoutOther_ProductsInput
    connect?: ProductsWhereUniqueInput
  }

  export type ProductAttributeUnitsCreateNestedManyWithoutProductsInput = {
    create?: XOR<Enumerable<ProductAttributeUnitsCreateWithoutProductsInput>, Enumerable<ProductAttributeUnitsUncheckedCreateWithoutProductsInput>>
    connectOrCreate?: Enumerable<ProductAttributeUnitsCreateOrConnectWithoutProductsInput>
    connect?: Enumerable<ProductAttributeUnitsWhereUniqueInput>
  }

  export type ProductPropertyUnitsCreateNestedManyWithoutProductsInput = {
    create?: XOR<Enumerable<ProductPropertyUnitsCreateWithoutProductsInput>, Enumerable<ProductPropertyUnitsUncheckedCreateWithoutProductsInput>>
    connectOrCreate?: Enumerable<ProductPropertyUnitsCreateOrConnectWithoutProductsInput>
    connect?: Enumerable<ProductPropertyUnitsWhereUniqueInput>
  }

  export type ProductsCreateNestedManyWithoutProductsInput = {
    create?: XOR<Enumerable<ProductsCreateWithoutProductsInput>, Enumerable<ProductsUncheckedCreateWithoutProductsInput>>
    connectOrCreate?: Enumerable<ProductsCreateOrConnectWithoutProductsInput>
    connect?: Enumerable<ProductsWhereUniqueInput>
  }

  export type PropertyUnitProductCategoryProductsCreateNestedManyWithoutProductsInput = {
    create?: XOR<Enumerable<PropertyUnitProductCategoryProductsCreateWithoutProductsInput>, Enumerable<PropertyUnitProductCategoryProductsUncheckedCreateWithoutProductsInput>>
    connectOrCreate?: Enumerable<PropertyUnitProductCategoryProductsCreateOrConnectWithoutProductsInput>
    connect?: Enumerable<PropertyUnitProductCategoryProductsWhereUniqueInput>
  }

  export type ProductAttributeUnitsUncheckedCreateNestedManyWithoutProductsInput = {
    create?: XOR<Enumerable<ProductAttributeUnitsCreateWithoutProductsInput>, Enumerable<ProductAttributeUnitsUncheckedCreateWithoutProductsInput>>
    connectOrCreate?: Enumerable<ProductAttributeUnitsCreateOrConnectWithoutProductsInput>
    connect?: Enumerable<ProductAttributeUnitsWhereUniqueInput>
  }

  export type ProductPropertyUnitsUncheckedCreateNestedManyWithoutProductsInput = {
    create?: XOR<Enumerable<ProductPropertyUnitsCreateWithoutProductsInput>, Enumerable<ProductPropertyUnitsUncheckedCreateWithoutProductsInput>>
    connectOrCreate?: Enumerable<ProductPropertyUnitsCreateOrConnectWithoutProductsInput>
    connect?: Enumerable<ProductPropertyUnitsWhereUniqueInput>
  }

  export type ProductsUncheckedCreateNestedManyWithoutProductsInput = {
    create?: XOR<Enumerable<ProductsCreateWithoutProductsInput>, Enumerable<ProductsUncheckedCreateWithoutProductsInput>>
    connectOrCreate?: Enumerable<ProductsCreateOrConnectWithoutProductsInput>
    connect?: Enumerable<ProductsWhereUniqueInput>
  }

  export type PropertyUnitProductCategoryProductsUncheckedCreateNestedManyWithoutProductsInput = {
    create?: XOR<Enumerable<PropertyUnitProductCategoryProductsCreateWithoutProductsInput>, Enumerable<PropertyUnitProductCategoryProductsUncheckedCreateWithoutProductsInput>>
    connectOrCreate?: Enumerable<PropertyUnitProductCategoryProductsCreateOrConnectWithoutProductsInput>
    connect?: Enumerable<PropertyUnitProductCategoryProductsWhereUniqueInput>
  }

  export type ProductsUpdateOneWithoutOther_ProductsInput = {
    create?: XOR<ProductsCreateWithoutOther_ProductsInput, ProductsUncheckedCreateWithoutOther_ProductsInput>
    connectOrCreate?: ProductsCreateOrConnectWithoutOther_ProductsInput
    upsert?: ProductsUpsertWithoutOther_ProductsInput
    connect?: ProductsWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<ProductsUpdateWithoutOther_ProductsInput, ProductsUncheckedUpdateWithoutOther_ProductsInput>
  }

  export type ProductAttributeUnitsUpdateManyWithoutProductsInput = {
    create?: XOR<Enumerable<ProductAttributeUnitsCreateWithoutProductsInput>, Enumerable<ProductAttributeUnitsUncheckedCreateWithoutProductsInput>>
    connectOrCreate?: Enumerable<ProductAttributeUnitsCreateOrConnectWithoutProductsInput>
    upsert?: Enumerable<ProductAttributeUnitsUpsertWithWhereUniqueWithoutProductsInput>
    connect?: Enumerable<ProductAttributeUnitsWhereUniqueInput>
    set?: Enumerable<ProductAttributeUnitsWhereUniqueInput>
    disconnect?: Enumerable<ProductAttributeUnitsWhereUniqueInput>
    delete?: Enumerable<ProductAttributeUnitsWhereUniqueInput>
    update?: Enumerable<ProductAttributeUnitsUpdateWithWhereUniqueWithoutProductsInput>
    updateMany?: Enumerable<ProductAttributeUnitsUpdateManyWithWhereWithoutProductsInput>
    deleteMany?: Enumerable<ProductAttributeUnitsScalarWhereInput>
  }

  export type ProductPropertyUnitsUpdateManyWithoutProductsInput = {
    create?: XOR<Enumerable<ProductPropertyUnitsCreateWithoutProductsInput>, Enumerable<ProductPropertyUnitsUncheckedCreateWithoutProductsInput>>
    connectOrCreate?: Enumerable<ProductPropertyUnitsCreateOrConnectWithoutProductsInput>
    upsert?: Enumerable<ProductPropertyUnitsUpsertWithWhereUniqueWithoutProductsInput>
    connect?: Enumerable<ProductPropertyUnitsWhereUniqueInput>
    set?: Enumerable<ProductPropertyUnitsWhereUniqueInput>
    disconnect?: Enumerable<ProductPropertyUnitsWhereUniqueInput>
    delete?: Enumerable<ProductPropertyUnitsWhereUniqueInput>
    update?: Enumerable<ProductPropertyUnitsUpdateWithWhereUniqueWithoutProductsInput>
    updateMany?: Enumerable<ProductPropertyUnitsUpdateManyWithWhereWithoutProductsInput>
    deleteMany?: Enumerable<ProductPropertyUnitsScalarWhereInput>
  }

  export type ProductsUpdateManyWithoutProductsInput = {
    create?: XOR<Enumerable<ProductsCreateWithoutProductsInput>, Enumerable<ProductsUncheckedCreateWithoutProductsInput>>
    connectOrCreate?: Enumerable<ProductsCreateOrConnectWithoutProductsInput>
    upsert?: Enumerable<ProductsUpsertWithWhereUniqueWithoutProductsInput>
    connect?: Enumerable<ProductsWhereUniqueInput>
    set?: Enumerable<ProductsWhereUniqueInput>
    disconnect?: Enumerable<ProductsWhereUniqueInput>
    delete?: Enumerable<ProductsWhereUniqueInput>
    update?: Enumerable<ProductsUpdateWithWhereUniqueWithoutProductsInput>
    updateMany?: Enumerable<ProductsUpdateManyWithWhereWithoutProductsInput>
    deleteMany?: Enumerable<ProductsScalarWhereInput>
  }

  export type PropertyUnitProductCategoryProductsUpdateManyWithoutProductsInput = {
    create?: XOR<Enumerable<PropertyUnitProductCategoryProductsCreateWithoutProductsInput>, Enumerable<PropertyUnitProductCategoryProductsUncheckedCreateWithoutProductsInput>>
    connectOrCreate?: Enumerable<PropertyUnitProductCategoryProductsCreateOrConnectWithoutProductsInput>
    upsert?: Enumerable<PropertyUnitProductCategoryProductsUpsertWithWhereUniqueWithoutProductsInput>
    connect?: Enumerable<PropertyUnitProductCategoryProductsWhereUniqueInput>
    set?: Enumerable<PropertyUnitProductCategoryProductsWhereUniqueInput>
    disconnect?: Enumerable<PropertyUnitProductCategoryProductsWhereUniqueInput>
    delete?: Enumerable<PropertyUnitProductCategoryProductsWhereUniqueInput>
    update?: Enumerable<PropertyUnitProductCategoryProductsUpdateWithWhereUniqueWithoutProductsInput>
    updateMany?: Enumerable<PropertyUnitProductCategoryProductsUpdateManyWithWhereWithoutProductsInput>
    deleteMany?: Enumerable<PropertyUnitProductCategoryProductsScalarWhereInput>
  }

  export type ProductAttributeUnitsUncheckedUpdateManyWithoutProductsInput = {
    create?: XOR<Enumerable<ProductAttributeUnitsCreateWithoutProductsInput>, Enumerable<ProductAttributeUnitsUncheckedCreateWithoutProductsInput>>
    connectOrCreate?: Enumerable<ProductAttributeUnitsCreateOrConnectWithoutProductsInput>
    upsert?: Enumerable<ProductAttributeUnitsUpsertWithWhereUniqueWithoutProductsInput>
    connect?: Enumerable<ProductAttributeUnitsWhereUniqueInput>
    set?: Enumerable<ProductAttributeUnitsWhereUniqueInput>
    disconnect?: Enumerable<ProductAttributeUnitsWhereUniqueInput>
    delete?: Enumerable<ProductAttributeUnitsWhereUniqueInput>
    update?: Enumerable<ProductAttributeUnitsUpdateWithWhereUniqueWithoutProductsInput>
    updateMany?: Enumerable<ProductAttributeUnitsUpdateManyWithWhereWithoutProductsInput>
    deleteMany?: Enumerable<ProductAttributeUnitsScalarWhereInput>
  }

  export type ProductPropertyUnitsUncheckedUpdateManyWithoutProductsInput = {
    create?: XOR<Enumerable<ProductPropertyUnitsCreateWithoutProductsInput>, Enumerable<ProductPropertyUnitsUncheckedCreateWithoutProductsInput>>
    connectOrCreate?: Enumerable<ProductPropertyUnitsCreateOrConnectWithoutProductsInput>
    upsert?: Enumerable<ProductPropertyUnitsUpsertWithWhereUniqueWithoutProductsInput>
    connect?: Enumerable<ProductPropertyUnitsWhereUniqueInput>
    set?: Enumerable<ProductPropertyUnitsWhereUniqueInput>
    disconnect?: Enumerable<ProductPropertyUnitsWhereUniqueInput>
    delete?: Enumerable<ProductPropertyUnitsWhereUniqueInput>
    update?: Enumerable<ProductPropertyUnitsUpdateWithWhereUniqueWithoutProductsInput>
    updateMany?: Enumerable<ProductPropertyUnitsUpdateManyWithWhereWithoutProductsInput>
    deleteMany?: Enumerable<ProductPropertyUnitsScalarWhereInput>
  }

  export type ProductsUncheckedUpdateManyWithoutProductsInput = {
    create?: XOR<Enumerable<ProductsCreateWithoutProductsInput>, Enumerable<ProductsUncheckedCreateWithoutProductsInput>>
    connectOrCreate?: Enumerable<ProductsCreateOrConnectWithoutProductsInput>
    upsert?: Enumerable<ProductsUpsertWithWhereUniqueWithoutProductsInput>
    connect?: Enumerable<ProductsWhereUniqueInput>
    set?: Enumerable<ProductsWhereUniqueInput>
    disconnect?: Enumerable<ProductsWhereUniqueInput>
    delete?: Enumerable<ProductsWhereUniqueInput>
    update?: Enumerable<ProductsUpdateWithWhereUniqueWithoutProductsInput>
    updateMany?: Enumerable<ProductsUpdateManyWithWhereWithoutProductsInput>
    deleteMany?: Enumerable<ProductsScalarWhereInput>
  }

  export type PropertyUnitProductCategoryProductsUncheckedUpdateManyWithoutProductsInput = {
    create?: XOR<Enumerable<PropertyUnitProductCategoryProductsCreateWithoutProductsInput>, Enumerable<PropertyUnitProductCategoryProductsUncheckedCreateWithoutProductsInput>>
    connectOrCreate?: Enumerable<PropertyUnitProductCategoryProductsCreateOrConnectWithoutProductsInput>
    upsert?: Enumerable<PropertyUnitProductCategoryProductsUpsertWithWhereUniqueWithoutProductsInput>
    connect?: Enumerable<PropertyUnitProductCategoryProductsWhereUniqueInput>
    set?: Enumerable<PropertyUnitProductCategoryProductsWhereUniqueInput>
    disconnect?: Enumerable<PropertyUnitProductCategoryProductsWhereUniqueInput>
    delete?: Enumerable<PropertyUnitProductCategoryProductsWhereUniqueInput>
    update?: Enumerable<PropertyUnitProductCategoryProductsUpdateWithWhereUniqueWithoutProductsInput>
    updateMany?: Enumerable<PropertyUnitProductCategoryProductsUpdateManyWithWhereWithoutProductsInput>
    deleteMany?: Enumerable<PropertyUnitProductCategoryProductsScalarWhereInput>
  }

  export type ProjectsCreateNestedOneWithoutProjectProposalsInput = {
    create?: XOR<ProjectsCreateWithoutProjectProposalsInput, ProjectsUncheckedCreateWithoutProjectProposalsInput>
    connectOrCreate?: ProjectsCreateOrConnectWithoutProjectProposalsInput
    connect?: ProjectsWhereUniqueInput
  }

  export type AreaOfWorksCreateNestedManyWithoutProjectProposalsInput = {
    create?: XOR<Enumerable<AreaOfWorksCreateWithoutProjectProposalsInput>, Enumerable<AreaOfWorksUncheckedCreateWithoutProjectProposalsInput>>
    connectOrCreate?: Enumerable<AreaOfWorksCreateOrConnectWithoutProjectProposalsInput>
    connect?: Enumerable<AreaOfWorksWhereUniqueInput>
  }

  export type ScopeOfWorkPropertyUnitsCreateNestedManyWithoutProjectProposalsInput = {
    create?: XOR<Enumerable<ScopeOfWorkPropertyUnitsCreateWithoutProjectProposalsInput>, Enumerable<ScopeOfWorkPropertyUnitsUncheckedCreateWithoutProjectProposalsInput>>
    connectOrCreate?: Enumerable<ScopeOfWorkPropertyUnitsCreateOrConnectWithoutProjectProposalsInput>
    connect?: Enumerable<ScopeOfWorkPropertyUnitsWhereUniqueInput>
  }

  export type ScopeOfWorksCreateNestedManyWithoutProjectProposalsInput = {
    create?: XOR<Enumerable<ScopeOfWorksCreateWithoutProjectProposalsInput>, Enumerable<ScopeOfWorksUncheckedCreateWithoutProjectProposalsInput>>
    connectOrCreate?: Enumerable<ScopeOfWorksCreateOrConnectWithoutProjectProposalsInput>
    connect?: Enumerable<ScopeOfWorksWhereUniqueInput>
  }

  export type AreaOfWorksUncheckedCreateNestedManyWithoutProjectProposalsInput = {
    create?: XOR<Enumerable<AreaOfWorksCreateWithoutProjectProposalsInput>, Enumerable<AreaOfWorksUncheckedCreateWithoutProjectProposalsInput>>
    connectOrCreate?: Enumerable<AreaOfWorksCreateOrConnectWithoutProjectProposalsInput>
    connect?: Enumerable<AreaOfWorksWhereUniqueInput>
  }

  export type ScopeOfWorkPropertyUnitsUncheckedCreateNestedManyWithoutProjectProposalsInput = {
    create?: XOR<Enumerable<ScopeOfWorkPropertyUnitsCreateWithoutProjectProposalsInput>, Enumerable<ScopeOfWorkPropertyUnitsUncheckedCreateWithoutProjectProposalsInput>>
    connectOrCreate?: Enumerable<ScopeOfWorkPropertyUnitsCreateOrConnectWithoutProjectProposalsInput>
    connect?: Enumerable<ScopeOfWorkPropertyUnitsWhereUniqueInput>
  }

  export type ScopeOfWorksUncheckedCreateNestedManyWithoutProjectProposalsInput = {
    create?: XOR<Enumerable<ScopeOfWorksCreateWithoutProjectProposalsInput>, Enumerable<ScopeOfWorksUncheckedCreateWithoutProjectProposalsInput>>
    connectOrCreate?: Enumerable<ScopeOfWorksCreateOrConnectWithoutProjectProposalsInput>
    connect?: Enumerable<ScopeOfWorksWhereUniqueInput>
  }

  export type ProjectsUpdateOneRequiredWithoutProjectProposalsInput = {
    create?: XOR<ProjectsCreateWithoutProjectProposalsInput, ProjectsUncheckedCreateWithoutProjectProposalsInput>
    connectOrCreate?: ProjectsCreateOrConnectWithoutProjectProposalsInput
    upsert?: ProjectsUpsertWithoutProjectProposalsInput
    connect?: ProjectsWhereUniqueInput
    update?: XOR<ProjectsUpdateWithoutProjectProposalsInput, ProjectsUncheckedUpdateWithoutProjectProposalsInput>
  }

  export type AreaOfWorksUpdateManyWithoutProjectProposalsInput = {
    create?: XOR<Enumerable<AreaOfWorksCreateWithoutProjectProposalsInput>, Enumerable<AreaOfWorksUncheckedCreateWithoutProjectProposalsInput>>
    connectOrCreate?: Enumerable<AreaOfWorksCreateOrConnectWithoutProjectProposalsInput>
    upsert?: Enumerable<AreaOfWorksUpsertWithWhereUniqueWithoutProjectProposalsInput>
    connect?: Enumerable<AreaOfWorksWhereUniqueInput>
    set?: Enumerable<AreaOfWorksWhereUniqueInput>
    disconnect?: Enumerable<AreaOfWorksWhereUniqueInput>
    delete?: Enumerable<AreaOfWorksWhereUniqueInput>
    update?: Enumerable<AreaOfWorksUpdateWithWhereUniqueWithoutProjectProposalsInput>
    updateMany?: Enumerable<AreaOfWorksUpdateManyWithWhereWithoutProjectProposalsInput>
    deleteMany?: Enumerable<AreaOfWorksScalarWhereInput>
  }

  export type ScopeOfWorkPropertyUnitsUpdateManyWithoutProjectProposalsInput = {
    create?: XOR<Enumerable<ScopeOfWorkPropertyUnitsCreateWithoutProjectProposalsInput>, Enumerable<ScopeOfWorkPropertyUnitsUncheckedCreateWithoutProjectProposalsInput>>
    connectOrCreate?: Enumerable<ScopeOfWorkPropertyUnitsCreateOrConnectWithoutProjectProposalsInput>
    upsert?: Enumerable<ScopeOfWorkPropertyUnitsUpsertWithWhereUniqueWithoutProjectProposalsInput>
    connect?: Enumerable<ScopeOfWorkPropertyUnitsWhereUniqueInput>
    set?: Enumerable<ScopeOfWorkPropertyUnitsWhereUniqueInput>
    disconnect?: Enumerable<ScopeOfWorkPropertyUnitsWhereUniqueInput>
    delete?: Enumerable<ScopeOfWorkPropertyUnitsWhereUniqueInput>
    update?: Enumerable<ScopeOfWorkPropertyUnitsUpdateWithWhereUniqueWithoutProjectProposalsInput>
    updateMany?: Enumerable<ScopeOfWorkPropertyUnitsUpdateManyWithWhereWithoutProjectProposalsInput>
    deleteMany?: Enumerable<ScopeOfWorkPropertyUnitsScalarWhereInput>
  }

  export type ScopeOfWorksUpdateManyWithoutProjectProposalsInput = {
    create?: XOR<Enumerable<ScopeOfWorksCreateWithoutProjectProposalsInput>, Enumerable<ScopeOfWorksUncheckedCreateWithoutProjectProposalsInput>>
    connectOrCreate?: Enumerable<ScopeOfWorksCreateOrConnectWithoutProjectProposalsInput>
    upsert?: Enumerable<ScopeOfWorksUpsertWithWhereUniqueWithoutProjectProposalsInput>
    connect?: Enumerable<ScopeOfWorksWhereUniqueInput>
    set?: Enumerable<ScopeOfWorksWhereUniqueInput>
    disconnect?: Enumerable<ScopeOfWorksWhereUniqueInput>
    delete?: Enumerable<ScopeOfWorksWhereUniqueInput>
    update?: Enumerable<ScopeOfWorksUpdateWithWhereUniqueWithoutProjectProposalsInput>
    updateMany?: Enumerable<ScopeOfWorksUpdateManyWithWhereWithoutProjectProposalsInput>
    deleteMany?: Enumerable<ScopeOfWorksScalarWhereInput>
  }

  export type AreaOfWorksUncheckedUpdateManyWithoutProjectProposalsInput = {
    create?: XOR<Enumerable<AreaOfWorksCreateWithoutProjectProposalsInput>, Enumerable<AreaOfWorksUncheckedCreateWithoutProjectProposalsInput>>
    connectOrCreate?: Enumerable<AreaOfWorksCreateOrConnectWithoutProjectProposalsInput>
    upsert?: Enumerable<AreaOfWorksUpsertWithWhereUniqueWithoutProjectProposalsInput>
    connect?: Enumerable<AreaOfWorksWhereUniqueInput>
    set?: Enumerable<AreaOfWorksWhereUniqueInput>
    disconnect?: Enumerable<AreaOfWorksWhereUniqueInput>
    delete?: Enumerable<AreaOfWorksWhereUniqueInput>
    update?: Enumerable<AreaOfWorksUpdateWithWhereUniqueWithoutProjectProposalsInput>
    updateMany?: Enumerable<AreaOfWorksUpdateManyWithWhereWithoutProjectProposalsInput>
    deleteMany?: Enumerable<AreaOfWorksScalarWhereInput>
  }

  export type ScopeOfWorkPropertyUnitsUncheckedUpdateManyWithoutProjectProposalsInput = {
    create?: XOR<Enumerable<ScopeOfWorkPropertyUnitsCreateWithoutProjectProposalsInput>, Enumerable<ScopeOfWorkPropertyUnitsUncheckedCreateWithoutProjectProposalsInput>>
    connectOrCreate?: Enumerable<ScopeOfWorkPropertyUnitsCreateOrConnectWithoutProjectProposalsInput>
    upsert?: Enumerable<ScopeOfWorkPropertyUnitsUpsertWithWhereUniqueWithoutProjectProposalsInput>
    connect?: Enumerable<ScopeOfWorkPropertyUnitsWhereUniqueInput>
    set?: Enumerable<ScopeOfWorkPropertyUnitsWhereUniqueInput>
    disconnect?: Enumerable<ScopeOfWorkPropertyUnitsWhereUniqueInput>
    delete?: Enumerable<ScopeOfWorkPropertyUnitsWhereUniqueInput>
    update?: Enumerable<ScopeOfWorkPropertyUnitsUpdateWithWhereUniqueWithoutProjectProposalsInput>
    updateMany?: Enumerable<ScopeOfWorkPropertyUnitsUpdateManyWithWhereWithoutProjectProposalsInput>
    deleteMany?: Enumerable<ScopeOfWorkPropertyUnitsScalarWhereInput>
  }

  export type ScopeOfWorksUncheckedUpdateManyWithoutProjectProposalsInput = {
    create?: XOR<Enumerable<ScopeOfWorksCreateWithoutProjectProposalsInput>, Enumerable<ScopeOfWorksUncheckedCreateWithoutProjectProposalsInput>>
    connectOrCreate?: Enumerable<ScopeOfWorksCreateOrConnectWithoutProjectProposalsInput>
    upsert?: Enumerable<ScopeOfWorksUpsertWithWhereUniqueWithoutProjectProposalsInput>
    connect?: Enumerable<ScopeOfWorksWhereUniqueInput>
    set?: Enumerable<ScopeOfWorksWhereUniqueInput>
    disconnect?: Enumerable<ScopeOfWorksWhereUniqueInput>
    delete?: Enumerable<ScopeOfWorksWhereUniqueInput>
    update?: Enumerable<ScopeOfWorksUpdateWithWhereUniqueWithoutProjectProposalsInput>
    updateMany?: Enumerable<ScopeOfWorksUpdateManyWithWhereWithoutProjectProposalsInput>
    deleteMany?: Enumerable<ScopeOfWorksScalarWhereInput>
  }

  export type Property_AddressesCreateNestedOneWithoutProjectsInput = {
    create?: XOR<Property_AddressesCreateWithoutProjectsInput, Property_AddressesUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: Property_AddressesCreateOrConnectWithoutProjectsInput
    connect?: Property_AddressesWhereUniqueInput
  }

  export type ProjectProposalsCreateNestedManyWithoutProjectsInput = {
    create?: XOR<Enumerable<ProjectProposalsCreateWithoutProjectsInput>, Enumerable<ProjectProposalsUncheckedCreateWithoutProjectsInput>>
    connectOrCreate?: Enumerable<ProjectProposalsCreateOrConnectWithoutProjectsInput>
    connect?: Enumerable<ProjectProposalsWhereUniqueInput>
  }

  export type ProjectTypeAssociationsCreateNestedManyWithoutProjectsInput = {
    create?: XOR<Enumerable<ProjectTypeAssociationsCreateWithoutProjectsInput>, Enumerable<ProjectTypeAssociationsUncheckedCreateWithoutProjectsInput>>
    connectOrCreate?: Enumerable<ProjectTypeAssociationsCreateOrConnectWithoutProjectsInput>
    connect?: Enumerable<ProjectTypeAssociationsWhereUniqueInput>
  }

  export type ProjectProposalsUncheckedCreateNestedManyWithoutProjectsInput = {
    create?: XOR<Enumerable<ProjectProposalsCreateWithoutProjectsInput>, Enumerable<ProjectProposalsUncheckedCreateWithoutProjectsInput>>
    connectOrCreate?: Enumerable<ProjectProposalsCreateOrConnectWithoutProjectsInput>
    connect?: Enumerable<ProjectProposalsWhereUniqueInput>
  }

  export type ProjectTypeAssociationsUncheckedCreateNestedManyWithoutProjectsInput = {
    create?: XOR<Enumerable<ProjectTypeAssociationsCreateWithoutProjectsInput>, Enumerable<ProjectTypeAssociationsUncheckedCreateWithoutProjectsInput>>
    connectOrCreate?: Enumerable<ProjectTypeAssociationsCreateOrConnectWithoutProjectsInput>
    connect?: Enumerable<ProjectTypeAssociationsWhereUniqueInput>
  }

  export type Property_AddressesUpdateOneRequiredWithoutProjectsInput = {
    create?: XOR<Property_AddressesCreateWithoutProjectsInput, Property_AddressesUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: Property_AddressesCreateOrConnectWithoutProjectsInput
    upsert?: Property_AddressesUpsertWithoutProjectsInput
    connect?: Property_AddressesWhereUniqueInput
    update?: XOR<Property_AddressesUpdateWithoutProjectsInput, Property_AddressesUncheckedUpdateWithoutProjectsInput>
  }

  export type ProjectProposalsUpdateManyWithoutProjectsInput = {
    create?: XOR<Enumerable<ProjectProposalsCreateWithoutProjectsInput>, Enumerable<ProjectProposalsUncheckedCreateWithoutProjectsInput>>
    connectOrCreate?: Enumerable<ProjectProposalsCreateOrConnectWithoutProjectsInput>
    upsert?: Enumerable<ProjectProposalsUpsertWithWhereUniqueWithoutProjectsInput>
    connect?: Enumerable<ProjectProposalsWhereUniqueInput>
    set?: Enumerable<ProjectProposalsWhereUniqueInput>
    disconnect?: Enumerable<ProjectProposalsWhereUniqueInput>
    delete?: Enumerable<ProjectProposalsWhereUniqueInput>
    update?: Enumerable<ProjectProposalsUpdateWithWhereUniqueWithoutProjectsInput>
    updateMany?: Enumerable<ProjectProposalsUpdateManyWithWhereWithoutProjectsInput>
    deleteMany?: Enumerable<ProjectProposalsScalarWhereInput>
  }

  export type ProjectTypeAssociationsUpdateManyWithoutProjectsInput = {
    create?: XOR<Enumerable<ProjectTypeAssociationsCreateWithoutProjectsInput>, Enumerable<ProjectTypeAssociationsUncheckedCreateWithoutProjectsInput>>
    connectOrCreate?: Enumerable<ProjectTypeAssociationsCreateOrConnectWithoutProjectsInput>
    upsert?: Enumerable<ProjectTypeAssociationsUpsertWithWhereUniqueWithoutProjectsInput>
    connect?: Enumerable<ProjectTypeAssociationsWhereUniqueInput>
    set?: Enumerable<ProjectTypeAssociationsWhereUniqueInput>
    disconnect?: Enumerable<ProjectTypeAssociationsWhereUniqueInput>
    delete?: Enumerable<ProjectTypeAssociationsWhereUniqueInput>
    update?: Enumerable<ProjectTypeAssociationsUpdateWithWhereUniqueWithoutProjectsInput>
    updateMany?: Enumerable<ProjectTypeAssociationsUpdateManyWithWhereWithoutProjectsInput>
    deleteMany?: Enumerable<ProjectTypeAssociationsScalarWhereInput>
  }

  export type ProjectProposalsUncheckedUpdateManyWithoutProjectsInput = {
    create?: XOR<Enumerable<ProjectProposalsCreateWithoutProjectsInput>, Enumerable<ProjectProposalsUncheckedCreateWithoutProjectsInput>>
    connectOrCreate?: Enumerable<ProjectProposalsCreateOrConnectWithoutProjectsInput>
    upsert?: Enumerable<ProjectProposalsUpsertWithWhereUniqueWithoutProjectsInput>
    connect?: Enumerable<ProjectProposalsWhereUniqueInput>
    set?: Enumerable<ProjectProposalsWhereUniqueInput>
    disconnect?: Enumerable<ProjectProposalsWhereUniqueInput>
    delete?: Enumerable<ProjectProposalsWhereUniqueInput>
    update?: Enumerable<ProjectProposalsUpdateWithWhereUniqueWithoutProjectsInput>
    updateMany?: Enumerable<ProjectProposalsUpdateManyWithWhereWithoutProjectsInput>
    deleteMany?: Enumerable<ProjectProposalsScalarWhereInput>
  }

  export type ProjectTypeAssociationsUncheckedUpdateManyWithoutProjectsInput = {
    create?: XOR<Enumerable<ProjectTypeAssociationsCreateWithoutProjectsInput>, Enumerable<ProjectTypeAssociationsUncheckedCreateWithoutProjectsInput>>
    connectOrCreate?: Enumerable<ProjectTypeAssociationsCreateOrConnectWithoutProjectsInput>
    upsert?: Enumerable<ProjectTypeAssociationsUpsertWithWhereUniqueWithoutProjectsInput>
    connect?: Enumerable<ProjectTypeAssociationsWhereUniqueInput>
    set?: Enumerable<ProjectTypeAssociationsWhereUniqueInput>
    disconnect?: Enumerable<ProjectTypeAssociationsWhereUniqueInput>
    delete?: Enumerable<ProjectTypeAssociationsWhereUniqueInput>
    update?: Enumerable<ProjectTypeAssociationsUpdateWithWhereUniqueWithoutProjectsInput>
    updateMany?: Enumerable<ProjectTypeAssociationsUpdateManyWithWhereWithoutProjectsInput>
    deleteMany?: Enumerable<ProjectTypeAssociationsScalarWhereInput>
  }

  export type ProjectsCreateNestedOneWithoutProjectTypeAssociationsInput = {
    create?: XOR<ProjectsCreateWithoutProjectTypeAssociationsInput, ProjectsUncheckedCreateWithoutProjectTypeAssociationsInput>
    connectOrCreate?: ProjectsCreateOrConnectWithoutProjectTypeAssociationsInput
    connect?: ProjectsWhereUniqueInput
  }

  export type ProjectTypesCreateNestedOneWithoutProjectTypeAssociationsInput = {
    create?: XOR<ProjectTypesCreateWithoutProjectTypeAssociationsInput, ProjectTypesUncheckedCreateWithoutProjectTypeAssociationsInput>
    connectOrCreate?: ProjectTypesCreateOrConnectWithoutProjectTypeAssociationsInput
    connect?: ProjectTypesWhereUniqueInput
  }

  export type ProjectsUpdateOneRequiredWithoutProjectTypeAssociationsInput = {
    create?: XOR<ProjectsCreateWithoutProjectTypeAssociationsInput, ProjectsUncheckedCreateWithoutProjectTypeAssociationsInput>
    connectOrCreate?: ProjectsCreateOrConnectWithoutProjectTypeAssociationsInput
    upsert?: ProjectsUpsertWithoutProjectTypeAssociationsInput
    connect?: ProjectsWhereUniqueInput
    update?: XOR<ProjectsUpdateWithoutProjectTypeAssociationsInput, ProjectsUncheckedUpdateWithoutProjectTypeAssociationsInput>
  }

  export type ProjectTypesUpdateOneRequiredWithoutProjectTypeAssociationsInput = {
    create?: XOR<ProjectTypesCreateWithoutProjectTypeAssociationsInput, ProjectTypesUncheckedCreateWithoutProjectTypeAssociationsInput>
    connectOrCreate?: ProjectTypesCreateOrConnectWithoutProjectTypeAssociationsInput
    upsert?: ProjectTypesUpsertWithoutProjectTypeAssociationsInput
    connect?: ProjectTypesWhereUniqueInput
    update?: XOR<ProjectTypesUpdateWithoutProjectTypeAssociationsInput, ProjectTypesUncheckedUpdateWithoutProjectTypeAssociationsInput>
  }

  export type ProjectTypeAssociationsCreateNestedManyWithoutProjectTypesInput = {
    create?: XOR<Enumerable<ProjectTypeAssociationsCreateWithoutProjectTypesInput>, Enumerable<ProjectTypeAssociationsUncheckedCreateWithoutProjectTypesInput>>
    connectOrCreate?: Enumerable<ProjectTypeAssociationsCreateOrConnectWithoutProjectTypesInput>
    connect?: Enumerable<ProjectTypeAssociationsWhereUniqueInput>
  }

  export type ProjectTypeAssociationsUncheckedCreateNestedManyWithoutProjectTypesInput = {
    create?: XOR<Enumerable<ProjectTypeAssociationsCreateWithoutProjectTypesInput>, Enumerable<ProjectTypeAssociationsUncheckedCreateWithoutProjectTypesInput>>
    connectOrCreate?: Enumerable<ProjectTypeAssociationsCreateOrConnectWithoutProjectTypesInput>
    connect?: Enumerable<ProjectTypeAssociationsWhereUniqueInput>
  }

  export type ProjectTypeAssociationsUpdateManyWithoutProjectTypesInput = {
    create?: XOR<Enumerable<ProjectTypeAssociationsCreateWithoutProjectTypesInput>, Enumerable<ProjectTypeAssociationsUncheckedCreateWithoutProjectTypesInput>>
    connectOrCreate?: Enumerable<ProjectTypeAssociationsCreateOrConnectWithoutProjectTypesInput>
    upsert?: Enumerable<ProjectTypeAssociationsUpsertWithWhereUniqueWithoutProjectTypesInput>
    connect?: Enumerable<ProjectTypeAssociationsWhereUniqueInput>
    set?: Enumerable<ProjectTypeAssociationsWhereUniqueInput>
    disconnect?: Enumerable<ProjectTypeAssociationsWhereUniqueInput>
    delete?: Enumerable<ProjectTypeAssociationsWhereUniqueInput>
    update?: Enumerable<ProjectTypeAssociationsUpdateWithWhereUniqueWithoutProjectTypesInput>
    updateMany?: Enumerable<ProjectTypeAssociationsUpdateManyWithWhereWithoutProjectTypesInput>
    deleteMany?: Enumerable<ProjectTypeAssociationsScalarWhereInput>
  }

  export type ProjectTypeAssociationsUncheckedUpdateManyWithoutProjectTypesInput = {
    create?: XOR<Enumerable<ProjectTypeAssociationsCreateWithoutProjectTypesInput>, Enumerable<ProjectTypeAssociationsUncheckedCreateWithoutProjectTypesInput>>
    connectOrCreate?: Enumerable<ProjectTypeAssociationsCreateOrConnectWithoutProjectTypesInput>
    upsert?: Enumerable<ProjectTypeAssociationsUpsertWithWhereUniqueWithoutProjectTypesInput>
    connect?: Enumerable<ProjectTypeAssociationsWhereUniqueInput>
    set?: Enumerable<ProjectTypeAssociationsWhereUniqueInput>
    disconnect?: Enumerable<ProjectTypeAssociationsWhereUniqueInput>
    delete?: Enumerable<ProjectTypeAssociationsWhereUniqueInput>
    update?: Enumerable<ProjectTypeAssociationsUpdateWithWhereUniqueWithoutProjectTypesInput>
    updateMany?: Enumerable<ProjectTypeAssociationsUpdateManyWithWhereWithoutProjectTypesInput>
    deleteMany?: Enumerable<ProjectTypeAssociationsScalarWhereInput>
  }

  export type UnitLocationsCreateNestedManyWithoutPropertyLevelsInput = {
    create?: XOR<Enumerable<UnitLocationsCreateWithoutPropertyLevelsInput>, Enumerable<UnitLocationsUncheckedCreateWithoutPropertyLevelsInput>>
    connectOrCreate?: Enumerable<UnitLocationsCreateOrConnectWithoutPropertyLevelsInput>
    connect?: Enumerable<UnitLocationsWhereUniqueInput>
  }

  export type UnitLocationsUncheckedCreateNestedManyWithoutPropertyLevelsInput = {
    create?: XOR<Enumerable<UnitLocationsCreateWithoutPropertyLevelsInput>, Enumerable<UnitLocationsUncheckedCreateWithoutPropertyLevelsInput>>
    connectOrCreate?: Enumerable<UnitLocationsCreateOrConnectWithoutPropertyLevelsInput>
    connect?: Enumerable<UnitLocationsWhereUniqueInput>
  }

  export type UnitLocationsUpdateManyWithoutPropertyLevelsInput = {
    create?: XOR<Enumerable<UnitLocationsCreateWithoutPropertyLevelsInput>, Enumerable<UnitLocationsUncheckedCreateWithoutPropertyLevelsInput>>
    connectOrCreate?: Enumerable<UnitLocationsCreateOrConnectWithoutPropertyLevelsInput>
    upsert?: Enumerable<UnitLocationsUpsertWithWhereUniqueWithoutPropertyLevelsInput>
    connect?: Enumerable<UnitLocationsWhereUniqueInput>
    set?: Enumerable<UnitLocationsWhereUniqueInput>
    disconnect?: Enumerable<UnitLocationsWhereUniqueInput>
    delete?: Enumerable<UnitLocationsWhereUniqueInput>
    update?: Enumerable<UnitLocationsUpdateWithWhereUniqueWithoutPropertyLevelsInput>
    updateMany?: Enumerable<UnitLocationsUpdateManyWithWhereWithoutPropertyLevelsInput>
    deleteMany?: Enumerable<UnitLocationsScalarWhereInput>
  }

  export type UnitLocationsUncheckedUpdateManyWithoutPropertyLevelsInput = {
    create?: XOR<Enumerable<UnitLocationsCreateWithoutPropertyLevelsInput>, Enumerable<UnitLocationsUncheckedCreateWithoutPropertyLevelsInput>>
    connectOrCreate?: Enumerable<UnitLocationsCreateOrConnectWithoutPropertyLevelsInput>
    upsert?: Enumerable<UnitLocationsUpsertWithWhereUniqueWithoutPropertyLevelsInput>
    connect?: Enumerable<UnitLocationsWhereUniqueInput>
    set?: Enumerable<UnitLocationsWhereUniqueInput>
    disconnect?: Enumerable<UnitLocationsWhereUniqueInput>
    delete?: Enumerable<UnitLocationsWhereUniqueInput>
    update?: Enumerable<UnitLocationsUpdateWithWhereUniqueWithoutPropertyLevelsInput>
    updateMany?: Enumerable<UnitLocationsUpdateManyWithWhereWithoutPropertyLevelsInput>
    deleteMany?: Enumerable<UnitLocationsScalarWhereInput>
  }

  export type UsersCreateNestedOneWithoutPropertyOwnersInput = {
    create?: XOR<UsersCreateWithoutPropertyOwnersInput, UsersUncheckedCreateWithoutPropertyOwnersInput>
    connectOrCreate?: UsersCreateOrConnectWithoutPropertyOwnersInput
    connect?: UsersWhereUniqueInput
  }

  export type Property_AddressesCreateNestedManyWithoutPropertyOwnersInput = {
    create?: XOR<Enumerable<Property_AddressesCreateWithoutPropertyOwnersInput>, Enumerable<Property_AddressesUncheckedCreateWithoutPropertyOwnersInput>>
    connectOrCreate?: Enumerable<Property_AddressesCreateOrConnectWithoutPropertyOwnersInput>
    connect?: Enumerable<Property_AddressesWhereUniqueInput>
  }

  export type Property_AddressesUncheckedCreateNestedManyWithoutPropertyOwnersInput = {
    create?: XOR<Enumerable<Property_AddressesCreateWithoutPropertyOwnersInput>, Enumerable<Property_AddressesUncheckedCreateWithoutPropertyOwnersInput>>
    connectOrCreate?: Enumerable<Property_AddressesCreateOrConnectWithoutPropertyOwnersInput>
    connect?: Enumerable<Property_AddressesWhereUniqueInput>
  }

  export type UsersUpdateOneRequiredWithoutPropertyOwnersInput = {
    create?: XOR<UsersCreateWithoutPropertyOwnersInput, UsersUncheckedCreateWithoutPropertyOwnersInput>
    connectOrCreate?: UsersCreateOrConnectWithoutPropertyOwnersInput
    upsert?: UsersUpsertWithoutPropertyOwnersInput
    connect?: UsersWhereUniqueInput
    update?: XOR<UsersUpdateWithoutPropertyOwnersInput, UsersUncheckedUpdateWithoutPropertyOwnersInput>
  }

  export type Property_AddressesUpdateManyWithoutPropertyOwnersInput = {
    create?: XOR<Enumerable<Property_AddressesCreateWithoutPropertyOwnersInput>, Enumerable<Property_AddressesUncheckedCreateWithoutPropertyOwnersInput>>
    connectOrCreate?: Enumerable<Property_AddressesCreateOrConnectWithoutPropertyOwnersInput>
    upsert?: Enumerable<Property_AddressesUpsertWithWhereUniqueWithoutPropertyOwnersInput>
    connect?: Enumerable<Property_AddressesWhereUniqueInput>
    set?: Enumerable<Property_AddressesWhereUniqueInput>
    disconnect?: Enumerable<Property_AddressesWhereUniqueInput>
    delete?: Enumerable<Property_AddressesWhereUniqueInput>
    update?: Enumerable<Property_AddressesUpdateWithWhereUniqueWithoutPropertyOwnersInput>
    updateMany?: Enumerable<Property_AddressesUpdateManyWithWhereWithoutPropertyOwnersInput>
    deleteMany?: Enumerable<Property_AddressesScalarWhereInput>
  }

  export type Property_AddressesUncheckedUpdateManyWithoutPropertyOwnersInput = {
    create?: XOR<Enumerable<Property_AddressesCreateWithoutPropertyOwnersInput>, Enumerable<Property_AddressesUncheckedCreateWithoutPropertyOwnersInput>>
    connectOrCreate?: Enumerable<Property_AddressesCreateOrConnectWithoutPropertyOwnersInput>
    upsert?: Enumerable<Property_AddressesUpsertWithWhereUniqueWithoutPropertyOwnersInput>
    connect?: Enumerable<Property_AddressesWhereUniqueInput>
    set?: Enumerable<Property_AddressesWhereUniqueInput>
    disconnect?: Enumerable<Property_AddressesWhereUniqueInput>
    delete?: Enumerable<Property_AddressesWhereUniqueInput>
    update?: Enumerable<Property_AddressesUpdateWithWhereUniqueWithoutPropertyOwnersInput>
    updateMany?: Enumerable<Property_AddressesUpdateManyWithWhereWithoutPropertyOwnersInput>
    deleteMany?: Enumerable<Property_AddressesScalarWhereInput>
  }

  export type Property_TypesCreateNestedOneWithoutPropertySubTypesInput = {
    create?: XOR<Property_TypesCreateWithoutPropertySubTypesInput, Property_TypesUncheckedCreateWithoutPropertySubTypesInput>
    connectOrCreate?: Property_TypesCreateOrConnectWithoutPropertySubTypesInput
    connect?: Property_TypesWhereUniqueInput
  }

  export type Property_AddressesCreateNestedManyWithoutPropertySubTypesInput = {
    create?: XOR<Enumerable<Property_AddressesCreateWithoutPropertySubTypesInput>, Enumerable<Property_AddressesUncheckedCreateWithoutPropertySubTypesInput>>
    connectOrCreate?: Enumerable<Property_AddressesCreateOrConnectWithoutPropertySubTypesInput>
    connect?: Enumerable<Property_AddressesWhereUniqueInput>
  }

  export type UnitLocationsCreateNestedManyWithoutPropertySubTypesInput = {
    create?: XOR<Enumerable<UnitLocationsCreateWithoutPropertySubTypesInput>, Enumerable<UnitLocationsUncheckedCreateWithoutPropertySubTypesInput>>
    connectOrCreate?: Enumerable<UnitLocationsCreateOrConnectWithoutPropertySubTypesInput>
    connect?: Enumerable<UnitLocationsWhereUniqueInput>
  }

  export type Property_AddressesUncheckedCreateNestedManyWithoutPropertySubTypesInput = {
    create?: XOR<Enumerable<Property_AddressesCreateWithoutPropertySubTypesInput>, Enumerable<Property_AddressesUncheckedCreateWithoutPropertySubTypesInput>>
    connectOrCreate?: Enumerable<Property_AddressesCreateOrConnectWithoutPropertySubTypesInput>
    connect?: Enumerable<Property_AddressesWhereUniqueInput>
  }

  export type UnitLocationsUncheckedCreateNestedManyWithoutPropertySubTypesInput = {
    create?: XOR<Enumerable<UnitLocationsCreateWithoutPropertySubTypesInput>, Enumerable<UnitLocationsUncheckedCreateWithoutPropertySubTypesInput>>
    connectOrCreate?: Enumerable<UnitLocationsCreateOrConnectWithoutPropertySubTypesInput>
    connect?: Enumerable<UnitLocationsWhereUniqueInput>
  }

  export type Property_TypesUpdateOneRequiredWithoutPropertySubTypesInput = {
    create?: XOR<Property_TypesCreateWithoutPropertySubTypesInput, Property_TypesUncheckedCreateWithoutPropertySubTypesInput>
    connectOrCreate?: Property_TypesCreateOrConnectWithoutPropertySubTypesInput
    upsert?: Property_TypesUpsertWithoutPropertySubTypesInput
    connect?: Property_TypesWhereUniqueInput
    update?: XOR<Property_TypesUpdateWithoutPropertySubTypesInput, Property_TypesUncheckedUpdateWithoutPropertySubTypesInput>
  }

  export type Property_AddressesUpdateManyWithoutPropertySubTypesInput = {
    create?: XOR<Enumerable<Property_AddressesCreateWithoutPropertySubTypesInput>, Enumerable<Property_AddressesUncheckedCreateWithoutPropertySubTypesInput>>
    connectOrCreate?: Enumerable<Property_AddressesCreateOrConnectWithoutPropertySubTypesInput>
    upsert?: Enumerable<Property_AddressesUpsertWithWhereUniqueWithoutPropertySubTypesInput>
    connect?: Enumerable<Property_AddressesWhereUniqueInput>
    set?: Enumerable<Property_AddressesWhereUniqueInput>
    disconnect?: Enumerable<Property_AddressesWhereUniqueInput>
    delete?: Enumerable<Property_AddressesWhereUniqueInput>
    update?: Enumerable<Property_AddressesUpdateWithWhereUniqueWithoutPropertySubTypesInput>
    updateMany?: Enumerable<Property_AddressesUpdateManyWithWhereWithoutPropertySubTypesInput>
    deleteMany?: Enumerable<Property_AddressesScalarWhereInput>
  }

  export type UnitLocationsUpdateManyWithoutPropertySubTypesInput = {
    create?: XOR<Enumerable<UnitLocationsCreateWithoutPropertySubTypesInput>, Enumerable<UnitLocationsUncheckedCreateWithoutPropertySubTypesInput>>
    connectOrCreate?: Enumerable<UnitLocationsCreateOrConnectWithoutPropertySubTypesInput>
    upsert?: Enumerable<UnitLocationsUpsertWithWhereUniqueWithoutPropertySubTypesInput>
    connect?: Enumerable<UnitLocationsWhereUniqueInput>
    set?: Enumerable<UnitLocationsWhereUniqueInput>
    disconnect?: Enumerable<UnitLocationsWhereUniqueInput>
    delete?: Enumerable<UnitLocationsWhereUniqueInput>
    update?: Enumerable<UnitLocationsUpdateWithWhereUniqueWithoutPropertySubTypesInput>
    updateMany?: Enumerable<UnitLocationsUpdateManyWithWhereWithoutPropertySubTypesInput>
    deleteMany?: Enumerable<UnitLocationsScalarWhereInput>
  }

  export type Property_AddressesUncheckedUpdateManyWithoutPropertySubTypesInput = {
    create?: XOR<Enumerable<Property_AddressesCreateWithoutPropertySubTypesInput>, Enumerable<Property_AddressesUncheckedCreateWithoutPropertySubTypesInput>>
    connectOrCreate?: Enumerable<Property_AddressesCreateOrConnectWithoutPropertySubTypesInput>
    upsert?: Enumerable<Property_AddressesUpsertWithWhereUniqueWithoutPropertySubTypesInput>
    connect?: Enumerable<Property_AddressesWhereUniqueInput>
    set?: Enumerable<Property_AddressesWhereUniqueInput>
    disconnect?: Enumerable<Property_AddressesWhereUniqueInput>
    delete?: Enumerable<Property_AddressesWhereUniqueInput>
    update?: Enumerable<Property_AddressesUpdateWithWhereUniqueWithoutPropertySubTypesInput>
    updateMany?: Enumerable<Property_AddressesUpdateManyWithWhereWithoutPropertySubTypesInput>
    deleteMany?: Enumerable<Property_AddressesScalarWhereInput>
  }

  export type UnitLocationsUncheckedUpdateManyWithoutPropertySubTypesInput = {
    create?: XOR<Enumerable<UnitLocationsCreateWithoutPropertySubTypesInput>, Enumerable<UnitLocationsUncheckedCreateWithoutPropertySubTypesInput>>
    connectOrCreate?: Enumerable<UnitLocationsCreateOrConnectWithoutPropertySubTypesInput>
    upsert?: Enumerable<UnitLocationsUpsertWithWhereUniqueWithoutPropertySubTypesInput>
    connect?: Enumerable<UnitLocationsWhereUniqueInput>
    set?: Enumerable<UnitLocationsWhereUniqueInput>
    disconnect?: Enumerable<UnitLocationsWhereUniqueInput>
    delete?: Enumerable<UnitLocationsWhereUniqueInput>
    update?: Enumerable<UnitLocationsUpdateWithWhereUniqueWithoutPropertySubTypesInput>
    updateMany?: Enumerable<UnitLocationsUpdateManyWithWhereWithoutPropertySubTypesInput>
    deleteMany?: Enumerable<UnitLocationsScalarWhereInput>
  }

  export type AttributesCreateNestedOneWithoutPropertyUnitAttributesInput = {
    create?: XOR<AttributesCreateWithoutPropertyUnitAttributesInput, AttributesUncheckedCreateWithoutPropertyUnitAttributesInput>
    connectOrCreate?: AttributesCreateOrConnectWithoutPropertyUnitAttributesInput
    connect?: AttributesWhereUniqueInput
  }

  export type AttributeUnitsCreateNestedOneWithoutPropertyUnitAttributesInput = {
    create?: XOR<AttributeUnitsCreateWithoutPropertyUnitAttributesInput, AttributeUnitsUncheckedCreateWithoutPropertyUnitAttributesInput>
    connectOrCreate?: AttributeUnitsCreateOrConnectWithoutPropertyUnitAttributesInput
    connect?: AttributeUnitsWhereUniqueInput
  }

  export type PropertyUnitsCreateNestedOneWithoutPropertyUnitAttributesInput = {
    create?: XOR<PropertyUnitsCreateWithoutPropertyUnitAttributesInput, PropertyUnitsUncheckedCreateWithoutPropertyUnitAttributesInput>
    connectOrCreate?: PropertyUnitsCreateOrConnectWithoutPropertyUnitAttributesInput
    connect?: PropertyUnitsWhereUniqueInput
  }

  export type ScopeOfWorkPropertyUnitsCreateNestedManyWithoutPropertyUnitAttributesInput = {
    create?: XOR<Enumerable<ScopeOfWorkPropertyUnitsCreateWithoutPropertyUnitAttributesInput>, Enumerable<ScopeOfWorkPropertyUnitsUncheckedCreateWithoutPropertyUnitAttributesInput>>
    connectOrCreate?: Enumerable<ScopeOfWorkPropertyUnitsCreateOrConnectWithoutPropertyUnitAttributesInput>
    connect?: Enumerable<ScopeOfWorkPropertyUnitsWhereUniqueInput>
  }

  export type ScopeOfWorkPropertyUnitsUncheckedCreateNestedManyWithoutPropertyUnitAttributesInput = {
    create?: XOR<Enumerable<ScopeOfWorkPropertyUnitsCreateWithoutPropertyUnitAttributesInput>, Enumerable<ScopeOfWorkPropertyUnitsUncheckedCreateWithoutPropertyUnitAttributesInput>>
    connectOrCreate?: Enumerable<ScopeOfWorkPropertyUnitsCreateOrConnectWithoutPropertyUnitAttributesInput>
    connect?: Enumerable<ScopeOfWorkPropertyUnitsWhereUniqueInput>
  }

  export type AttributesUpdateOneRequiredWithoutPropertyUnitAttributesInput = {
    create?: XOR<AttributesCreateWithoutPropertyUnitAttributesInput, AttributesUncheckedCreateWithoutPropertyUnitAttributesInput>
    connectOrCreate?: AttributesCreateOrConnectWithoutPropertyUnitAttributesInput
    upsert?: AttributesUpsertWithoutPropertyUnitAttributesInput
    connect?: AttributesWhereUniqueInput
    update?: XOR<AttributesUpdateWithoutPropertyUnitAttributesInput, AttributesUncheckedUpdateWithoutPropertyUnitAttributesInput>
  }

  export type AttributeUnitsUpdateOneRequiredWithoutPropertyUnitAttributesInput = {
    create?: XOR<AttributeUnitsCreateWithoutPropertyUnitAttributesInput, AttributeUnitsUncheckedCreateWithoutPropertyUnitAttributesInput>
    connectOrCreate?: AttributeUnitsCreateOrConnectWithoutPropertyUnitAttributesInput
    upsert?: AttributeUnitsUpsertWithoutPropertyUnitAttributesInput
    connect?: AttributeUnitsWhereUniqueInput
    update?: XOR<AttributeUnitsUpdateWithoutPropertyUnitAttributesInput, AttributeUnitsUncheckedUpdateWithoutPropertyUnitAttributesInput>
  }

  export type PropertyUnitsUpdateOneRequiredWithoutPropertyUnitAttributesInput = {
    create?: XOR<PropertyUnitsCreateWithoutPropertyUnitAttributesInput, PropertyUnitsUncheckedCreateWithoutPropertyUnitAttributesInput>
    connectOrCreate?: PropertyUnitsCreateOrConnectWithoutPropertyUnitAttributesInput
    upsert?: PropertyUnitsUpsertWithoutPropertyUnitAttributesInput
    connect?: PropertyUnitsWhereUniqueInput
    update?: XOR<PropertyUnitsUpdateWithoutPropertyUnitAttributesInput, PropertyUnitsUncheckedUpdateWithoutPropertyUnitAttributesInput>
  }

  export type ScopeOfWorkPropertyUnitsUpdateManyWithoutPropertyUnitAttributesInput = {
    create?: XOR<Enumerable<ScopeOfWorkPropertyUnitsCreateWithoutPropertyUnitAttributesInput>, Enumerable<ScopeOfWorkPropertyUnitsUncheckedCreateWithoutPropertyUnitAttributesInput>>
    connectOrCreate?: Enumerable<ScopeOfWorkPropertyUnitsCreateOrConnectWithoutPropertyUnitAttributesInput>
    upsert?: Enumerable<ScopeOfWorkPropertyUnitsUpsertWithWhereUniqueWithoutPropertyUnitAttributesInput>
    connect?: Enumerable<ScopeOfWorkPropertyUnitsWhereUniqueInput>
    set?: Enumerable<ScopeOfWorkPropertyUnitsWhereUniqueInput>
    disconnect?: Enumerable<ScopeOfWorkPropertyUnitsWhereUniqueInput>
    delete?: Enumerable<ScopeOfWorkPropertyUnitsWhereUniqueInput>
    update?: Enumerable<ScopeOfWorkPropertyUnitsUpdateWithWhereUniqueWithoutPropertyUnitAttributesInput>
    updateMany?: Enumerable<ScopeOfWorkPropertyUnitsUpdateManyWithWhereWithoutPropertyUnitAttributesInput>
    deleteMany?: Enumerable<ScopeOfWorkPropertyUnitsScalarWhereInput>
  }

  export type ScopeOfWorkPropertyUnitsUncheckedUpdateManyWithoutPropertyUnitAttributesInput = {
    create?: XOR<Enumerable<ScopeOfWorkPropertyUnitsCreateWithoutPropertyUnitAttributesInput>, Enumerable<ScopeOfWorkPropertyUnitsUncheckedCreateWithoutPropertyUnitAttributesInput>>
    connectOrCreate?: Enumerable<ScopeOfWorkPropertyUnitsCreateOrConnectWithoutPropertyUnitAttributesInput>
    upsert?: Enumerable<ScopeOfWorkPropertyUnitsUpsertWithWhereUniqueWithoutPropertyUnitAttributesInput>
    connect?: Enumerable<ScopeOfWorkPropertyUnitsWhereUniqueInput>
    set?: Enumerable<ScopeOfWorkPropertyUnitsWhereUniqueInput>
    disconnect?: Enumerable<ScopeOfWorkPropertyUnitsWhereUniqueInput>
    delete?: Enumerable<ScopeOfWorkPropertyUnitsWhereUniqueInput>
    update?: Enumerable<ScopeOfWorkPropertyUnitsUpdateWithWhereUniqueWithoutPropertyUnitAttributesInput>
    updateMany?: Enumerable<ScopeOfWorkPropertyUnitsUpdateManyWithWhereWithoutPropertyUnitAttributesInput>
    deleteMany?: Enumerable<ScopeOfWorkPropertyUnitsScalarWhereInput>
  }

  export type ProductCategoriesCreateNestedOneWithoutPropertyUnitProductCategoriesInput = {
    create?: XOR<ProductCategoriesCreateWithoutPropertyUnitProductCategoriesInput, ProductCategoriesUncheckedCreateWithoutPropertyUnitProductCategoriesInput>
    connectOrCreate?: ProductCategoriesCreateOrConnectWithoutPropertyUnitProductCategoriesInput
    connect?: ProductCategoriesWhereUniqueInput
  }

  export type PropertyUnitsCreateNestedOneWithoutPropertyUnitProductCategoriesInput = {
    create?: XOR<PropertyUnitsCreateWithoutPropertyUnitProductCategoriesInput, PropertyUnitsUncheckedCreateWithoutPropertyUnitProductCategoriesInput>
    connectOrCreate?: PropertyUnitsCreateOrConnectWithoutPropertyUnitProductCategoriesInput
    connect?: PropertyUnitsWhereUniqueInput
  }

  export type PropertyUnitProductCategoryProductsCreateNestedManyWithoutPropertyUnitProductCategoriesInput = {
    create?: XOR<Enumerable<PropertyUnitProductCategoryProductsCreateWithoutPropertyUnitProductCategoriesInput>, Enumerable<PropertyUnitProductCategoryProductsUncheckedCreateWithoutPropertyUnitProductCategoriesInput>>
    connectOrCreate?: Enumerable<PropertyUnitProductCategoryProductsCreateOrConnectWithoutPropertyUnitProductCategoriesInput>
    connect?: Enumerable<PropertyUnitProductCategoryProductsWhereUniqueInput>
  }

  export type PropertyUnitProductCategoryProductsUncheckedCreateNestedManyWithoutPropertyUnitProductCategoriesInput = {
    create?: XOR<Enumerable<PropertyUnitProductCategoryProductsCreateWithoutPropertyUnitProductCategoriesInput>, Enumerable<PropertyUnitProductCategoryProductsUncheckedCreateWithoutPropertyUnitProductCategoriesInput>>
    connectOrCreate?: Enumerable<PropertyUnitProductCategoryProductsCreateOrConnectWithoutPropertyUnitProductCategoriesInput>
    connect?: Enumerable<PropertyUnitProductCategoryProductsWhereUniqueInput>
  }

  export type ProductCategoriesUpdateOneRequiredWithoutPropertyUnitProductCategoriesInput = {
    create?: XOR<ProductCategoriesCreateWithoutPropertyUnitProductCategoriesInput, ProductCategoriesUncheckedCreateWithoutPropertyUnitProductCategoriesInput>
    connectOrCreate?: ProductCategoriesCreateOrConnectWithoutPropertyUnitProductCategoriesInput
    upsert?: ProductCategoriesUpsertWithoutPropertyUnitProductCategoriesInput
    connect?: ProductCategoriesWhereUniqueInput
    update?: XOR<ProductCategoriesUpdateWithoutPropertyUnitProductCategoriesInput, ProductCategoriesUncheckedUpdateWithoutPropertyUnitProductCategoriesInput>
  }

  export type PropertyUnitsUpdateOneRequiredWithoutPropertyUnitProductCategoriesInput = {
    create?: XOR<PropertyUnitsCreateWithoutPropertyUnitProductCategoriesInput, PropertyUnitsUncheckedCreateWithoutPropertyUnitProductCategoriesInput>
    connectOrCreate?: PropertyUnitsCreateOrConnectWithoutPropertyUnitProductCategoriesInput
    upsert?: PropertyUnitsUpsertWithoutPropertyUnitProductCategoriesInput
    connect?: PropertyUnitsWhereUniqueInput
    update?: XOR<PropertyUnitsUpdateWithoutPropertyUnitProductCategoriesInput, PropertyUnitsUncheckedUpdateWithoutPropertyUnitProductCategoriesInput>
  }

  export type PropertyUnitProductCategoryProductsUpdateManyWithoutPropertyUnitProductCategoriesInput = {
    create?: XOR<Enumerable<PropertyUnitProductCategoryProductsCreateWithoutPropertyUnitProductCategoriesInput>, Enumerable<PropertyUnitProductCategoryProductsUncheckedCreateWithoutPropertyUnitProductCategoriesInput>>
    connectOrCreate?: Enumerable<PropertyUnitProductCategoryProductsCreateOrConnectWithoutPropertyUnitProductCategoriesInput>
    upsert?: Enumerable<PropertyUnitProductCategoryProductsUpsertWithWhereUniqueWithoutPropertyUnitProductCategoriesInput>
    connect?: Enumerable<PropertyUnitProductCategoryProductsWhereUniqueInput>
    set?: Enumerable<PropertyUnitProductCategoryProductsWhereUniqueInput>
    disconnect?: Enumerable<PropertyUnitProductCategoryProductsWhereUniqueInput>
    delete?: Enumerable<PropertyUnitProductCategoryProductsWhereUniqueInput>
    update?: Enumerable<PropertyUnitProductCategoryProductsUpdateWithWhereUniqueWithoutPropertyUnitProductCategoriesInput>
    updateMany?: Enumerable<PropertyUnitProductCategoryProductsUpdateManyWithWhereWithoutPropertyUnitProductCategoriesInput>
    deleteMany?: Enumerable<PropertyUnitProductCategoryProductsScalarWhereInput>
  }

  export type PropertyUnitProductCategoryProductsUncheckedUpdateManyWithoutPropertyUnitProductCategoriesInput = {
    create?: XOR<Enumerable<PropertyUnitProductCategoryProductsCreateWithoutPropertyUnitProductCategoriesInput>, Enumerable<PropertyUnitProductCategoryProductsUncheckedCreateWithoutPropertyUnitProductCategoriesInput>>
    connectOrCreate?: Enumerable<PropertyUnitProductCategoryProductsCreateOrConnectWithoutPropertyUnitProductCategoriesInput>
    upsert?: Enumerable<PropertyUnitProductCategoryProductsUpsertWithWhereUniqueWithoutPropertyUnitProductCategoriesInput>
    connect?: Enumerable<PropertyUnitProductCategoryProductsWhereUniqueInput>
    set?: Enumerable<PropertyUnitProductCategoryProductsWhereUniqueInput>
    disconnect?: Enumerable<PropertyUnitProductCategoryProductsWhereUniqueInput>
    delete?: Enumerable<PropertyUnitProductCategoryProductsWhereUniqueInput>
    update?: Enumerable<PropertyUnitProductCategoryProductsUpdateWithWhereUniqueWithoutPropertyUnitProductCategoriesInput>
    updateMany?: Enumerable<PropertyUnitProductCategoryProductsUpdateManyWithWhereWithoutPropertyUnitProductCategoriesInput>
    deleteMany?: Enumerable<PropertyUnitProductCategoryProductsScalarWhereInput>
  }

  export type ProductsCreateNestedOneWithoutPropertyUnitProductCategoryProductsInput = {
    create?: XOR<ProductsCreateWithoutPropertyUnitProductCategoryProductsInput, ProductsUncheckedCreateWithoutPropertyUnitProductCategoryProductsInput>
    connectOrCreate?: ProductsCreateOrConnectWithoutPropertyUnitProductCategoryProductsInput
    connect?: ProductsWhereUniqueInput
  }

  export type PropertyUnitProductCategoriesCreateNestedOneWithoutPropertyUnitProductCategoryProductsInput = {
    create?: XOR<PropertyUnitProductCategoriesCreateWithoutPropertyUnitProductCategoryProductsInput, PropertyUnitProductCategoriesUncheckedCreateWithoutPropertyUnitProductCategoryProductsInput>
    connectOrCreate?: PropertyUnitProductCategoriesCreateOrConnectWithoutPropertyUnitProductCategoryProductsInput
    connect?: PropertyUnitProductCategoriesWhereUniqueInput
  }

  export type ProductsUpdateOneRequiredWithoutPropertyUnitProductCategoryProductsInput = {
    create?: XOR<ProductsCreateWithoutPropertyUnitProductCategoryProductsInput, ProductsUncheckedCreateWithoutPropertyUnitProductCategoryProductsInput>
    connectOrCreate?: ProductsCreateOrConnectWithoutPropertyUnitProductCategoryProductsInput
    upsert?: ProductsUpsertWithoutPropertyUnitProductCategoryProductsInput
    connect?: ProductsWhereUniqueInput
    update?: XOR<ProductsUpdateWithoutPropertyUnitProductCategoryProductsInput, ProductsUncheckedUpdateWithoutPropertyUnitProductCategoryProductsInput>
  }

  export type PropertyUnitProductCategoriesUpdateOneRequiredWithoutPropertyUnitProductCategoryProductsInput = {
    create?: XOR<PropertyUnitProductCategoriesCreateWithoutPropertyUnitProductCategoryProductsInput, PropertyUnitProductCategoriesUncheckedCreateWithoutPropertyUnitProductCategoryProductsInput>
    connectOrCreate?: PropertyUnitProductCategoriesCreateOrConnectWithoutPropertyUnitProductCategoryProductsInput
    upsert?: PropertyUnitProductCategoriesUpsertWithoutPropertyUnitProductCategoryProductsInput
    connect?: PropertyUnitProductCategoriesWhereUniqueInput
    update?: XOR<PropertyUnitProductCategoriesUpdateWithoutPropertyUnitProductCategoryProductsInput, PropertyUnitProductCategoriesUncheckedUpdateWithoutPropertyUnitProductCategoryProductsInput>
  }

  export type ProductPropertyUnitsCreateNestedManyWithoutPropertyUnitsInput = {
    create?: XOR<Enumerable<ProductPropertyUnitsCreateWithoutPropertyUnitsInput>, Enumerable<ProductPropertyUnitsUncheckedCreateWithoutPropertyUnitsInput>>
    connectOrCreate?: Enumerable<ProductPropertyUnitsCreateOrConnectWithoutPropertyUnitsInput>
    connect?: Enumerable<ProductPropertyUnitsWhereUniqueInput>
  }

  export type PropertyUnitAttributesCreateNestedManyWithoutPropertyUnitsInput = {
    create?: XOR<Enumerable<PropertyUnitAttributesCreateWithoutPropertyUnitsInput>, Enumerable<PropertyUnitAttributesUncheckedCreateWithoutPropertyUnitsInput>>
    connectOrCreate?: Enumerable<PropertyUnitAttributesCreateOrConnectWithoutPropertyUnitsInput>
    connect?: Enumerable<PropertyUnitAttributesWhereUniqueInput>
  }

  export type PropertyUnitProductCategoriesCreateNestedManyWithoutPropertyUnitsInput = {
    create?: XOR<Enumerable<PropertyUnitProductCategoriesCreateWithoutPropertyUnitsInput>, Enumerable<PropertyUnitProductCategoriesUncheckedCreateWithoutPropertyUnitsInput>>
    connectOrCreate?: Enumerable<PropertyUnitProductCategoriesCreateOrConnectWithoutPropertyUnitsInput>
    connect?: Enumerable<PropertyUnitProductCategoriesWhereUniqueInput>
  }

  export type UnitLocationsCreateNestedManyWithoutPropertyUnitsInput = {
    create?: XOR<Enumerable<UnitLocationsCreateWithoutPropertyUnitsInput>, Enumerable<UnitLocationsUncheckedCreateWithoutPropertyUnitsInput>>
    connectOrCreate?: Enumerable<UnitLocationsCreateOrConnectWithoutPropertyUnitsInput>
    connect?: Enumerable<UnitLocationsWhereUniqueInput>
  }

  export type ProductPropertyUnitsUncheckedCreateNestedManyWithoutPropertyUnitsInput = {
    create?: XOR<Enumerable<ProductPropertyUnitsCreateWithoutPropertyUnitsInput>, Enumerable<ProductPropertyUnitsUncheckedCreateWithoutPropertyUnitsInput>>
    connectOrCreate?: Enumerable<ProductPropertyUnitsCreateOrConnectWithoutPropertyUnitsInput>
    connect?: Enumerable<ProductPropertyUnitsWhereUniqueInput>
  }

  export type PropertyUnitAttributesUncheckedCreateNestedManyWithoutPropertyUnitsInput = {
    create?: XOR<Enumerable<PropertyUnitAttributesCreateWithoutPropertyUnitsInput>, Enumerable<PropertyUnitAttributesUncheckedCreateWithoutPropertyUnitsInput>>
    connectOrCreate?: Enumerable<PropertyUnitAttributesCreateOrConnectWithoutPropertyUnitsInput>
    connect?: Enumerable<PropertyUnitAttributesWhereUniqueInput>
  }

  export type PropertyUnitProductCategoriesUncheckedCreateNestedManyWithoutPropertyUnitsInput = {
    create?: XOR<Enumerable<PropertyUnitProductCategoriesCreateWithoutPropertyUnitsInput>, Enumerable<PropertyUnitProductCategoriesUncheckedCreateWithoutPropertyUnitsInput>>
    connectOrCreate?: Enumerable<PropertyUnitProductCategoriesCreateOrConnectWithoutPropertyUnitsInput>
    connect?: Enumerable<PropertyUnitProductCategoriesWhereUniqueInput>
  }

  export type UnitLocationsUncheckedCreateNestedManyWithoutPropertyUnitsInput = {
    create?: XOR<Enumerable<UnitLocationsCreateWithoutPropertyUnitsInput>, Enumerable<UnitLocationsUncheckedCreateWithoutPropertyUnitsInput>>
    connectOrCreate?: Enumerable<UnitLocationsCreateOrConnectWithoutPropertyUnitsInput>
    connect?: Enumerable<UnitLocationsWhereUniqueInput>
  }

  export type ProductPropertyUnitsUpdateManyWithoutPropertyUnitsInput = {
    create?: XOR<Enumerable<ProductPropertyUnitsCreateWithoutPropertyUnitsInput>, Enumerable<ProductPropertyUnitsUncheckedCreateWithoutPropertyUnitsInput>>
    connectOrCreate?: Enumerable<ProductPropertyUnitsCreateOrConnectWithoutPropertyUnitsInput>
    upsert?: Enumerable<ProductPropertyUnitsUpsertWithWhereUniqueWithoutPropertyUnitsInput>
    connect?: Enumerable<ProductPropertyUnitsWhereUniqueInput>
    set?: Enumerable<ProductPropertyUnitsWhereUniqueInput>
    disconnect?: Enumerable<ProductPropertyUnitsWhereUniqueInput>
    delete?: Enumerable<ProductPropertyUnitsWhereUniqueInput>
    update?: Enumerable<ProductPropertyUnitsUpdateWithWhereUniqueWithoutPropertyUnitsInput>
    updateMany?: Enumerable<ProductPropertyUnitsUpdateManyWithWhereWithoutPropertyUnitsInput>
    deleteMany?: Enumerable<ProductPropertyUnitsScalarWhereInput>
  }

  export type PropertyUnitAttributesUpdateManyWithoutPropertyUnitsInput = {
    create?: XOR<Enumerable<PropertyUnitAttributesCreateWithoutPropertyUnitsInput>, Enumerable<PropertyUnitAttributesUncheckedCreateWithoutPropertyUnitsInput>>
    connectOrCreate?: Enumerable<PropertyUnitAttributesCreateOrConnectWithoutPropertyUnitsInput>
    upsert?: Enumerable<PropertyUnitAttributesUpsertWithWhereUniqueWithoutPropertyUnitsInput>
    connect?: Enumerable<PropertyUnitAttributesWhereUniqueInput>
    set?: Enumerable<PropertyUnitAttributesWhereUniqueInput>
    disconnect?: Enumerable<PropertyUnitAttributesWhereUniqueInput>
    delete?: Enumerable<PropertyUnitAttributesWhereUniqueInput>
    update?: Enumerable<PropertyUnitAttributesUpdateWithWhereUniqueWithoutPropertyUnitsInput>
    updateMany?: Enumerable<PropertyUnitAttributesUpdateManyWithWhereWithoutPropertyUnitsInput>
    deleteMany?: Enumerable<PropertyUnitAttributesScalarWhereInput>
  }

  export type PropertyUnitProductCategoriesUpdateManyWithoutPropertyUnitsInput = {
    create?: XOR<Enumerable<PropertyUnitProductCategoriesCreateWithoutPropertyUnitsInput>, Enumerable<PropertyUnitProductCategoriesUncheckedCreateWithoutPropertyUnitsInput>>
    connectOrCreate?: Enumerable<PropertyUnitProductCategoriesCreateOrConnectWithoutPropertyUnitsInput>
    upsert?: Enumerable<PropertyUnitProductCategoriesUpsertWithWhereUniqueWithoutPropertyUnitsInput>
    connect?: Enumerable<PropertyUnitProductCategoriesWhereUniqueInput>
    set?: Enumerable<PropertyUnitProductCategoriesWhereUniqueInput>
    disconnect?: Enumerable<PropertyUnitProductCategoriesWhereUniqueInput>
    delete?: Enumerable<PropertyUnitProductCategoriesWhereUniqueInput>
    update?: Enumerable<PropertyUnitProductCategoriesUpdateWithWhereUniqueWithoutPropertyUnitsInput>
    updateMany?: Enumerable<PropertyUnitProductCategoriesUpdateManyWithWhereWithoutPropertyUnitsInput>
    deleteMany?: Enumerable<PropertyUnitProductCategoriesScalarWhereInput>
  }

  export type UnitLocationsUpdateManyWithoutPropertyUnitsInput = {
    create?: XOR<Enumerable<UnitLocationsCreateWithoutPropertyUnitsInput>, Enumerable<UnitLocationsUncheckedCreateWithoutPropertyUnitsInput>>
    connectOrCreate?: Enumerable<UnitLocationsCreateOrConnectWithoutPropertyUnitsInput>
    upsert?: Enumerable<UnitLocationsUpsertWithWhereUniqueWithoutPropertyUnitsInput>
    connect?: Enumerable<UnitLocationsWhereUniqueInput>
    set?: Enumerable<UnitLocationsWhereUniqueInput>
    disconnect?: Enumerable<UnitLocationsWhereUniqueInput>
    delete?: Enumerable<UnitLocationsWhereUniqueInput>
    update?: Enumerable<UnitLocationsUpdateWithWhereUniqueWithoutPropertyUnitsInput>
    updateMany?: Enumerable<UnitLocationsUpdateManyWithWhereWithoutPropertyUnitsInput>
    deleteMany?: Enumerable<UnitLocationsScalarWhereInput>
  }

  export type ProductPropertyUnitsUncheckedUpdateManyWithoutPropertyUnitsInput = {
    create?: XOR<Enumerable<ProductPropertyUnitsCreateWithoutPropertyUnitsInput>, Enumerable<ProductPropertyUnitsUncheckedCreateWithoutPropertyUnitsInput>>
    connectOrCreate?: Enumerable<ProductPropertyUnitsCreateOrConnectWithoutPropertyUnitsInput>
    upsert?: Enumerable<ProductPropertyUnitsUpsertWithWhereUniqueWithoutPropertyUnitsInput>
    connect?: Enumerable<ProductPropertyUnitsWhereUniqueInput>
    set?: Enumerable<ProductPropertyUnitsWhereUniqueInput>
    disconnect?: Enumerable<ProductPropertyUnitsWhereUniqueInput>
    delete?: Enumerable<ProductPropertyUnitsWhereUniqueInput>
    update?: Enumerable<ProductPropertyUnitsUpdateWithWhereUniqueWithoutPropertyUnitsInput>
    updateMany?: Enumerable<ProductPropertyUnitsUpdateManyWithWhereWithoutPropertyUnitsInput>
    deleteMany?: Enumerable<ProductPropertyUnitsScalarWhereInput>
  }

  export type PropertyUnitAttributesUncheckedUpdateManyWithoutPropertyUnitsInput = {
    create?: XOR<Enumerable<PropertyUnitAttributesCreateWithoutPropertyUnitsInput>, Enumerable<PropertyUnitAttributesUncheckedCreateWithoutPropertyUnitsInput>>
    connectOrCreate?: Enumerable<PropertyUnitAttributesCreateOrConnectWithoutPropertyUnitsInput>
    upsert?: Enumerable<PropertyUnitAttributesUpsertWithWhereUniqueWithoutPropertyUnitsInput>
    connect?: Enumerable<PropertyUnitAttributesWhereUniqueInput>
    set?: Enumerable<PropertyUnitAttributesWhereUniqueInput>
    disconnect?: Enumerable<PropertyUnitAttributesWhereUniqueInput>
    delete?: Enumerable<PropertyUnitAttributesWhereUniqueInput>
    update?: Enumerable<PropertyUnitAttributesUpdateWithWhereUniqueWithoutPropertyUnitsInput>
    updateMany?: Enumerable<PropertyUnitAttributesUpdateManyWithWhereWithoutPropertyUnitsInput>
    deleteMany?: Enumerable<PropertyUnitAttributesScalarWhereInput>
  }

  export type PropertyUnitProductCategoriesUncheckedUpdateManyWithoutPropertyUnitsInput = {
    create?: XOR<Enumerable<PropertyUnitProductCategoriesCreateWithoutPropertyUnitsInput>, Enumerable<PropertyUnitProductCategoriesUncheckedCreateWithoutPropertyUnitsInput>>
    connectOrCreate?: Enumerable<PropertyUnitProductCategoriesCreateOrConnectWithoutPropertyUnitsInput>
    upsert?: Enumerable<PropertyUnitProductCategoriesUpsertWithWhereUniqueWithoutPropertyUnitsInput>
    connect?: Enumerable<PropertyUnitProductCategoriesWhereUniqueInput>
    set?: Enumerable<PropertyUnitProductCategoriesWhereUniqueInput>
    disconnect?: Enumerable<PropertyUnitProductCategoriesWhereUniqueInput>
    delete?: Enumerable<PropertyUnitProductCategoriesWhereUniqueInput>
    update?: Enumerable<PropertyUnitProductCategoriesUpdateWithWhereUniqueWithoutPropertyUnitsInput>
    updateMany?: Enumerable<PropertyUnitProductCategoriesUpdateManyWithWhereWithoutPropertyUnitsInput>
    deleteMany?: Enumerable<PropertyUnitProductCategoriesScalarWhereInput>
  }

  export type UnitLocationsUncheckedUpdateManyWithoutPropertyUnitsInput = {
    create?: XOR<Enumerable<UnitLocationsCreateWithoutPropertyUnitsInput>, Enumerable<UnitLocationsUncheckedCreateWithoutPropertyUnitsInput>>
    connectOrCreate?: Enumerable<UnitLocationsCreateOrConnectWithoutPropertyUnitsInput>
    upsert?: Enumerable<UnitLocationsUpsertWithWhereUniqueWithoutPropertyUnitsInput>
    connect?: Enumerable<UnitLocationsWhereUniqueInput>
    set?: Enumerable<UnitLocationsWhereUniqueInput>
    disconnect?: Enumerable<UnitLocationsWhereUniqueInput>
    delete?: Enumerable<UnitLocationsWhereUniqueInput>
    update?: Enumerable<UnitLocationsUpdateWithWhereUniqueWithoutPropertyUnitsInput>
    updateMany?: Enumerable<UnitLocationsUpdateManyWithWhereWithoutPropertyUnitsInput>
    deleteMany?: Enumerable<UnitLocationsScalarWhereInput>
  }

  export type CitiesCreateNestedOneWithoutProperty_AddressesInput = {
    create?: XOR<CitiesCreateWithoutProperty_AddressesInput, CitiesUncheckedCreateWithoutProperty_AddressesInput>
    connectOrCreate?: CitiesCreateOrConnectWithoutProperty_AddressesInput
    connect?: CitiesWhereUniqueInput
  }

  export type PropertyOwnersCreateNestedOneWithoutProperty_AddressesInput = {
    create?: XOR<PropertyOwnersCreateWithoutProperty_AddressesInput, PropertyOwnersUncheckedCreateWithoutProperty_AddressesInput>
    connectOrCreate?: PropertyOwnersCreateOrConnectWithoutProperty_AddressesInput
    connect?: PropertyOwnersWhereUniqueInput
  }

  export type PropertySubTypesCreateNestedOneWithoutProperty_AddressesInput = {
    create?: XOR<PropertySubTypesCreateWithoutProperty_AddressesInput, PropertySubTypesUncheckedCreateWithoutProperty_AddressesInput>
    connectOrCreate?: PropertySubTypesCreateOrConnectWithoutProperty_AddressesInput
    connect?: PropertySubTypesWhereUniqueInput
  }

  export type ProjectsCreateNestedManyWithoutProperty_AddressesInput = {
    create?: XOR<Enumerable<ProjectsCreateWithoutProperty_AddressesInput>, Enumerable<ProjectsUncheckedCreateWithoutProperty_AddressesInput>>
    connectOrCreate?: Enumerable<ProjectsCreateOrConnectWithoutProperty_AddressesInput>
    connect?: Enumerable<ProjectsWhereUniqueInput>
  }

  export type ProjectsUncheckedCreateNestedManyWithoutProperty_AddressesInput = {
    create?: XOR<Enumerable<ProjectsCreateWithoutProperty_AddressesInput>, Enumerable<ProjectsUncheckedCreateWithoutProperty_AddressesInput>>
    connectOrCreate?: Enumerable<ProjectsCreateOrConnectWithoutProperty_AddressesInput>
    connect?: Enumerable<ProjectsWhereUniqueInput>
  }

  export type CitiesUpdateOneRequiredWithoutProperty_AddressesInput = {
    create?: XOR<CitiesCreateWithoutProperty_AddressesInput, CitiesUncheckedCreateWithoutProperty_AddressesInput>
    connectOrCreate?: CitiesCreateOrConnectWithoutProperty_AddressesInput
    upsert?: CitiesUpsertWithoutProperty_AddressesInput
    connect?: CitiesWhereUniqueInput
    update?: XOR<CitiesUpdateWithoutProperty_AddressesInput, CitiesUncheckedUpdateWithoutProperty_AddressesInput>
  }

  export type PropertyOwnersUpdateOneRequiredWithoutProperty_AddressesInput = {
    create?: XOR<PropertyOwnersCreateWithoutProperty_AddressesInput, PropertyOwnersUncheckedCreateWithoutProperty_AddressesInput>
    connectOrCreate?: PropertyOwnersCreateOrConnectWithoutProperty_AddressesInput
    upsert?: PropertyOwnersUpsertWithoutProperty_AddressesInput
    connect?: PropertyOwnersWhereUniqueInput
    update?: XOR<PropertyOwnersUpdateWithoutProperty_AddressesInput, PropertyOwnersUncheckedUpdateWithoutProperty_AddressesInput>
  }

  export type PropertySubTypesUpdateOneRequiredWithoutProperty_AddressesInput = {
    create?: XOR<PropertySubTypesCreateWithoutProperty_AddressesInput, PropertySubTypesUncheckedCreateWithoutProperty_AddressesInput>
    connectOrCreate?: PropertySubTypesCreateOrConnectWithoutProperty_AddressesInput
    upsert?: PropertySubTypesUpsertWithoutProperty_AddressesInput
    connect?: PropertySubTypesWhereUniqueInput
    update?: XOR<PropertySubTypesUpdateWithoutProperty_AddressesInput, PropertySubTypesUncheckedUpdateWithoutProperty_AddressesInput>
  }

  export type ProjectsUpdateManyWithoutProperty_AddressesInput = {
    create?: XOR<Enumerable<ProjectsCreateWithoutProperty_AddressesInput>, Enumerable<ProjectsUncheckedCreateWithoutProperty_AddressesInput>>
    connectOrCreate?: Enumerable<ProjectsCreateOrConnectWithoutProperty_AddressesInput>
    upsert?: Enumerable<ProjectsUpsertWithWhereUniqueWithoutProperty_AddressesInput>
    connect?: Enumerable<ProjectsWhereUniqueInput>
    set?: Enumerable<ProjectsWhereUniqueInput>
    disconnect?: Enumerable<ProjectsWhereUniqueInput>
    delete?: Enumerable<ProjectsWhereUniqueInput>
    update?: Enumerable<ProjectsUpdateWithWhereUniqueWithoutProperty_AddressesInput>
    updateMany?: Enumerable<ProjectsUpdateManyWithWhereWithoutProperty_AddressesInput>
    deleteMany?: Enumerable<ProjectsScalarWhereInput>
  }

  export type ProjectsUncheckedUpdateManyWithoutProperty_AddressesInput = {
    create?: XOR<Enumerable<ProjectsCreateWithoutProperty_AddressesInput>, Enumerable<ProjectsUncheckedCreateWithoutProperty_AddressesInput>>
    connectOrCreate?: Enumerable<ProjectsCreateOrConnectWithoutProperty_AddressesInput>
    upsert?: Enumerable<ProjectsUpsertWithWhereUniqueWithoutProperty_AddressesInput>
    connect?: Enumerable<ProjectsWhereUniqueInput>
    set?: Enumerable<ProjectsWhereUniqueInput>
    disconnect?: Enumerable<ProjectsWhereUniqueInput>
    delete?: Enumerable<ProjectsWhereUniqueInput>
    update?: Enumerable<ProjectsUpdateWithWhereUniqueWithoutProperty_AddressesInput>
    updateMany?: Enumerable<ProjectsUpdateManyWithWhereWithoutProperty_AddressesInput>
    deleteMany?: Enumerable<ProjectsScalarWhereInput>
  }

  export type PropertySubTypesCreateNestedManyWithoutProperty_TypesInput = {
    create?: XOR<Enumerable<PropertySubTypesCreateWithoutProperty_TypesInput>, Enumerable<PropertySubTypesUncheckedCreateWithoutProperty_TypesInput>>
    connectOrCreate?: Enumerable<PropertySubTypesCreateOrConnectWithoutProperty_TypesInput>
    connect?: Enumerable<PropertySubTypesWhereUniqueInput>
  }

  export type PropertySubTypesUncheckedCreateNestedManyWithoutProperty_TypesInput = {
    create?: XOR<Enumerable<PropertySubTypesCreateWithoutProperty_TypesInput>, Enumerable<PropertySubTypesUncheckedCreateWithoutProperty_TypesInput>>
    connectOrCreate?: Enumerable<PropertySubTypesCreateOrConnectWithoutProperty_TypesInput>
    connect?: Enumerable<PropertySubTypesWhereUniqueInput>
  }

  export type PropertySubTypesUpdateManyWithoutProperty_TypesInput = {
    create?: XOR<Enumerable<PropertySubTypesCreateWithoutProperty_TypesInput>, Enumerable<PropertySubTypesUncheckedCreateWithoutProperty_TypesInput>>
    connectOrCreate?: Enumerable<PropertySubTypesCreateOrConnectWithoutProperty_TypesInput>
    upsert?: Enumerable<PropertySubTypesUpsertWithWhereUniqueWithoutProperty_TypesInput>
    connect?: Enumerable<PropertySubTypesWhereUniqueInput>
    set?: Enumerable<PropertySubTypesWhereUniqueInput>
    disconnect?: Enumerable<PropertySubTypesWhereUniqueInput>
    delete?: Enumerable<PropertySubTypesWhereUniqueInput>
    update?: Enumerable<PropertySubTypesUpdateWithWhereUniqueWithoutProperty_TypesInput>
    updateMany?: Enumerable<PropertySubTypesUpdateManyWithWhereWithoutProperty_TypesInput>
    deleteMany?: Enumerable<PropertySubTypesScalarWhereInput>
  }

  export type PropertySubTypesUncheckedUpdateManyWithoutProperty_TypesInput = {
    create?: XOR<Enumerable<PropertySubTypesCreateWithoutProperty_TypesInput>, Enumerable<PropertySubTypesUncheckedCreateWithoutProperty_TypesInput>>
    connectOrCreate?: Enumerable<PropertySubTypesCreateOrConnectWithoutProperty_TypesInput>
    upsert?: Enumerable<PropertySubTypesUpsertWithWhereUniqueWithoutProperty_TypesInput>
    connect?: Enumerable<PropertySubTypesWhereUniqueInput>
    set?: Enumerable<PropertySubTypesWhereUniqueInput>
    disconnect?: Enumerable<PropertySubTypesWhereUniqueInput>
    delete?: Enumerable<PropertySubTypesWhereUniqueInput>
    update?: Enumerable<PropertySubTypesUpdateWithWhereUniqueWithoutProperty_TypesInput>
    updateMany?: Enumerable<PropertySubTypesUpdateManyWithWhereWithoutProperty_TypesInput>
    deleteMany?: Enumerable<PropertySubTypesScalarWhereInput>
  }

  export type AreaOfWorksCreateNestedOneWithoutScopeOfWorkPropertyUnitsInput = {
    create?: XOR<AreaOfWorksCreateWithoutScopeOfWorkPropertyUnitsInput, AreaOfWorksUncheckedCreateWithoutScopeOfWorkPropertyUnitsInput>
    connectOrCreate?: AreaOfWorksCreateOrConnectWithoutScopeOfWorkPropertyUnitsInput
    connect?: AreaOfWorksWhereUniqueInput
  }

  export type ProjectProposalsCreateNestedOneWithoutScopeOfWorkPropertyUnitsInput = {
    create?: XOR<ProjectProposalsCreateWithoutScopeOfWorkPropertyUnitsInput, ProjectProposalsUncheckedCreateWithoutScopeOfWorkPropertyUnitsInput>
    connectOrCreate?: ProjectProposalsCreateOrConnectWithoutScopeOfWorkPropertyUnitsInput
    connect?: ProjectProposalsWhereUniqueInput
  }

  export type PropertyUnitAttributesCreateNestedOneWithoutScopeOfWorkPropertyUnitsInput = {
    create?: XOR<PropertyUnitAttributesCreateWithoutScopeOfWorkPropertyUnitsInput, PropertyUnitAttributesUncheckedCreateWithoutScopeOfWorkPropertyUnitsInput>
    connectOrCreate?: PropertyUnitAttributesCreateOrConnectWithoutScopeOfWorkPropertyUnitsInput
    connect?: PropertyUnitAttributesWhereUniqueInput
  }

  export type AreaOfWorksUpdateOneRequiredWithoutScopeOfWorkPropertyUnitsInput = {
    create?: XOR<AreaOfWorksCreateWithoutScopeOfWorkPropertyUnitsInput, AreaOfWorksUncheckedCreateWithoutScopeOfWorkPropertyUnitsInput>
    connectOrCreate?: AreaOfWorksCreateOrConnectWithoutScopeOfWorkPropertyUnitsInput
    upsert?: AreaOfWorksUpsertWithoutScopeOfWorkPropertyUnitsInput
    connect?: AreaOfWorksWhereUniqueInput
    update?: XOR<AreaOfWorksUpdateWithoutScopeOfWorkPropertyUnitsInput, AreaOfWorksUncheckedUpdateWithoutScopeOfWorkPropertyUnitsInput>
  }

  export type ProjectProposalsUpdateOneRequiredWithoutScopeOfWorkPropertyUnitsInput = {
    create?: XOR<ProjectProposalsCreateWithoutScopeOfWorkPropertyUnitsInput, ProjectProposalsUncheckedCreateWithoutScopeOfWorkPropertyUnitsInput>
    connectOrCreate?: ProjectProposalsCreateOrConnectWithoutScopeOfWorkPropertyUnitsInput
    upsert?: ProjectProposalsUpsertWithoutScopeOfWorkPropertyUnitsInput
    connect?: ProjectProposalsWhereUniqueInput
    update?: XOR<ProjectProposalsUpdateWithoutScopeOfWorkPropertyUnitsInput, ProjectProposalsUncheckedUpdateWithoutScopeOfWorkPropertyUnitsInput>
  }

  export type PropertyUnitAttributesUpdateOneRequiredWithoutScopeOfWorkPropertyUnitsInput = {
    create?: XOR<PropertyUnitAttributesCreateWithoutScopeOfWorkPropertyUnitsInput, PropertyUnitAttributesUncheckedCreateWithoutScopeOfWorkPropertyUnitsInput>
    connectOrCreate?: PropertyUnitAttributesCreateOrConnectWithoutScopeOfWorkPropertyUnitsInput
    upsert?: PropertyUnitAttributesUpsertWithoutScopeOfWorkPropertyUnitsInput
    connect?: PropertyUnitAttributesWhereUniqueInput
    update?: XOR<PropertyUnitAttributesUpdateWithoutScopeOfWorkPropertyUnitsInput, PropertyUnitAttributesUncheckedUpdateWithoutScopeOfWorkPropertyUnitsInput>
  }

  export type AreaOfWorksCreateNestedOneWithoutScopeOfWorksInput = {
    create?: XOR<AreaOfWorksCreateWithoutScopeOfWorksInput, AreaOfWorksUncheckedCreateWithoutScopeOfWorksInput>
    connectOrCreate?: AreaOfWorksCreateOrConnectWithoutScopeOfWorksInput
    connect?: AreaOfWorksWhereUniqueInput
  }

  export type ProductAttributeUnitsCreateNestedOneWithoutScopeOfWorksInput = {
    create?: XOR<ProductAttributeUnitsCreateWithoutScopeOfWorksInput, ProductAttributeUnitsUncheckedCreateWithoutScopeOfWorksInput>
    connectOrCreate?: ProductAttributeUnitsCreateOrConnectWithoutScopeOfWorksInput
    connect?: ProductAttributeUnitsWhereUniqueInput
  }

  export type ProductAttributeUnitValuesCreateNestedOneWithoutScopeOfWorksInput = {
    create?: XOR<ProductAttributeUnitValuesCreateWithoutScopeOfWorksInput, ProductAttributeUnitValuesUncheckedCreateWithoutScopeOfWorksInput>
    connectOrCreate?: ProductAttributeUnitValuesCreateOrConnectWithoutScopeOfWorksInput
    connect?: ProductAttributeUnitValuesWhereUniqueInput
  }

  export type ProjectProposalsCreateNestedOneWithoutScopeOfWorksInput = {
    create?: XOR<ProjectProposalsCreateWithoutScopeOfWorksInput, ProjectProposalsUncheckedCreateWithoutScopeOfWorksInput>
    connectOrCreate?: ProjectProposalsCreateOrConnectWithoutScopeOfWorksInput
    connect?: ProjectProposalsWhereUniqueInput
  }

  export type AreaOfWorksUpdateOneRequiredWithoutScopeOfWorksInput = {
    create?: XOR<AreaOfWorksCreateWithoutScopeOfWorksInput, AreaOfWorksUncheckedCreateWithoutScopeOfWorksInput>
    connectOrCreate?: AreaOfWorksCreateOrConnectWithoutScopeOfWorksInput
    upsert?: AreaOfWorksUpsertWithoutScopeOfWorksInput
    connect?: AreaOfWorksWhereUniqueInput
    update?: XOR<AreaOfWorksUpdateWithoutScopeOfWorksInput, AreaOfWorksUncheckedUpdateWithoutScopeOfWorksInput>
  }

  export type ProductAttributeUnitsUpdateOneRequiredWithoutScopeOfWorksInput = {
    create?: XOR<ProductAttributeUnitsCreateWithoutScopeOfWorksInput, ProductAttributeUnitsUncheckedCreateWithoutScopeOfWorksInput>
    connectOrCreate?: ProductAttributeUnitsCreateOrConnectWithoutScopeOfWorksInput
    upsert?: ProductAttributeUnitsUpsertWithoutScopeOfWorksInput
    connect?: ProductAttributeUnitsWhereUniqueInput
    update?: XOR<ProductAttributeUnitsUpdateWithoutScopeOfWorksInput, ProductAttributeUnitsUncheckedUpdateWithoutScopeOfWorksInput>
  }

  export type ProductAttributeUnitValuesUpdateOneRequiredWithoutScopeOfWorksInput = {
    create?: XOR<ProductAttributeUnitValuesCreateWithoutScopeOfWorksInput, ProductAttributeUnitValuesUncheckedCreateWithoutScopeOfWorksInput>
    connectOrCreate?: ProductAttributeUnitValuesCreateOrConnectWithoutScopeOfWorksInput
    upsert?: ProductAttributeUnitValuesUpsertWithoutScopeOfWorksInput
    connect?: ProductAttributeUnitValuesWhereUniqueInput
    update?: XOR<ProductAttributeUnitValuesUpdateWithoutScopeOfWorksInput, ProductAttributeUnitValuesUncheckedUpdateWithoutScopeOfWorksInput>
  }

  export type ProjectProposalsUpdateOneRequiredWithoutScopeOfWorksInput = {
    create?: XOR<ProjectProposalsCreateWithoutScopeOfWorksInput, ProjectProposalsUncheckedCreateWithoutScopeOfWorksInput>
    connectOrCreate?: ProjectProposalsCreateOrConnectWithoutScopeOfWorksInput
    upsert?: ProjectProposalsUpsertWithoutScopeOfWorksInput
    connect?: ProjectProposalsWhereUniqueInput
    update?: XOR<ProjectProposalsUpdateWithoutScopeOfWorksInput, ProjectProposalsUncheckedUpdateWithoutScopeOfWorksInput>
  }

  export type CountriesCreateNestedOneWithoutStatesInput = {
    create?: XOR<CountriesCreateWithoutStatesInput, CountriesUncheckedCreateWithoutStatesInput>
    connectOrCreate?: CountriesCreateOrConnectWithoutStatesInput
    connect?: CountriesWhereUniqueInput
  }

  export type CitiesCreateNestedManyWithoutStatesInput = {
    create?: XOR<Enumerable<CitiesCreateWithoutStatesInput>, Enumerable<CitiesUncheckedCreateWithoutStatesInput>>
    connectOrCreate?: Enumerable<CitiesCreateOrConnectWithoutStatesInput>
    connect?: Enumerable<CitiesWhereUniqueInput>
  }

  export type CitiesUncheckedCreateNestedManyWithoutStatesInput = {
    create?: XOR<Enumerable<CitiesCreateWithoutStatesInput>, Enumerable<CitiesUncheckedCreateWithoutStatesInput>>
    connectOrCreate?: Enumerable<CitiesCreateOrConnectWithoutStatesInput>
    connect?: Enumerable<CitiesWhereUniqueInput>
  }

  export type CountriesUpdateOneRequiredWithoutStatesInput = {
    create?: XOR<CountriesCreateWithoutStatesInput, CountriesUncheckedCreateWithoutStatesInput>
    connectOrCreate?: CountriesCreateOrConnectWithoutStatesInput
    upsert?: CountriesUpsertWithoutStatesInput
    connect?: CountriesWhereUniqueInput
    update?: XOR<CountriesUpdateWithoutStatesInput, CountriesUncheckedUpdateWithoutStatesInput>
  }

  export type CitiesUpdateManyWithoutStatesInput = {
    create?: XOR<Enumerable<CitiesCreateWithoutStatesInput>, Enumerable<CitiesUncheckedCreateWithoutStatesInput>>
    connectOrCreate?: Enumerable<CitiesCreateOrConnectWithoutStatesInput>
    upsert?: Enumerable<CitiesUpsertWithWhereUniqueWithoutStatesInput>
    connect?: Enumerable<CitiesWhereUniqueInput>
    set?: Enumerable<CitiesWhereUniqueInput>
    disconnect?: Enumerable<CitiesWhereUniqueInput>
    delete?: Enumerable<CitiesWhereUniqueInput>
    update?: Enumerable<CitiesUpdateWithWhereUniqueWithoutStatesInput>
    updateMany?: Enumerable<CitiesUpdateManyWithWhereWithoutStatesInput>
    deleteMany?: Enumerable<CitiesScalarWhereInput>
  }

  export type CitiesUncheckedUpdateManyWithoutStatesInput = {
    create?: XOR<Enumerable<CitiesCreateWithoutStatesInput>, Enumerable<CitiesUncheckedCreateWithoutStatesInput>>
    connectOrCreate?: Enumerable<CitiesCreateOrConnectWithoutStatesInput>
    upsert?: Enumerable<CitiesUpsertWithWhereUniqueWithoutStatesInput>
    connect?: Enumerable<CitiesWhereUniqueInput>
    set?: Enumerable<CitiesWhereUniqueInput>
    disconnect?: Enumerable<CitiesWhereUniqueInput>
    delete?: Enumerable<CitiesWhereUniqueInput>
    update?: Enumerable<CitiesUpdateWithWhereUniqueWithoutStatesInput>
    updateMany?: Enumerable<CitiesUpdateManyWithWhereWithoutStatesInput>
    deleteMany?: Enumerable<CitiesScalarWhereInput>
  }

  export type PropertyLevelsCreateNestedOneWithoutUnitLocationsInput = {
    create?: XOR<PropertyLevelsCreateWithoutUnitLocationsInput, PropertyLevelsUncheckedCreateWithoutUnitLocationsInput>
    connectOrCreate?: PropertyLevelsCreateOrConnectWithoutUnitLocationsInput
    connect?: PropertyLevelsWhereUniqueInput
  }

  export type PropertySubTypesCreateNestedOneWithoutUnitLocationsInput = {
    create?: XOR<PropertySubTypesCreateWithoutUnitLocationsInput, PropertySubTypesUncheckedCreateWithoutUnitLocationsInput>
    connectOrCreate?: PropertySubTypesCreateOrConnectWithoutUnitLocationsInput
    connect?: PropertySubTypesWhereUniqueInput
  }

  export type PropertyUnitsCreateNestedOneWithoutUnitLocationsInput = {
    create?: XOR<PropertyUnitsCreateWithoutUnitLocationsInput, PropertyUnitsUncheckedCreateWithoutUnitLocationsInput>
    connectOrCreate?: PropertyUnitsCreateOrConnectWithoutUnitLocationsInput
    connect?: PropertyUnitsWhereUniqueInput
  }

  export type AreaOfWorksCreateNestedManyWithoutUnitLocationsInput = {
    create?: XOR<Enumerable<AreaOfWorksCreateWithoutUnitLocationsInput>, Enumerable<AreaOfWorksUncheckedCreateWithoutUnitLocationsInput>>
    connectOrCreate?: Enumerable<AreaOfWorksCreateOrConnectWithoutUnitLocationsInput>
    connect?: Enumerable<AreaOfWorksWhereUniqueInput>
  }

  export type AreaOfWorksUncheckedCreateNestedManyWithoutUnitLocationsInput = {
    create?: XOR<Enumerable<AreaOfWorksCreateWithoutUnitLocationsInput>, Enumerable<AreaOfWorksUncheckedCreateWithoutUnitLocationsInput>>
    connectOrCreate?: Enumerable<AreaOfWorksCreateOrConnectWithoutUnitLocationsInput>
    connect?: Enumerable<AreaOfWorksWhereUniqueInput>
  }

  export type PropertyLevelsUpdateOneRequiredWithoutUnitLocationsInput = {
    create?: XOR<PropertyLevelsCreateWithoutUnitLocationsInput, PropertyLevelsUncheckedCreateWithoutUnitLocationsInput>
    connectOrCreate?: PropertyLevelsCreateOrConnectWithoutUnitLocationsInput
    upsert?: PropertyLevelsUpsertWithoutUnitLocationsInput
    connect?: PropertyLevelsWhereUniqueInput
    update?: XOR<PropertyLevelsUpdateWithoutUnitLocationsInput, PropertyLevelsUncheckedUpdateWithoutUnitLocationsInput>
  }

  export type PropertySubTypesUpdateOneRequiredWithoutUnitLocationsInput = {
    create?: XOR<PropertySubTypesCreateWithoutUnitLocationsInput, PropertySubTypesUncheckedCreateWithoutUnitLocationsInput>
    connectOrCreate?: PropertySubTypesCreateOrConnectWithoutUnitLocationsInput
    upsert?: PropertySubTypesUpsertWithoutUnitLocationsInput
    connect?: PropertySubTypesWhereUniqueInput
    update?: XOR<PropertySubTypesUpdateWithoutUnitLocationsInput, PropertySubTypesUncheckedUpdateWithoutUnitLocationsInput>
  }

  export type PropertyUnitsUpdateOneRequiredWithoutUnitLocationsInput = {
    create?: XOR<PropertyUnitsCreateWithoutUnitLocationsInput, PropertyUnitsUncheckedCreateWithoutUnitLocationsInput>
    connectOrCreate?: PropertyUnitsCreateOrConnectWithoutUnitLocationsInput
    upsert?: PropertyUnitsUpsertWithoutUnitLocationsInput
    connect?: PropertyUnitsWhereUniqueInput
    update?: XOR<PropertyUnitsUpdateWithoutUnitLocationsInput, PropertyUnitsUncheckedUpdateWithoutUnitLocationsInput>
  }

  export type AreaOfWorksUpdateManyWithoutUnitLocationsInput = {
    create?: XOR<Enumerable<AreaOfWorksCreateWithoutUnitLocationsInput>, Enumerable<AreaOfWorksUncheckedCreateWithoutUnitLocationsInput>>
    connectOrCreate?: Enumerable<AreaOfWorksCreateOrConnectWithoutUnitLocationsInput>
    upsert?: Enumerable<AreaOfWorksUpsertWithWhereUniqueWithoutUnitLocationsInput>
    connect?: Enumerable<AreaOfWorksWhereUniqueInput>
    set?: Enumerable<AreaOfWorksWhereUniqueInput>
    disconnect?: Enumerable<AreaOfWorksWhereUniqueInput>
    delete?: Enumerable<AreaOfWorksWhereUniqueInput>
    update?: Enumerable<AreaOfWorksUpdateWithWhereUniqueWithoutUnitLocationsInput>
    updateMany?: Enumerable<AreaOfWorksUpdateManyWithWhereWithoutUnitLocationsInput>
    deleteMany?: Enumerable<AreaOfWorksScalarWhereInput>
  }

  export type AreaOfWorksUncheckedUpdateManyWithoutUnitLocationsInput = {
    create?: XOR<Enumerable<AreaOfWorksCreateWithoutUnitLocationsInput>, Enumerable<AreaOfWorksUncheckedCreateWithoutUnitLocationsInput>>
    connectOrCreate?: Enumerable<AreaOfWorksCreateOrConnectWithoutUnitLocationsInput>
    upsert?: Enumerable<AreaOfWorksUpsertWithWhereUniqueWithoutUnitLocationsInput>
    connect?: Enumerable<AreaOfWorksWhereUniqueInput>
    set?: Enumerable<AreaOfWorksWhereUniqueInput>
    disconnect?: Enumerable<AreaOfWorksWhereUniqueInput>
    delete?: Enumerable<AreaOfWorksWhereUniqueInput>
    update?: Enumerable<AreaOfWorksUpdateWithWhereUniqueWithoutUnitLocationsInput>
    updateMany?: Enumerable<AreaOfWorksUpdateManyWithWhereWithoutUnitLocationsInput>
    deleteMany?: Enumerable<AreaOfWorksScalarWhereInput>
  }

  export type Backend_UsersCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<Backend_UsersCreateWithoutUsersInput>, Enumerable<Backend_UsersUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<Backend_UsersCreateOrConnectWithoutUsersInput>
    connect?: Enumerable<Backend_UsersWhereUniqueInput>
  }

  export type ContractorsCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<ContractorsCreateWithoutUsersInput>, Enumerable<ContractorsUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<ContractorsCreateOrConnectWithoutUsersInput>
    connect?: Enumerable<ContractorsWhereUniqueInput>
  }

  export type PropertyOwnersCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<PropertyOwnersCreateWithoutUsersInput>, Enumerable<PropertyOwnersUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<PropertyOwnersCreateOrConnectWithoutUsersInput>
    connect?: Enumerable<PropertyOwnersWhereUniqueInput>
  }

  export type Backend_UsersUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<Backend_UsersCreateWithoutUsersInput>, Enumerable<Backend_UsersUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<Backend_UsersCreateOrConnectWithoutUsersInput>
    connect?: Enumerable<Backend_UsersWhereUniqueInput>
  }

  export type ContractorsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<ContractorsCreateWithoutUsersInput>, Enumerable<ContractorsUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<ContractorsCreateOrConnectWithoutUsersInput>
    connect?: Enumerable<ContractorsWhereUniqueInput>
  }

  export type PropertyOwnersUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<PropertyOwnersCreateWithoutUsersInput>, Enumerable<PropertyOwnersUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<PropertyOwnersCreateOrConnectWithoutUsersInput>
    connect?: Enumerable<PropertyOwnersWhereUniqueInput>
  }

  export type Backend_UsersUpdateManyWithoutUsersInput = {
    create?: XOR<Enumerable<Backend_UsersCreateWithoutUsersInput>, Enumerable<Backend_UsersUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<Backend_UsersCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<Backend_UsersUpsertWithWhereUniqueWithoutUsersInput>
    connect?: Enumerable<Backend_UsersWhereUniqueInput>
    set?: Enumerable<Backend_UsersWhereUniqueInput>
    disconnect?: Enumerable<Backend_UsersWhereUniqueInput>
    delete?: Enumerable<Backend_UsersWhereUniqueInput>
    update?: Enumerable<Backend_UsersUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<Backend_UsersUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<Backend_UsersScalarWhereInput>
  }

  export type ContractorsUpdateManyWithoutUsersInput = {
    create?: XOR<Enumerable<ContractorsCreateWithoutUsersInput>, Enumerable<ContractorsUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<ContractorsCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<ContractorsUpsertWithWhereUniqueWithoutUsersInput>
    connect?: Enumerable<ContractorsWhereUniqueInput>
    set?: Enumerable<ContractorsWhereUniqueInput>
    disconnect?: Enumerable<ContractorsWhereUniqueInput>
    delete?: Enumerable<ContractorsWhereUniqueInput>
    update?: Enumerable<ContractorsUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<ContractorsUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<ContractorsScalarWhereInput>
  }

  export type PropertyOwnersUpdateManyWithoutUsersInput = {
    create?: XOR<Enumerable<PropertyOwnersCreateWithoutUsersInput>, Enumerable<PropertyOwnersUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<PropertyOwnersCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<PropertyOwnersUpsertWithWhereUniqueWithoutUsersInput>
    connect?: Enumerable<PropertyOwnersWhereUniqueInput>
    set?: Enumerable<PropertyOwnersWhereUniqueInput>
    disconnect?: Enumerable<PropertyOwnersWhereUniqueInput>
    delete?: Enumerable<PropertyOwnersWhereUniqueInput>
    update?: Enumerable<PropertyOwnersUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<PropertyOwnersUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<PropertyOwnersScalarWhereInput>
  }

  export type Backend_UsersUncheckedUpdateManyWithoutUsersInput = {
    create?: XOR<Enumerable<Backend_UsersCreateWithoutUsersInput>, Enumerable<Backend_UsersUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<Backend_UsersCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<Backend_UsersUpsertWithWhereUniqueWithoutUsersInput>
    connect?: Enumerable<Backend_UsersWhereUniqueInput>
    set?: Enumerable<Backend_UsersWhereUniqueInput>
    disconnect?: Enumerable<Backend_UsersWhereUniqueInput>
    delete?: Enumerable<Backend_UsersWhereUniqueInput>
    update?: Enumerable<Backend_UsersUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<Backend_UsersUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<Backend_UsersScalarWhereInput>
  }

  export type ContractorsUncheckedUpdateManyWithoutUsersInput = {
    create?: XOR<Enumerable<ContractorsCreateWithoutUsersInput>, Enumerable<ContractorsUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<ContractorsCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<ContractorsUpsertWithWhereUniqueWithoutUsersInput>
    connect?: Enumerable<ContractorsWhereUniqueInput>
    set?: Enumerable<ContractorsWhereUniqueInput>
    disconnect?: Enumerable<ContractorsWhereUniqueInput>
    delete?: Enumerable<ContractorsWhereUniqueInput>
    update?: Enumerable<ContractorsUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<ContractorsUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<ContractorsScalarWhereInput>
  }

  export type PropertyOwnersUncheckedUpdateManyWithoutUsersInput = {
    create?: XOR<Enumerable<PropertyOwnersCreateWithoutUsersInput>, Enumerable<PropertyOwnersUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<PropertyOwnersCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<PropertyOwnersUpsertWithWhereUniqueWithoutUsersInput>
    connect?: Enumerable<PropertyOwnersWhereUniqueInput>
    set?: Enumerable<PropertyOwnersWhereUniqueInput>
    disconnect?: Enumerable<PropertyOwnersWhereUniqueInput>
    delete?: Enumerable<PropertyOwnersWhereUniqueInput>
    update?: Enumerable<PropertyOwnersUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<PropertyOwnersUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<PropertyOwnersScalarWhereInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type ProjectProposalsCreateWithoutAreaOfWorksInput = {
    name?: string | null
    proposal_status?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    Projects: ProjectsCreateNestedOneWithoutProjectProposalsInput
    ScopeOfWorkPropertyUnits?: ScopeOfWorkPropertyUnitsCreateNestedManyWithoutProjectProposalsInput
    ScopeOfWorks?: ScopeOfWorksCreateNestedManyWithoutProjectProposalsInput
  }

  export type ProjectProposalsUncheckedCreateWithoutAreaOfWorksInput = {
    id?: number
    name?: string | null
    project_id: number
    proposal_status?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    ScopeOfWorkPropertyUnits?: ScopeOfWorkPropertyUnitsUncheckedCreateNestedManyWithoutProjectProposalsInput
    ScopeOfWorks?: ScopeOfWorksUncheckedCreateNestedManyWithoutProjectProposalsInput
  }

  export type ProjectProposalsCreateOrConnectWithoutAreaOfWorksInput = {
    where: ProjectProposalsWhereUniqueInput
    create: XOR<ProjectProposalsCreateWithoutAreaOfWorksInput, ProjectProposalsUncheckedCreateWithoutAreaOfWorksInput>
  }

  export type UnitLocationsCreateWithoutAreaOfWorksInput = {
    unit_name?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    PropertyLevels: PropertyLevelsCreateNestedOneWithoutUnitLocationsInput
    PropertySubTypes: PropertySubTypesCreateNestedOneWithoutUnitLocationsInput
    PropertyUnits: PropertyUnitsCreateNestedOneWithoutUnitLocationsInput
  }

  export type UnitLocationsUncheckedCreateWithoutAreaOfWorksInput = {
    id?: number
    unit_name?: string | null
    property_sub_type_id: number
    property_level_id: number
    property_unit_id: number
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
  }

  export type UnitLocationsCreateOrConnectWithoutAreaOfWorksInput = {
    where: UnitLocationsWhereUniqueInput
    create: XOR<UnitLocationsCreateWithoutAreaOfWorksInput, UnitLocationsUncheckedCreateWithoutAreaOfWorksInput>
  }

  export type ScopeOfWorkPropertyUnitsCreateWithoutAreaOfWorksInput = {
    value?: string | null
    attribute_custom_name?: string | null
    attribute_custom_value?: string | null
    attribute_custom_unit?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    ProjectProposals: ProjectProposalsCreateNestedOneWithoutScopeOfWorkPropertyUnitsInput
    PropertyUnitAttributes: PropertyUnitAttributesCreateNestedOneWithoutScopeOfWorkPropertyUnitsInput
  }

  export type ScopeOfWorkPropertyUnitsUncheckedCreateWithoutAreaOfWorksInput = {
    id?: number
    project_proposal_id: number
    property_unit_attribute_id: number
    value?: string | null
    attribute_custom_name?: string | null
    attribute_custom_value?: string | null
    attribute_custom_unit?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
  }

  export type ScopeOfWorkPropertyUnitsCreateOrConnectWithoutAreaOfWorksInput = {
    where: ScopeOfWorkPropertyUnitsWhereUniqueInput
    create: XOR<ScopeOfWorkPropertyUnitsCreateWithoutAreaOfWorksInput, ScopeOfWorkPropertyUnitsUncheckedCreateWithoutAreaOfWorksInput>
  }

  export type ScopeOfWorksCreateWithoutAreaOfWorksInput = {
    attribute_custom_name?: string | null
    attribute_custom_value?: string | null
    attribute_custom_unit?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    ProductAttributeUnits: ProductAttributeUnitsCreateNestedOneWithoutScopeOfWorksInput
    ProductAttributeUnitValues: ProductAttributeUnitValuesCreateNestedOneWithoutScopeOfWorksInput
    ProjectProposals: ProjectProposalsCreateNestedOneWithoutScopeOfWorksInput
  }

  export type ScopeOfWorksUncheckedCreateWithoutAreaOfWorksInput = {
    id?: number
    project_proposal_id: number
    product_attribute_unit_id: number
    product_attribute_unit_value_id: number
    attribute_custom_name?: string | null
    attribute_custom_value?: string | null
    attribute_custom_unit?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
  }

  export type ScopeOfWorksCreateOrConnectWithoutAreaOfWorksInput = {
    where: ScopeOfWorksWhereUniqueInput
    create: XOR<ScopeOfWorksCreateWithoutAreaOfWorksInput, ScopeOfWorksUncheckedCreateWithoutAreaOfWorksInput>
  }

  export type ProjectProposalsUpsertWithoutAreaOfWorksInput = {
    update: XOR<ProjectProposalsUpdateWithoutAreaOfWorksInput, ProjectProposalsUncheckedUpdateWithoutAreaOfWorksInput>
    create: XOR<ProjectProposalsCreateWithoutAreaOfWorksInput, ProjectProposalsUncheckedCreateWithoutAreaOfWorksInput>
  }

  export type ProjectProposalsUpdateWithoutAreaOfWorksInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    proposal_status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    Projects?: ProjectsUpdateOneRequiredWithoutProjectProposalsInput
    ScopeOfWorkPropertyUnits?: ScopeOfWorkPropertyUnitsUpdateManyWithoutProjectProposalsInput
    ScopeOfWorks?: ScopeOfWorksUpdateManyWithoutProjectProposalsInput
  }

  export type ProjectProposalsUncheckedUpdateWithoutAreaOfWorksInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    project_id?: IntFieldUpdateOperationsInput | number
    proposal_status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    ScopeOfWorkPropertyUnits?: ScopeOfWorkPropertyUnitsUncheckedUpdateManyWithoutProjectProposalsInput
    ScopeOfWorks?: ScopeOfWorksUncheckedUpdateManyWithoutProjectProposalsInput
  }

  export type UnitLocationsUpsertWithoutAreaOfWorksInput = {
    update: XOR<UnitLocationsUpdateWithoutAreaOfWorksInput, UnitLocationsUncheckedUpdateWithoutAreaOfWorksInput>
    create: XOR<UnitLocationsCreateWithoutAreaOfWorksInput, UnitLocationsUncheckedCreateWithoutAreaOfWorksInput>
  }

  export type UnitLocationsUpdateWithoutAreaOfWorksInput = {
    unit_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    PropertyLevels?: PropertyLevelsUpdateOneRequiredWithoutUnitLocationsInput
    PropertySubTypes?: PropertySubTypesUpdateOneRequiredWithoutUnitLocationsInput
    PropertyUnits?: PropertyUnitsUpdateOneRequiredWithoutUnitLocationsInput
  }

  export type UnitLocationsUncheckedUpdateWithoutAreaOfWorksInput = {
    id?: IntFieldUpdateOperationsInput | number
    unit_name?: NullableStringFieldUpdateOperationsInput | string | null
    property_sub_type_id?: IntFieldUpdateOperationsInput | number
    property_level_id?: IntFieldUpdateOperationsInput | number
    property_unit_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ScopeOfWorkPropertyUnitsUpsertWithWhereUniqueWithoutAreaOfWorksInput = {
    where: ScopeOfWorkPropertyUnitsWhereUniqueInput
    update: XOR<ScopeOfWorkPropertyUnitsUpdateWithoutAreaOfWorksInput, ScopeOfWorkPropertyUnitsUncheckedUpdateWithoutAreaOfWorksInput>
    create: XOR<ScopeOfWorkPropertyUnitsCreateWithoutAreaOfWorksInput, ScopeOfWorkPropertyUnitsUncheckedCreateWithoutAreaOfWorksInput>
  }

  export type ScopeOfWorkPropertyUnitsUpdateWithWhereUniqueWithoutAreaOfWorksInput = {
    where: ScopeOfWorkPropertyUnitsWhereUniqueInput
    data: XOR<ScopeOfWorkPropertyUnitsUpdateWithoutAreaOfWorksInput, ScopeOfWorkPropertyUnitsUncheckedUpdateWithoutAreaOfWorksInput>
  }

  export type ScopeOfWorkPropertyUnitsUpdateManyWithWhereWithoutAreaOfWorksInput = {
    where: ScopeOfWorkPropertyUnitsScalarWhereInput
    data: XOR<ScopeOfWorkPropertyUnitsUpdateManyMutationInput, ScopeOfWorkPropertyUnitsUncheckedUpdateManyWithoutScopeOfWorkPropertyUnitsInput>
  }

  export type ScopeOfWorkPropertyUnitsScalarWhereInput = {
    AND?: Enumerable<ScopeOfWorkPropertyUnitsScalarWhereInput>
    OR?: Enumerable<ScopeOfWorkPropertyUnitsScalarWhereInput>
    NOT?: Enumerable<ScopeOfWorkPropertyUnitsScalarWhereInput>
    id?: IntFilter | number
    project_proposal_id?: IntFilter | number
    area_of_work_id?: IntFilter | number
    property_unit_attribute_id?: IntFilter | number
    value?: StringNullableFilter | string | null
    attribute_custom_name?: StringNullableFilter | string | null
    attribute_custom_value?: StringNullableFilter | string | null
    attribute_custom_unit?: StringNullableFilter | string | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    created_by?: IntNullableFilter | number | null
    updated_by?: IntNullableFilter | number | null
  }

  export type ScopeOfWorksUpsertWithWhereUniqueWithoutAreaOfWorksInput = {
    where: ScopeOfWorksWhereUniqueInput
    update: XOR<ScopeOfWorksUpdateWithoutAreaOfWorksInput, ScopeOfWorksUncheckedUpdateWithoutAreaOfWorksInput>
    create: XOR<ScopeOfWorksCreateWithoutAreaOfWorksInput, ScopeOfWorksUncheckedCreateWithoutAreaOfWorksInput>
  }

  export type ScopeOfWorksUpdateWithWhereUniqueWithoutAreaOfWorksInput = {
    where: ScopeOfWorksWhereUniqueInput
    data: XOR<ScopeOfWorksUpdateWithoutAreaOfWorksInput, ScopeOfWorksUncheckedUpdateWithoutAreaOfWorksInput>
  }

  export type ScopeOfWorksUpdateManyWithWhereWithoutAreaOfWorksInput = {
    where: ScopeOfWorksScalarWhereInput
    data: XOR<ScopeOfWorksUpdateManyMutationInput, ScopeOfWorksUncheckedUpdateManyWithoutScopeOfWorksInput>
  }

  export type ScopeOfWorksScalarWhereInput = {
    AND?: Enumerable<ScopeOfWorksScalarWhereInput>
    OR?: Enumerable<ScopeOfWorksScalarWhereInput>
    NOT?: Enumerable<ScopeOfWorksScalarWhereInput>
    id?: IntFilter | number
    project_proposal_id?: IntFilter | number
    area_of_work_id?: IntFilter | number
    product_attribute_unit_id?: IntFilter | number
    product_attribute_unit_value_id?: IntFilter | number
    attribute_custom_name?: StringNullableFilter | string | null
    attribute_custom_value?: StringNullableFilter | string | null
    attribute_custom_unit?: StringNullableFilter | string | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    created_by?: IntNullableFilter | number | null
    updated_by?: IntNullableFilter | number | null
  }

  export type AttributesCreateWithoutOther_AttributesInput = {
    name?: string | null
    slug?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    Attributes?: AttributesCreateNestedOneWithoutOther_AttributesInput
    AttributeUnits?: AttributeUnitsCreateNestedManyWithoutAttributesInput
    ProductAttributeUnits?: ProductAttributeUnitsCreateNestedManyWithoutAttributesInput
    PropertyUnitAttributes?: PropertyUnitAttributesCreateNestedManyWithoutAttributesInput
  }

  export type AttributesUncheckedCreateWithoutOther_AttributesInput = {
    id?: number
    parent_id?: number | null
    name?: string | null
    slug?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    AttributeUnits?: AttributeUnitsUncheckedCreateNestedManyWithoutAttributesInput
    ProductAttributeUnits?: ProductAttributeUnitsUncheckedCreateNestedManyWithoutAttributesInput
    PropertyUnitAttributes?: PropertyUnitAttributesUncheckedCreateNestedManyWithoutAttributesInput
  }

  export type AttributesCreateOrConnectWithoutOther_AttributesInput = {
    where: AttributesWhereUniqueInput
    create: XOR<AttributesCreateWithoutOther_AttributesInput, AttributesUncheckedCreateWithoutOther_AttributesInput>
  }

  export type AttributesCreateWithoutAttributesInput = {
    name?: string | null
    slug?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    other_Attributes?: AttributesCreateNestedManyWithoutAttributesInput
    AttributeUnits?: AttributeUnitsCreateNestedManyWithoutAttributesInput
    ProductAttributeUnits?: ProductAttributeUnitsCreateNestedManyWithoutAttributesInput
    PropertyUnitAttributes?: PropertyUnitAttributesCreateNestedManyWithoutAttributesInput
  }

  export type AttributesUncheckedCreateWithoutAttributesInput = {
    id?: number
    name?: string | null
    slug?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    other_Attributes?: AttributesUncheckedCreateNestedManyWithoutAttributesInput
    AttributeUnits?: AttributeUnitsUncheckedCreateNestedManyWithoutAttributesInput
    ProductAttributeUnits?: ProductAttributeUnitsUncheckedCreateNestedManyWithoutAttributesInput
    PropertyUnitAttributes?: PropertyUnitAttributesUncheckedCreateNestedManyWithoutAttributesInput
  }

  export type AttributesCreateOrConnectWithoutAttributesInput = {
    where: AttributesWhereUniqueInput
    create: XOR<AttributesCreateWithoutAttributesInput, AttributesUncheckedCreateWithoutAttributesInput>
  }

  export type AttributeUnitsCreateWithoutAttributesInput = {
    unit_name?: string | null
    slug?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    ProductAttributeUnits?: ProductAttributeUnitsCreateNestedManyWithoutAttributeUnitsInput
    PropertyUnitAttributes?: PropertyUnitAttributesCreateNestedManyWithoutAttributeUnitsInput
  }

  export type AttributeUnitsUncheckedCreateWithoutAttributesInput = {
    id?: number
    unit_name?: string | null
    slug?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    ProductAttributeUnits?: ProductAttributeUnitsUncheckedCreateNestedManyWithoutAttributeUnitsInput
    PropertyUnitAttributes?: PropertyUnitAttributesUncheckedCreateNestedManyWithoutAttributeUnitsInput
  }

  export type AttributeUnitsCreateOrConnectWithoutAttributesInput = {
    where: AttributeUnitsWhereUniqueInput
    create: XOR<AttributeUnitsCreateWithoutAttributesInput, AttributeUnitsUncheckedCreateWithoutAttributesInput>
  }

  export type ProductAttributeUnitsCreateWithoutAttributesInput = {
    name?: string | null
    html_element_type?: string | null
    display_order?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    AttributeUnits: AttributeUnitsCreateNestedOneWithoutProductAttributeUnitsInput
    Products: ProductsCreateNestedOneWithoutProductAttributeUnitsInput
    ProductAttributeUnitValues?: ProductAttributeUnitValuesCreateNestedManyWithoutProductAttributeUnitsInput
    ScopeOfWorks?: ScopeOfWorksCreateNestedManyWithoutProductAttributeUnitsInput
  }

  export type ProductAttributeUnitsUncheckedCreateWithoutAttributesInput = {
    id?: number
    name?: string | null
    product_id: number
    attribute_unit_id: number
    html_element_type?: string | null
    display_order?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    ProductAttributeUnitValues?: ProductAttributeUnitValuesUncheckedCreateNestedManyWithoutProductAttributeUnitsInput
    ScopeOfWorks?: ScopeOfWorksUncheckedCreateNestedManyWithoutProductAttributeUnitsInput
  }

  export type ProductAttributeUnitsCreateOrConnectWithoutAttributesInput = {
    where: ProductAttributeUnitsWhereUniqueInput
    create: XOR<ProductAttributeUnitsCreateWithoutAttributesInput, ProductAttributeUnitsUncheckedCreateWithoutAttributesInput>
  }

  export type PropertyUnitAttributesCreateWithoutAttributesInput = {
    html_element_type?: string | null
    display_order?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    AttributeUnits: AttributeUnitsCreateNestedOneWithoutPropertyUnitAttributesInput
    PropertyUnits: PropertyUnitsCreateNestedOneWithoutPropertyUnitAttributesInput
    ScopeOfWorkPropertyUnits?: ScopeOfWorkPropertyUnitsCreateNestedManyWithoutPropertyUnitAttributesInput
  }

  export type PropertyUnitAttributesUncheckedCreateWithoutAttributesInput = {
    id?: number
    property_unit_id: number
    attribute_unit_id: number
    html_element_type?: string | null
    display_order?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    ScopeOfWorkPropertyUnits?: ScopeOfWorkPropertyUnitsUncheckedCreateNestedManyWithoutPropertyUnitAttributesInput
  }

  export type PropertyUnitAttributesCreateOrConnectWithoutAttributesInput = {
    where: PropertyUnitAttributesWhereUniqueInput
    create: XOR<PropertyUnitAttributesCreateWithoutAttributesInput, PropertyUnitAttributesUncheckedCreateWithoutAttributesInput>
  }

  export type AttributesUpsertWithoutOther_AttributesInput = {
    update: XOR<AttributesUpdateWithoutOther_AttributesInput, AttributesUncheckedUpdateWithoutOther_AttributesInput>
    create: XOR<AttributesCreateWithoutOther_AttributesInput, AttributesUncheckedCreateWithoutOther_AttributesInput>
  }

  export type AttributesUpdateWithoutOther_AttributesInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    Attributes?: AttributesUpdateOneWithoutOther_AttributesInput
    AttributeUnits?: AttributeUnitsUpdateManyWithoutAttributesInput
    ProductAttributeUnits?: ProductAttributeUnitsUpdateManyWithoutAttributesInput
    PropertyUnitAttributes?: PropertyUnitAttributesUpdateManyWithoutAttributesInput
  }

  export type AttributesUncheckedUpdateWithoutOther_AttributesInput = {
    id?: IntFieldUpdateOperationsInput | number
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    AttributeUnits?: AttributeUnitsUncheckedUpdateManyWithoutAttributesInput
    ProductAttributeUnits?: ProductAttributeUnitsUncheckedUpdateManyWithoutAttributesInput
    PropertyUnitAttributes?: PropertyUnitAttributesUncheckedUpdateManyWithoutAttributesInput
  }

  export type AttributesUpsertWithWhereUniqueWithoutAttributesInput = {
    where: AttributesWhereUniqueInput
    update: XOR<AttributesUpdateWithoutAttributesInput, AttributesUncheckedUpdateWithoutAttributesInput>
    create: XOR<AttributesCreateWithoutAttributesInput, AttributesUncheckedCreateWithoutAttributesInput>
  }

  export type AttributesUpdateWithWhereUniqueWithoutAttributesInput = {
    where: AttributesWhereUniqueInput
    data: XOR<AttributesUpdateWithoutAttributesInput, AttributesUncheckedUpdateWithoutAttributesInput>
  }

  export type AttributesUpdateManyWithWhereWithoutAttributesInput = {
    where: AttributesScalarWhereInput
    data: XOR<AttributesUpdateManyMutationInput, AttributesUncheckedUpdateManyWithoutOther_AttributesInput>
  }

  export type AttributesScalarWhereInput = {
    AND?: Enumerable<AttributesScalarWhereInput>
    OR?: Enumerable<AttributesScalarWhereInput>
    NOT?: Enumerable<AttributesScalarWhereInput>
    id?: IntFilter | number
    parent_id?: IntNullableFilter | number | null
    name?: StringNullableFilter | string | null
    slug?: StringNullableFilter | string | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    created_by?: IntNullableFilter | number | null
    updated_by?: IntNullableFilter | number | null
  }

  export type AttributeUnitsUpsertWithWhereUniqueWithoutAttributesInput = {
    where: AttributeUnitsWhereUniqueInput
    update: XOR<AttributeUnitsUpdateWithoutAttributesInput, AttributeUnitsUncheckedUpdateWithoutAttributesInput>
    create: XOR<AttributeUnitsCreateWithoutAttributesInput, AttributeUnitsUncheckedCreateWithoutAttributesInput>
  }

  export type AttributeUnitsUpdateWithWhereUniqueWithoutAttributesInput = {
    where: AttributeUnitsWhereUniqueInput
    data: XOR<AttributeUnitsUpdateWithoutAttributesInput, AttributeUnitsUncheckedUpdateWithoutAttributesInput>
  }

  export type AttributeUnitsUpdateManyWithWhereWithoutAttributesInput = {
    where: AttributeUnitsScalarWhereInput
    data: XOR<AttributeUnitsUpdateManyMutationInput, AttributeUnitsUncheckedUpdateManyWithoutAttributeUnitsInput>
  }

  export type AttributeUnitsScalarWhereInput = {
    AND?: Enumerable<AttributeUnitsScalarWhereInput>
    OR?: Enumerable<AttributeUnitsScalarWhereInput>
    NOT?: Enumerable<AttributeUnitsScalarWhereInput>
    id?: IntFilter | number
    attribute_parent_id?: IntNullableFilter | number | null
    unit_name?: StringNullableFilter | string | null
    slug?: StringNullableFilter | string | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    created_by?: IntNullableFilter | number | null
    updated_by?: IntNullableFilter | number | null
  }

  export type ProductAttributeUnitsUpsertWithWhereUniqueWithoutAttributesInput = {
    where: ProductAttributeUnitsWhereUniqueInput
    update: XOR<ProductAttributeUnitsUpdateWithoutAttributesInput, ProductAttributeUnitsUncheckedUpdateWithoutAttributesInput>
    create: XOR<ProductAttributeUnitsCreateWithoutAttributesInput, ProductAttributeUnitsUncheckedCreateWithoutAttributesInput>
  }

  export type ProductAttributeUnitsUpdateWithWhereUniqueWithoutAttributesInput = {
    where: ProductAttributeUnitsWhereUniqueInput
    data: XOR<ProductAttributeUnitsUpdateWithoutAttributesInput, ProductAttributeUnitsUncheckedUpdateWithoutAttributesInput>
  }

  export type ProductAttributeUnitsUpdateManyWithWhereWithoutAttributesInput = {
    where: ProductAttributeUnitsScalarWhereInput
    data: XOR<ProductAttributeUnitsUpdateManyMutationInput, ProductAttributeUnitsUncheckedUpdateManyWithoutProductAttributeUnitsInput>
  }

  export type ProductAttributeUnitsScalarWhereInput = {
    AND?: Enumerable<ProductAttributeUnitsScalarWhereInput>
    OR?: Enumerable<ProductAttributeUnitsScalarWhereInput>
    NOT?: Enumerable<ProductAttributeUnitsScalarWhereInput>
    id?: IntFilter | number
    name?: StringNullableFilter | string | null
    product_id?: IntFilter | number
    attribute_id?: IntFilter | number
    attribute_unit_id?: IntFilter | number
    html_element_type?: StringNullableFilter | string | null
    display_order?: IntNullableFilter | number | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    created_by?: IntNullableFilter | number | null
    updated_by?: IntNullableFilter | number | null
  }

  export type PropertyUnitAttributesUpsertWithWhereUniqueWithoutAttributesInput = {
    where: PropertyUnitAttributesWhereUniqueInput
    update: XOR<PropertyUnitAttributesUpdateWithoutAttributesInput, PropertyUnitAttributesUncheckedUpdateWithoutAttributesInput>
    create: XOR<PropertyUnitAttributesCreateWithoutAttributesInput, PropertyUnitAttributesUncheckedCreateWithoutAttributesInput>
  }

  export type PropertyUnitAttributesUpdateWithWhereUniqueWithoutAttributesInput = {
    where: PropertyUnitAttributesWhereUniqueInput
    data: XOR<PropertyUnitAttributesUpdateWithoutAttributesInput, PropertyUnitAttributesUncheckedUpdateWithoutAttributesInput>
  }

  export type PropertyUnitAttributesUpdateManyWithWhereWithoutAttributesInput = {
    where: PropertyUnitAttributesScalarWhereInput
    data: XOR<PropertyUnitAttributesUpdateManyMutationInput, PropertyUnitAttributesUncheckedUpdateManyWithoutPropertyUnitAttributesInput>
  }

  export type PropertyUnitAttributesScalarWhereInput = {
    AND?: Enumerable<PropertyUnitAttributesScalarWhereInput>
    OR?: Enumerable<PropertyUnitAttributesScalarWhereInput>
    NOT?: Enumerable<PropertyUnitAttributesScalarWhereInput>
    id?: IntFilter | number
    property_unit_id?: IntFilter | number
    attribute_id?: IntFilter | number
    attribute_unit_id?: IntFilter | number
    html_element_type?: StringNullableFilter | string | null
    display_order?: IntNullableFilter | number | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    created_by?: IntNullableFilter | number | null
    updated_by?: IntNullableFilter | number | null
  }

  export type AttributesCreateWithoutAttributeUnitsInput = {
    name?: string | null
    slug?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    Attributes?: AttributesCreateNestedOneWithoutOther_AttributesInput
    other_Attributes?: AttributesCreateNestedManyWithoutAttributesInput
    ProductAttributeUnits?: ProductAttributeUnitsCreateNestedManyWithoutAttributesInput
    PropertyUnitAttributes?: PropertyUnitAttributesCreateNestedManyWithoutAttributesInput
  }

  export type AttributesUncheckedCreateWithoutAttributeUnitsInput = {
    id?: number
    parent_id?: number | null
    name?: string | null
    slug?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    other_Attributes?: AttributesUncheckedCreateNestedManyWithoutAttributesInput
    ProductAttributeUnits?: ProductAttributeUnitsUncheckedCreateNestedManyWithoutAttributesInput
    PropertyUnitAttributes?: PropertyUnitAttributesUncheckedCreateNestedManyWithoutAttributesInput
  }

  export type AttributesCreateOrConnectWithoutAttributeUnitsInput = {
    where: AttributesWhereUniqueInput
    create: XOR<AttributesCreateWithoutAttributeUnitsInput, AttributesUncheckedCreateWithoutAttributeUnitsInput>
  }

  export type ProductAttributeUnitsCreateWithoutAttributeUnitsInput = {
    name?: string | null
    html_element_type?: string | null
    display_order?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    Attributes: AttributesCreateNestedOneWithoutProductAttributeUnitsInput
    Products: ProductsCreateNestedOneWithoutProductAttributeUnitsInput
    ProductAttributeUnitValues?: ProductAttributeUnitValuesCreateNestedManyWithoutProductAttributeUnitsInput
    ScopeOfWorks?: ScopeOfWorksCreateNestedManyWithoutProductAttributeUnitsInput
  }

  export type ProductAttributeUnitsUncheckedCreateWithoutAttributeUnitsInput = {
    id?: number
    name?: string | null
    product_id: number
    attribute_id: number
    html_element_type?: string | null
    display_order?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    ProductAttributeUnitValues?: ProductAttributeUnitValuesUncheckedCreateNestedManyWithoutProductAttributeUnitsInput
    ScopeOfWorks?: ScopeOfWorksUncheckedCreateNestedManyWithoutProductAttributeUnitsInput
  }

  export type ProductAttributeUnitsCreateOrConnectWithoutAttributeUnitsInput = {
    where: ProductAttributeUnitsWhereUniqueInput
    create: XOR<ProductAttributeUnitsCreateWithoutAttributeUnitsInput, ProductAttributeUnitsUncheckedCreateWithoutAttributeUnitsInput>
  }

  export type PropertyUnitAttributesCreateWithoutAttributeUnitsInput = {
    html_element_type?: string | null
    display_order?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    Attributes: AttributesCreateNestedOneWithoutPropertyUnitAttributesInput
    PropertyUnits: PropertyUnitsCreateNestedOneWithoutPropertyUnitAttributesInput
    ScopeOfWorkPropertyUnits?: ScopeOfWorkPropertyUnitsCreateNestedManyWithoutPropertyUnitAttributesInput
  }

  export type PropertyUnitAttributesUncheckedCreateWithoutAttributeUnitsInput = {
    id?: number
    property_unit_id: number
    attribute_id: number
    html_element_type?: string | null
    display_order?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    ScopeOfWorkPropertyUnits?: ScopeOfWorkPropertyUnitsUncheckedCreateNestedManyWithoutPropertyUnitAttributesInput
  }

  export type PropertyUnitAttributesCreateOrConnectWithoutAttributeUnitsInput = {
    where: PropertyUnitAttributesWhereUniqueInput
    create: XOR<PropertyUnitAttributesCreateWithoutAttributeUnitsInput, PropertyUnitAttributesUncheckedCreateWithoutAttributeUnitsInput>
  }

  export type AttributesUpsertWithoutAttributeUnitsInput = {
    update: XOR<AttributesUpdateWithoutAttributeUnitsInput, AttributesUncheckedUpdateWithoutAttributeUnitsInput>
    create: XOR<AttributesCreateWithoutAttributeUnitsInput, AttributesUncheckedCreateWithoutAttributeUnitsInput>
  }

  export type AttributesUpdateWithoutAttributeUnitsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    Attributes?: AttributesUpdateOneWithoutOther_AttributesInput
    other_Attributes?: AttributesUpdateManyWithoutAttributesInput
    ProductAttributeUnits?: ProductAttributeUnitsUpdateManyWithoutAttributesInput
    PropertyUnitAttributes?: PropertyUnitAttributesUpdateManyWithoutAttributesInput
  }

  export type AttributesUncheckedUpdateWithoutAttributeUnitsInput = {
    id?: IntFieldUpdateOperationsInput | number
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    other_Attributes?: AttributesUncheckedUpdateManyWithoutAttributesInput
    ProductAttributeUnits?: ProductAttributeUnitsUncheckedUpdateManyWithoutAttributesInput
    PropertyUnitAttributes?: PropertyUnitAttributesUncheckedUpdateManyWithoutAttributesInput
  }

  export type ProductAttributeUnitsUpsertWithWhereUniqueWithoutAttributeUnitsInput = {
    where: ProductAttributeUnitsWhereUniqueInput
    update: XOR<ProductAttributeUnitsUpdateWithoutAttributeUnitsInput, ProductAttributeUnitsUncheckedUpdateWithoutAttributeUnitsInput>
    create: XOR<ProductAttributeUnitsCreateWithoutAttributeUnitsInput, ProductAttributeUnitsUncheckedCreateWithoutAttributeUnitsInput>
  }

  export type ProductAttributeUnitsUpdateWithWhereUniqueWithoutAttributeUnitsInput = {
    where: ProductAttributeUnitsWhereUniqueInput
    data: XOR<ProductAttributeUnitsUpdateWithoutAttributeUnitsInput, ProductAttributeUnitsUncheckedUpdateWithoutAttributeUnitsInput>
  }

  export type ProductAttributeUnitsUpdateManyWithWhereWithoutAttributeUnitsInput = {
    where: ProductAttributeUnitsScalarWhereInput
    data: XOR<ProductAttributeUnitsUpdateManyMutationInput, ProductAttributeUnitsUncheckedUpdateManyWithoutProductAttributeUnitsInput>
  }

  export type PropertyUnitAttributesUpsertWithWhereUniqueWithoutAttributeUnitsInput = {
    where: PropertyUnitAttributesWhereUniqueInput
    update: XOR<PropertyUnitAttributesUpdateWithoutAttributeUnitsInput, PropertyUnitAttributesUncheckedUpdateWithoutAttributeUnitsInput>
    create: XOR<PropertyUnitAttributesCreateWithoutAttributeUnitsInput, PropertyUnitAttributesUncheckedCreateWithoutAttributeUnitsInput>
  }

  export type PropertyUnitAttributesUpdateWithWhereUniqueWithoutAttributeUnitsInput = {
    where: PropertyUnitAttributesWhereUniqueInput
    data: XOR<PropertyUnitAttributesUpdateWithoutAttributeUnitsInput, PropertyUnitAttributesUncheckedUpdateWithoutAttributeUnitsInput>
  }

  export type PropertyUnitAttributesUpdateManyWithWhereWithoutAttributeUnitsInput = {
    where: PropertyUnitAttributesScalarWhereInput
    data: XOR<PropertyUnitAttributesUpdateManyMutationInput, PropertyUnitAttributesUncheckedUpdateManyWithoutPropertyUnitAttributesInput>
  }

  export type UsersCreateWithoutBackend_UsersInput = {
    user_type: string
    email: string
    status?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    username?: string | null
    email_verified?: boolean
    name?: string | null
    Contractors?: ContractorsCreateNestedManyWithoutUsersInput
    PropertyOwners?: PropertyOwnersCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutBackend_UsersInput = {
    id?: number
    user_type: string
    email: string
    status?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    username?: string | null
    email_verified?: boolean
    name?: string | null
    Contractors?: ContractorsUncheckedCreateNestedManyWithoutUsersInput
    PropertyOwners?: PropertyOwnersUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutBackend_UsersInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutBackend_UsersInput, UsersUncheckedCreateWithoutBackend_UsersInput>
  }

  export type UsersUpsertWithoutBackend_UsersInput = {
    update: XOR<UsersUpdateWithoutBackend_UsersInput, UsersUncheckedUpdateWithoutBackend_UsersInput>
    create: XOR<UsersCreateWithoutBackend_UsersInput, UsersUncheckedCreateWithoutBackend_UsersInput>
  }

  export type UsersUpdateWithoutBackend_UsersInput = {
    user_type?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    name?: NullableStringFieldUpdateOperationsInput | string | null
    Contractors?: ContractorsUpdateManyWithoutUsersInput
    PropertyOwners?: PropertyOwnersUpdateManyWithoutUsersInput
  }

  export type UsersUncheckedUpdateWithoutBackend_UsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_type?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    name?: NullableStringFieldUpdateOperationsInput | string | null
    Contractors?: ContractorsUncheckedUpdateManyWithoutUsersInput
    PropertyOwners?: PropertyOwnersUncheckedUpdateManyWithoutUsersInput
  }

  export type StatesCreateWithoutCitiesInput = {
    name?: string | null
    state_code: string
    status?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    Countries: CountriesCreateNestedOneWithoutStatesInput
  }

  export type StatesUncheckedCreateWithoutCitiesInput = {
    id?: number
    country_id: number
    name?: string | null
    state_code: string
    status?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
  }

  export type StatesCreateOrConnectWithoutCitiesInput = {
    where: StatesWhereUniqueInput
    create: XOR<StatesCreateWithoutCitiesInput, StatesUncheckedCreateWithoutCitiesInput>
  }

  export type Property_AddressesCreateWithoutCitiesInput = {
    street?: string | null
    postal_code?: string | null
    construction_type?: string | null
    withBasement?: boolean
    storyId?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    PropertyOwners: PropertyOwnersCreateNestedOneWithoutProperty_AddressesInput
    PropertySubTypes: PropertySubTypesCreateNestedOneWithoutProperty_AddressesInput
    Projects?: ProjectsCreateNestedManyWithoutProperty_AddressesInput
  }

  export type Property_AddressesUncheckedCreateWithoutCitiesInput = {
    id?: number
    street?: string | null
    property_owner_id: number
    property_sub_type_id: number
    postal_code?: string | null
    construction_type?: string | null
    withBasement?: boolean
    storyId?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    Projects?: ProjectsUncheckedCreateNestedManyWithoutProperty_AddressesInput
  }

  export type Property_AddressesCreateOrConnectWithoutCitiesInput = {
    where: Property_AddressesWhereUniqueInput
    create: XOR<Property_AddressesCreateWithoutCitiesInput, Property_AddressesUncheckedCreateWithoutCitiesInput>
  }

  export type StatesUpsertWithoutCitiesInput = {
    update: XOR<StatesUpdateWithoutCitiesInput, StatesUncheckedUpdateWithoutCitiesInput>
    create: XOR<StatesCreateWithoutCitiesInput, StatesUncheckedCreateWithoutCitiesInput>
  }

  export type StatesUpdateWithoutCitiesInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    state_code?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    Countries?: CountriesUpdateOneRequiredWithoutStatesInput
  }

  export type StatesUncheckedUpdateWithoutCitiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    country_id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    state_code?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type Property_AddressesUpsertWithWhereUniqueWithoutCitiesInput = {
    where: Property_AddressesWhereUniqueInput
    update: XOR<Property_AddressesUpdateWithoutCitiesInput, Property_AddressesUncheckedUpdateWithoutCitiesInput>
    create: XOR<Property_AddressesCreateWithoutCitiesInput, Property_AddressesUncheckedCreateWithoutCitiesInput>
  }

  export type Property_AddressesUpdateWithWhereUniqueWithoutCitiesInput = {
    where: Property_AddressesWhereUniqueInput
    data: XOR<Property_AddressesUpdateWithoutCitiesInput, Property_AddressesUncheckedUpdateWithoutCitiesInput>
  }

  export type Property_AddressesUpdateManyWithWhereWithoutCitiesInput = {
    where: Property_AddressesScalarWhereInput
    data: XOR<Property_AddressesUpdateManyMutationInput, Property_AddressesUncheckedUpdateManyWithoutProperty_AddressesInput>
  }

  export type Property_AddressesScalarWhereInput = {
    AND?: Enumerable<Property_AddressesScalarWhereInput>
    OR?: Enumerable<Property_AddressesScalarWhereInput>
    NOT?: Enumerable<Property_AddressesScalarWhereInput>
    id?: IntFilter | number
    street?: StringNullableFilter | string | null
    property_owner_id?: IntFilter | number
    city_id?: IntFilter | number
    property_sub_type_id?: IntFilter | number
    postal_code?: StringNullableFilter | string | null
    construction_type?: StringNullableFilter | string | null
    withBasement?: BoolFilter | boolean
    storyId?: IntNullableFilter | number | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    created_by?: IntNullableFilter | number | null
    updated_by?: IntNullableFilter | number | null
  }

  export type UsersCreateWithoutContractorsInput = {
    user_type: string
    email: string
    status?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    username?: string | null
    email_verified?: boolean
    name?: string | null
    Backend_Users?: Backend_UsersCreateNestedManyWithoutUsersInput
    PropertyOwners?: PropertyOwnersCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutContractorsInput = {
    id?: number
    user_type: string
    email: string
    status?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    username?: string | null
    email_verified?: boolean
    name?: string | null
    Backend_Users?: Backend_UsersUncheckedCreateNestedManyWithoutUsersInput
    PropertyOwners?: PropertyOwnersUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutContractorsInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutContractorsInput, UsersUncheckedCreateWithoutContractorsInput>
  }

  export type UsersUpsertWithoutContractorsInput = {
    update: XOR<UsersUpdateWithoutContractorsInput, UsersUncheckedUpdateWithoutContractorsInput>
    create: XOR<UsersCreateWithoutContractorsInput, UsersUncheckedCreateWithoutContractorsInput>
  }

  export type UsersUpdateWithoutContractorsInput = {
    user_type?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    name?: NullableStringFieldUpdateOperationsInput | string | null
    Backend_Users?: Backend_UsersUpdateManyWithoutUsersInput
    PropertyOwners?: PropertyOwnersUpdateManyWithoutUsersInput
  }

  export type UsersUncheckedUpdateWithoutContractorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_type?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    name?: NullableStringFieldUpdateOperationsInput | string | null
    Backend_Users?: Backend_UsersUncheckedUpdateManyWithoutUsersInput
    PropertyOwners?: PropertyOwnersUncheckedUpdateManyWithoutUsersInput
  }

  export type StatesCreateWithoutCountriesInput = {
    name?: string | null
    state_code: string
    status?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    Cities?: CitiesCreateNestedManyWithoutStatesInput
  }

  export type StatesUncheckedCreateWithoutCountriesInput = {
    id?: number
    name?: string | null
    state_code: string
    status?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    Cities?: CitiesUncheckedCreateNestedManyWithoutStatesInput
  }

  export type StatesCreateOrConnectWithoutCountriesInput = {
    where: StatesWhereUniqueInput
    create: XOR<StatesCreateWithoutCountriesInput, StatesUncheckedCreateWithoutCountriesInput>
  }

  export type StatesUpsertWithWhereUniqueWithoutCountriesInput = {
    where: StatesWhereUniqueInput
    update: XOR<StatesUpdateWithoutCountriesInput, StatesUncheckedUpdateWithoutCountriesInput>
    create: XOR<StatesCreateWithoutCountriesInput, StatesUncheckedCreateWithoutCountriesInput>
  }

  export type StatesUpdateWithWhereUniqueWithoutCountriesInput = {
    where: StatesWhereUniqueInput
    data: XOR<StatesUpdateWithoutCountriesInput, StatesUncheckedUpdateWithoutCountriesInput>
  }

  export type StatesUpdateManyWithWhereWithoutCountriesInput = {
    where: StatesScalarWhereInput
    data: XOR<StatesUpdateManyMutationInput, StatesUncheckedUpdateManyWithoutStatesInput>
  }

  export type StatesScalarWhereInput = {
    AND?: Enumerable<StatesScalarWhereInput>
    OR?: Enumerable<StatesScalarWhereInput>
    NOT?: Enumerable<StatesScalarWhereInput>
    id?: IntFilter | number
    country_id?: IntFilter | number
    name?: StringNullableFilter | string | null
    state_code?: StringFilter | string
    status?: BoolFilter | boolean
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    created_by?: IntNullableFilter | number | null
    updated_by?: IntNullableFilter | number | null
  }

  export type AttributesCreateWithoutProductAttributeUnitsInput = {
    name?: string | null
    slug?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    Attributes?: AttributesCreateNestedOneWithoutOther_AttributesInput
    other_Attributes?: AttributesCreateNestedManyWithoutAttributesInput
    AttributeUnits?: AttributeUnitsCreateNestedManyWithoutAttributesInput
    PropertyUnitAttributes?: PropertyUnitAttributesCreateNestedManyWithoutAttributesInput
  }

  export type AttributesUncheckedCreateWithoutProductAttributeUnitsInput = {
    id?: number
    parent_id?: number | null
    name?: string | null
    slug?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    other_Attributes?: AttributesUncheckedCreateNestedManyWithoutAttributesInput
    AttributeUnits?: AttributeUnitsUncheckedCreateNestedManyWithoutAttributesInput
    PropertyUnitAttributes?: PropertyUnitAttributesUncheckedCreateNestedManyWithoutAttributesInput
  }

  export type AttributesCreateOrConnectWithoutProductAttributeUnitsInput = {
    where: AttributesWhereUniqueInput
    create: XOR<AttributesCreateWithoutProductAttributeUnitsInput, AttributesUncheckedCreateWithoutProductAttributeUnitsInput>
  }

  export type AttributeUnitsCreateWithoutProductAttributeUnitsInput = {
    unit_name?: string | null
    slug?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    Attributes?: AttributesCreateNestedOneWithoutAttributeUnitsInput
    PropertyUnitAttributes?: PropertyUnitAttributesCreateNestedManyWithoutAttributeUnitsInput
  }

  export type AttributeUnitsUncheckedCreateWithoutProductAttributeUnitsInput = {
    id?: number
    attribute_parent_id?: number | null
    unit_name?: string | null
    slug?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    PropertyUnitAttributes?: PropertyUnitAttributesUncheckedCreateNestedManyWithoutAttributeUnitsInput
  }

  export type AttributeUnitsCreateOrConnectWithoutProductAttributeUnitsInput = {
    where: AttributeUnitsWhereUniqueInput
    create: XOR<AttributeUnitsCreateWithoutProductAttributeUnitsInput, AttributeUnitsUncheckedCreateWithoutProductAttributeUnitsInput>
  }

  export type ProductsCreateWithoutProductAttributeUnitsInput = {
    name?: string | null
    slug?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    Products?: ProductsCreateNestedOneWithoutOther_ProductsInput
    ProductPropertyUnits?: ProductPropertyUnitsCreateNestedManyWithoutProductsInput
    other_Products?: ProductsCreateNestedManyWithoutProductsInput
    PropertyUnitProductCategoryProducts?: PropertyUnitProductCategoryProductsCreateNestedManyWithoutProductsInput
  }

  export type ProductsUncheckedCreateWithoutProductAttributeUnitsInput = {
    id?: number
    parent_id?: number | null
    name?: string | null
    slug?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    ProductPropertyUnits?: ProductPropertyUnitsUncheckedCreateNestedManyWithoutProductsInput
    other_Products?: ProductsUncheckedCreateNestedManyWithoutProductsInput
    PropertyUnitProductCategoryProducts?: PropertyUnitProductCategoryProductsUncheckedCreateNestedManyWithoutProductsInput
  }

  export type ProductsCreateOrConnectWithoutProductAttributeUnitsInput = {
    where: ProductsWhereUniqueInput
    create: XOR<ProductsCreateWithoutProductAttributeUnitsInput, ProductsUncheckedCreateWithoutProductAttributeUnitsInput>
  }

  export type ProductAttributeUnitValuesCreateWithoutProductAttributeUnitsInput = {
    value?: string | null
    slug?: string | null
    custom?: boolean
    custom_html_element_type?: string | null
    is_default?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    ScopeOfWorks?: ScopeOfWorksCreateNestedManyWithoutProductAttributeUnitValuesInput
  }

  export type ProductAttributeUnitValuesUncheckedCreateWithoutProductAttributeUnitsInput = {
    id?: number
    value?: string | null
    slug?: string | null
    custom?: boolean
    custom_html_element_type?: string | null
    is_default?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    ScopeOfWorks?: ScopeOfWorksUncheckedCreateNestedManyWithoutProductAttributeUnitValuesInput
  }

  export type ProductAttributeUnitValuesCreateOrConnectWithoutProductAttributeUnitsInput = {
    where: ProductAttributeUnitValuesWhereUniqueInput
    create: XOR<ProductAttributeUnitValuesCreateWithoutProductAttributeUnitsInput, ProductAttributeUnitValuesUncheckedCreateWithoutProductAttributeUnitsInput>
  }

  export type ScopeOfWorksCreateWithoutProductAttributeUnitsInput = {
    attribute_custom_name?: string | null
    attribute_custom_value?: string | null
    attribute_custom_unit?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    AreaOfWorks: AreaOfWorksCreateNestedOneWithoutScopeOfWorksInput
    ProductAttributeUnitValues: ProductAttributeUnitValuesCreateNestedOneWithoutScopeOfWorksInput
    ProjectProposals: ProjectProposalsCreateNestedOneWithoutScopeOfWorksInput
  }

  export type ScopeOfWorksUncheckedCreateWithoutProductAttributeUnitsInput = {
    id?: number
    project_proposal_id: number
    area_of_work_id: number
    product_attribute_unit_value_id: number
    attribute_custom_name?: string | null
    attribute_custom_value?: string | null
    attribute_custom_unit?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
  }

  export type ScopeOfWorksCreateOrConnectWithoutProductAttributeUnitsInput = {
    where: ScopeOfWorksWhereUniqueInput
    create: XOR<ScopeOfWorksCreateWithoutProductAttributeUnitsInput, ScopeOfWorksUncheckedCreateWithoutProductAttributeUnitsInput>
  }

  export type AttributesUpsertWithoutProductAttributeUnitsInput = {
    update: XOR<AttributesUpdateWithoutProductAttributeUnitsInput, AttributesUncheckedUpdateWithoutProductAttributeUnitsInput>
    create: XOR<AttributesCreateWithoutProductAttributeUnitsInput, AttributesUncheckedCreateWithoutProductAttributeUnitsInput>
  }

  export type AttributesUpdateWithoutProductAttributeUnitsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    Attributes?: AttributesUpdateOneWithoutOther_AttributesInput
    other_Attributes?: AttributesUpdateManyWithoutAttributesInput
    AttributeUnits?: AttributeUnitsUpdateManyWithoutAttributesInput
    PropertyUnitAttributes?: PropertyUnitAttributesUpdateManyWithoutAttributesInput
  }

  export type AttributesUncheckedUpdateWithoutProductAttributeUnitsInput = {
    id?: IntFieldUpdateOperationsInput | number
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    other_Attributes?: AttributesUncheckedUpdateManyWithoutAttributesInput
    AttributeUnits?: AttributeUnitsUncheckedUpdateManyWithoutAttributesInput
    PropertyUnitAttributes?: PropertyUnitAttributesUncheckedUpdateManyWithoutAttributesInput
  }

  export type AttributeUnitsUpsertWithoutProductAttributeUnitsInput = {
    update: XOR<AttributeUnitsUpdateWithoutProductAttributeUnitsInput, AttributeUnitsUncheckedUpdateWithoutProductAttributeUnitsInput>
    create: XOR<AttributeUnitsCreateWithoutProductAttributeUnitsInput, AttributeUnitsUncheckedCreateWithoutProductAttributeUnitsInput>
  }

  export type AttributeUnitsUpdateWithoutProductAttributeUnitsInput = {
    unit_name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    Attributes?: AttributesUpdateOneWithoutAttributeUnitsInput
    PropertyUnitAttributes?: PropertyUnitAttributesUpdateManyWithoutAttributeUnitsInput
  }

  export type AttributeUnitsUncheckedUpdateWithoutProductAttributeUnitsInput = {
    id?: IntFieldUpdateOperationsInput | number
    attribute_parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    unit_name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    PropertyUnitAttributes?: PropertyUnitAttributesUncheckedUpdateManyWithoutAttributeUnitsInput
  }

  export type ProductsUpsertWithoutProductAttributeUnitsInput = {
    update: XOR<ProductsUpdateWithoutProductAttributeUnitsInput, ProductsUncheckedUpdateWithoutProductAttributeUnitsInput>
    create: XOR<ProductsCreateWithoutProductAttributeUnitsInput, ProductsUncheckedCreateWithoutProductAttributeUnitsInput>
  }

  export type ProductsUpdateWithoutProductAttributeUnitsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    Products?: ProductsUpdateOneWithoutOther_ProductsInput
    ProductPropertyUnits?: ProductPropertyUnitsUpdateManyWithoutProductsInput
    other_Products?: ProductsUpdateManyWithoutProductsInput
    PropertyUnitProductCategoryProducts?: PropertyUnitProductCategoryProductsUpdateManyWithoutProductsInput
  }

  export type ProductsUncheckedUpdateWithoutProductAttributeUnitsInput = {
    id?: IntFieldUpdateOperationsInput | number
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    ProductPropertyUnits?: ProductPropertyUnitsUncheckedUpdateManyWithoutProductsInput
    other_Products?: ProductsUncheckedUpdateManyWithoutProductsInput
    PropertyUnitProductCategoryProducts?: PropertyUnitProductCategoryProductsUncheckedUpdateManyWithoutProductsInput
  }

  export type ProductAttributeUnitValuesUpsertWithWhereUniqueWithoutProductAttributeUnitsInput = {
    where: ProductAttributeUnitValuesWhereUniqueInput
    update: XOR<ProductAttributeUnitValuesUpdateWithoutProductAttributeUnitsInput, ProductAttributeUnitValuesUncheckedUpdateWithoutProductAttributeUnitsInput>
    create: XOR<ProductAttributeUnitValuesCreateWithoutProductAttributeUnitsInput, ProductAttributeUnitValuesUncheckedCreateWithoutProductAttributeUnitsInput>
  }

  export type ProductAttributeUnitValuesUpdateWithWhereUniqueWithoutProductAttributeUnitsInput = {
    where: ProductAttributeUnitValuesWhereUniqueInput
    data: XOR<ProductAttributeUnitValuesUpdateWithoutProductAttributeUnitsInput, ProductAttributeUnitValuesUncheckedUpdateWithoutProductAttributeUnitsInput>
  }

  export type ProductAttributeUnitValuesUpdateManyWithWhereWithoutProductAttributeUnitsInput = {
    where: ProductAttributeUnitValuesScalarWhereInput
    data: XOR<ProductAttributeUnitValuesUpdateManyMutationInput, ProductAttributeUnitValuesUncheckedUpdateManyWithoutProductAttributeUnitValuesInput>
  }

  export type ProductAttributeUnitValuesScalarWhereInput = {
    AND?: Enumerable<ProductAttributeUnitValuesScalarWhereInput>
    OR?: Enumerable<ProductAttributeUnitValuesScalarWhereInput>
    NOT?: Enumerable<ProductAttributeUnitValuesScalarWhereInput>
    id?: IntFilter | number
    value?: StringNullableFilter | string | null
    slug?: StringNullableFilter | string | null
    product_attribute_unit_id?: IntFilter | number
    custom?: BoolFilter | boolean
    custom_html_element_type?: StringNullableFilter | string | null
    is_default?: BoolFilter | boolean
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    created_by?: IntNullableFilter | number | null
    updated_by?: IntNullableFilter | number | null
  }

  export type ScopeOfWorksUpsertWithWhereUniqueWithoutProductAttributeUnitsInput = {
    where: ScopeOfWorksWhereUniqueInput
    update: XOR<ScopeOfWorksUpdateWithoutProductAttributeUnitsInput, ScopeOfWorksUncheckedUpdateWithoutProductAttributeUnitsInput>
    create: XOR<ScopeOfWorksCreateWithoutProductAttributeUnitsInput, ScopeOfWorksUncheckedCreateWithoutProductAttributeUnitsInput>
  }

  export type ScopeOfWorksUpdateWithWhereUniqueWithoutProductAttributeUnitsInput = {
    where: ScopeOfWorksWhereUniqueInput
    data: XOR<ScopeOfWorksUpdateWithoutProductAttributeUnitsInput, ScopeOfWorksUncheckedUpdateWithoutProductAttributeUnitsInput>
  }

  export type ScopeOfWorksUpdateManyWithWhereWithoutProductAttributeUnitsInput = {
    where: ScopeOfWorksScalarWhereInput
    data: XOR<ScopeOfWorksUpdateManyMutationInput, ScopeOfWorksUncheckedUpdateManyWithoutScopeOfWorksInput>
  }

  export type ProductAttributeUnitsCreateWithoutProductAttributeUnitValuesInput = {
    name?: string | null
    html_element_type?: string | null
    display_order?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    Attributes: AttributesCreateNestedOneWithoutProductAttributeUnitsInput
    AttributeUnits: AttributeUnitsCreateNestedOneWithoutProductAttributeUnitsInput
    Products: ProductsCreateNestedOneWithoutProductAttributeUnitsInput
    ScopeOfWorks?: ScopeOfWorksCreateNestedManyWithoutProductAttributeUnitsInput
  }

  export type ProductAttributeUnitsUncheckedCreateWithoutProductAttributeUnitValuesInput = {
    id?: number
    name?: string | null
    product_id: number
    attribute_id: number
    attribute_unit_id: number
    html_element_type?: string | null
    display_order?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    ScopeOfWorks?: ScopeOfWorksUncheckedCreateNestedManyWithoutProductAttributeUnitsInput
  }

  export type ProductAttributeUnitsCreateOrConnectWithoutProductAttributeUnitValuesInput = {
    where: ProductAttributeUnitsWhereUniqueInput
    create: XOR<ProductAttributeUnitsCreateWithoutProductAttributeUnitValuesInput, ProductAttributeUnitsUncheckedCreateWithoutProductAttributeUnitValuesInput>
  }

  export type ScopeOfWorksCreateWithoutProductAttributeUnitValuesInput = {
    attribute_custom_name?: string | null
    attribute_custom_value?: string | null
    attribute_custom_unit?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    AreaOfWorks: AreaOfWorksCreateNestedOneWithoutScopeOfWorksInput
    ProductAttributeUnits: ProductAttributeUnitsCreateNestedOneWithoutScopeOfWorksInput
    ProjectProposals: ProjectProposalsCreateNestedOneWithoutScopeOfWorksInput
  }

  export type ScopeOfWorksUncheckedCreateWithoutProductAttributeUnitValuesInput = {
    id?: number
    project_proposal_id: number
    area_of_work_id: number
    product_attribute_unit_id: number
    attribute_custom_name?: string | null
    attribute_custom_value?: string | null
    attribute_custom_unit?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
  }

  export type ScopeOfWorksCreateOrConnectWithoutProductAttributeUnitValuesInput = {
    where: ScopeOfWorksWhereUniqueInput
    create: XOR<ScopeOfWorksCreateWithoutProductAttributeUnitValuesInput, ScopeOfWorksUncheckedCreateWithoutProductAttributeUnitValuesInput>
  }

  export type ProductAttributeUnitsUpsertWithoutProductAttributeUnitValuesInput = {
    update: XOR<ProductAttributeUnitsUpdateWithoutProductAttributeUnitValuesInput, ProductAttributeUnitsUncheckedUpdateWithoutProductAttributeUnitValuesInput>
    create: XOR<ProductAttributeUnitsCreateWithoutProductAttributeUnitValuesInput, ProductAttributeUnitsUncheckedCreateWithoutProductAttributeUnitValuesInput>
  }

  export type ProductAttributeUnitsUpdateWithoutProductAttributeUnitValuesInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    html_element_type?: NullableStringFieldUpdateOperationsInput | string | null
    display_order?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    Attributes?: AttributesUpdateOneRequiredWithoutProductAttributeUnitsInput
    AttributeUnits?: AttributeUnitsUpdateOneRequiredWithoutProductAttributeUnitsInput
    Products?: ProductsUpdateOneRequiredWithoutProductAttributeUnitsInput
    ScopeOfWorks?: ScopeOfWorksUpdateManyWithoutProductAttributeUnitsInput
  }

  export type ProductAttributeUnitsUncheckedUpdateWithoutProductAttributeUnitValuesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    product_id?: IntFieldUpdateOperationsInput | number
    attribute_id?: IntFieldUpdateOperationsInput | number
    attribute_unit_id?: IntFieldUpdateOperationsInput | number
    html_element_type?: NullableStringFieldUpdateOperationsInput | string | null
    display_order?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    ScopeOfWorks?: ScopeOfWorksUncheckedUpdateManyWithoutProductAttributeUnitsInput
  }

  export type ScopeOfWorksUpsertWithWhereUniqueWithoutProductAttributeUnitValuesInput = {
    where: ScopeOfWorksWhereUniqueInput
    update: XOR<ScopeOfWorksUpdateWithoutProductAttributeUnitValuesInput, ScopeOfWorksUncheckedUpdateWithoutProductAttributeUnitValuesInput>
    create: XOR<ScopeOfWorksCreateWithoutProductAttributeUnitValuesInput, ScopeOfWorksUncheckedCreateWithoutProductAttributeUnitValuesInput>
  }

  export type ScopeOfWorksUpdateWithWhereUniqueWithoutProductAttributeUnitValuesInput = {
    where: ScopeOfWorksWhereUniqueInput
    data: XOR<ScopeOfWorksUpdateWithoutProductAttributeUnitValuesInput, ScopeOfWorksUncheckedUpdateWithoutProductAttributeUnitValuesInput>
  }

  export type ScopeOfWorksUpdateManyWithWhereWithoutProductAttributeUnitValuesInput = {
    where: ScopeOfWorksScalarWhereInput
    data: XOR<ScopeOfWorksUpdateManyMutationInput, ScopeOfWorksUncheckedUpdateManyWithoutScopeOfWorksInput>
  }

  export type PropertyUnitProductCategoriesCreateWithoutProductCategoriesInput = {
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    PropertyUnits: PropertyUnitsCreateNestedOneWithoutPropertyUnitProductCategoriesInput
    PropertyUnitProductCategoryProducts?: PropertyUnitProductCategoryProductsCreateNestedManyWithoutPropertyUnitProductCategoriesInput
  }

  export type PropertyUnitProductCategoriesUncheckedCreateWithoutProductCategoriesInput = {
    id?: number
    property_unit_id: number
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    PropertyUnitProductCategoryProducts?: PropertyUnitProductCategoryProductsUncheckedCreateNestedManyWithoutPropertyUnitProductCategoriesInput
  }

  export type PropertyUnitProductCategoriesCreateOrConnectWithoutProductCategoriesInput = {
    where: PropertyUnitProductCategoriesWhereUniqueInput
    create: XOR<PropertyUnitProductCategoriesCreateWithoutProductCategoriesInput, PropertyUnitProductCategoriesUncheckedCreateWithoutProductCategoriesInput>
  }

  export type PropertyUnitProductCategoriesUpsertWithWhereUniqueWithoutProductCategoriesInput = {
    where: PropertyUnitProductCategoriesWhereUniqueInput
    update: XOR<PropertyUnitProductCategoriesUpdateWithoutProductCategoriesInput, PropertyUnitProductCategoriesUncheckedUpdateWithoutProductCategoriesInput>
    create: XOR<PropertyUnitProductCategoriesCreateWithoutProductCategoriesInput, PropertyUnitProductCategoriesUncheckedCreateWithoutProductCategoriesInput>
  }

  export type PropertyUnitProductCategoriesUpdateWithWhereUniqueWithoutProductCategoriesInput = {
    where: PropertyUnitProductCategoriesWhereUniqueInput
    data: XOR<PropertyUnitProductCategoriesUpdateWithoutProductCategoriesInput, PropertyUnitProductCategoriesUncheckedUpdateWithoutProductCategoriesInput>
  }

  export type PropertyUnitProductCategoriesUpdateManyWithWhereWithoutProductCategoriesInput = {
    where: PropertyUnitProductCategoriesScalarWhereInput
    data: XOR<PropertyUnitProductCategoriesUpdateManyMutationInput, PropertyUnitProductCategoriesUncheckedUpdateManyWithoutPropertyUnitProductCategoriesInput>
  }

  export type PropertyUnitProductCategoriesScalarWhereInput = {
    AND?: Enumerable<PropertyUnitProductCategoriesScalarWhereInput>
    OR?: Enumerable<PropertyUnitProductCategoriesScalarWhereInput>
    NOT?: Enumerable<PropertyUnitProductCategoriesScalarWhereInput>
    id?: IntFilter | number
    property_unit_id?: IntFilter | number
    product_category_id?: IntFilter | number
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    created_by?: IntNullableFilter | number | null
    updated_by?: IntNullableFilter | number | null
  }

  export type ProductsCreateWithoutProductPropertyUnitsInput = {
    name?: string | null
    slug?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    Products?: ProductsCreateNestedOneWithoutOther_ProductsInput
    ProductAttributeUnits?: ProductAttributeUnitsCreateNestedManyWithoutProductsInput
    other_Products?: ProductsCreateNestedManyWithoutProductsInput
    PropertyUnitProductCategoryProducts?: PropertyUnitProductCategoryProductsCreateNestedManyWithoutProductsInput
  }

  export type ProductsUncheckedCreateWithoutProductPropertyUnitsInput = {
    id?: number
    parent_id?: number | null
    name?: string | null
    slug?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    ProductAttributeUnits?: ProductAttributeUnitsUncheckedCreateNestedManyWithoutProductsInput
    other_Products?: ProductsUncheckedCreateNestedManyWithoutProductsInput
    PropertyUnitProductCategoryProducts?: PropertyUnitProductCategoryProductsUncheckedCreateNestedManyWithoutProductsInput
  }

  export type ProductsCreateOrConnectWithoutProductPropertyUnitsInput = {
    where: ProductsWhereUniqueInput
    create: XOR<ProductsCreateWithoutProductPropertyUnitsInput, ProductsUncheckedCreateWithoutProductPropertyUnitsInput>
  }

  export type PropertyUnitsCreateWithoutProductPropertyUnitsInput = {
    name?: string | null
    slug?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    PropertyUnitAttributes?: PropertyUnitAttributesCreateNestedManyWithoutPropertyUnitsInput
    PropertyUnitProductCategories?: PropertyUnitProductCategoriesCreateNestedManyWithoutPropertyUnitsInput
    UnitLocations?: UnitLocationsCreateNestedManyWithoutPropertyUnitsInput
  }

  export type PropertyUnitsUncheckedCreateWithoutProductPropertyUnitsInput = {
    id?: number
    name?: string | null
    slug?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    PropertyUnitAttributes?: PropertyUnitAttributesUncheckedCreateNestedManyWithoutPropertyUnitsInput
    PropertyUnitProductCategories?: PropertyUnitProductCategoriesUncheckedCreateNestedManyWithoutPropertyUnitsInput
    UnitLocations?: UnitLocationsUncheckedCreateNestedManyWithoutPropertyUnitsInput
  }

  export type PropertyUnitsCreateOrConnectWithoutProductPropertyUnitsInput = {
    where: PropertyUnitsWhereUniqueInput
    create: XOR<PropertyUnitsCreateWithoutProductPropertyUnitsInput, PropertyUnitsUncheckedCreateWithoutProductPropertyUnitsInput>
  }

  export type ProductsUpsertWithoutProductPropertyUnitsInput = {
    update: XOR<ProductsUpdateWithoutProductPropertyUnitsInput, ProductsUncheckedUpdateWithoutProductPropertyUnitsInput>
    create: XOR<ProductsCreateWithoutProductPropertyUnitsInput, ProductsUncheckedCreateWithoutProductPropertyUnitsInput>
  }

  export type ProductsUpdateWithoutProductPropertyUnitsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    Products?: ProductsUpdateOneWithoutOther_ProductsInput
    ProductAttributeUnits?: ProductAttributeUnitsUpdateManyWithoutProductsInput
    other_Products?: ProductsUpdateManyWithoutProductsInput
    PropertyUnitProductCategoryProducts?: PropertyUnitProductCategoryProductsUpdateManyWithoutProductsInput
  }

  export type ProductsUncheckedUpdateWithoutProductPropertyUnitsInput = {
    id?: IntFieldUpdateOperationsInput | number
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    ProductAttributeUnits?: ProductAttributeUnitsUncheckedUpdateManyWithoutProductsInput
    other_Products?: ProductsUncheckedUpdateManyWithoutProductsInput
    PropertyUnitProductCategoryProducts?: PropertyUnitProductCategoryProductsUncheckedUpdateManyWithoutProductsInput
  }

  export type PropertyUnitsUpsertWithoutProductPropertyUnitsInput = {
    update: XOR<PropertyUnitsUpdateWithoutProductPropertyUnitsInput, PropertyUnitsUncheckedUpdateWithoutProductPropertyUnitsInput>
    create: XOR<PropertyUnitsCreateWithoutProductPropertyUnitsInput, PropertyUnitsUncheckedCreateWithoutProductPropertyUnitsInput>
  }

  export type PropertyUnitsUpdateWithoutProductPropertyUnitsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    PropertyUnitAttributes?: PropertyUnitAttributesUpdateManyWithoutPropertyUnitsInput
    PropertyUnitProductCategories?: PropertyUnitProductCategoriesUpdateManyWithoutPropertyUnitsInput
    UnitLocations?: UnitLocationsUpdateManyWithoutPropertyUnitsInput
  }

  export type PropertyUnitsUncheckedUpdateWithoutProductPropertyUnitsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    PropertyUnitAttributes?: PropertyUnitAttributesUncheckedUpdateManyWithoutPropertyUnitsInput
    PropertyUnitProductCategories?: PropertyUnitProductCategoriesUncheckedUpdateManyWithoutPropertyUnitsInput
    UnitLocations?: UnitLocationsUncheckedUpdateManyWithoutPropertyUnitsInput
  }

  export type ProductsCreateWithoutOther_ProductsInput = {
    name?: string | null
    slug?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    Products?: ProductsCreateNestedOneWithoutOther_ProductsInput
    ProductAttributeUnits?: ProductAttributeUnitsCreateNestedManyWithoutProductsInput
    ProductPropertyUnits?: ProductPropertyUnitsCreateNestedManyWithoutProductsInput
    PropertyUnitProductCategoryProducts?: PropertyUnitProductCategoryProductsCreateNestedManyWithoutProductsInput
  }

  export type ProductsUncheckedCreateWithoutOther_ProductsInput = {
    id?: number
    parent_id?: number | null
    name?: string | null
    slug?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    ProductAttributeUnits?: ProductAttributeUnitsUncheckedCreateNestedManyWithoutProductsInput
    ProductPropertyUnits?: ProductPropertyUnitsUncheckedCreateNestedManyWithoutProductsInput
    PropertyUnitProductCategoryProducts?: PropertyUnitProductCategoryProductsUncheckedCreateNestedManyWithoutProductsInput
  }

  export type ProductsCreateOrConnectWithoutOther_ProductsInput = {
    where: ProductsWhereUniqueInput
    create: XOR<ProductsCreateWithoutOther_ProductsInput, ProductsUncheckedCreateWithoutOther_ProductsInput>
  }

  export type ProductAttributeUnitsCreateWithoutProductsInput = {
    name?: string | null
    html_element_type?: string | null
    display_order?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    Attributes: AttributesCreateNestedOneWithoutProductAttributeUnitsInput
    AttributeUnits: AttributeUnitsCreateNestedOneWithoutProductAttributeUnitsInput
    ProductAttributeUnitValues?: ProductAttributeUnitValuesCreateNestedManyWithoutProductAttributeUnitsInput
    ScopeOfWorks?: ScopeOfWorksCreateNestedManyWithoutProductAttributeUnitsInput
  }

  export type ProductAttributeUnitsUncheckedCreateWithoutProductsInput = {
    id?: number
    name?: string | null
    attribute_id: number
    attribute_unit_id: number
    html_element_type?: string | null
    display_order?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    ProductAttributeUnitValues?: ProductAttributeUnitValuesUncheckedCreateNestedManyWithoutProductAttributeUnitsInput
    ScopeOfWorks?: ScopeOfWorksUncheckedCreateNestedManyWithoutProductAttributeUnitsInput
  }

  export type ProductAttributeUnitsCreateOrConnectWithoutProductsInput = {
    where: ProductAttributeUnitsWhereUniqueInput
    create: XOR<ProductAttributeUnitsCreateWithoutProductsInput, ProductAttributeUnitsUncheckedCreateWithoutProductsInput>
  }

  export type ProductPropertyUnitsCreateWithoutProductsInput = {
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    PropertyUnits: PropertyUnitsCreateNestedOneWithoutProductPropertyUnitsInput
  }

  export type ProductPropertyUnitsUncheckedCreateWithoutProductsInput = {
    id?: number
    property_unit_id: number
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
  }

  export type ProductPropertyUnitsCreateOrConnectWithoutProductsInput = {
    where: ProductPropertyUnitsWhereUniqueInput
    create: XOR<ProductPropertyUnitsCreateWithoutProductsInput, ProductPropertyUnitsUncheckedCreateWithoutProductsInput>
  }

  export type ProductsCreateWithoutProductsInput = {
    name?: string | null
    slug?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    ProductAttributeUnits?: ProductAttributeUnitsCreateNestedManyWithoutProductsInput
    ProductPropertyUnits?: ProductPropertyUnitsCreateNestedManyWithoutProductsInput
    other_Products?: ProductsCreateNestedManyWithoutProductsInput
    PropertyUnitProductCategoryProducts?: PropertyUnitProductCategoryProductsCreateNestedManyWithoutProductsInput
  }

  export type ProductsUncheckedCreateWithoutProductsInput = {
    id?: number
    name?: string | null
    slug?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    ProductAttributeUnits?: ProductAttributeUnitsUncheckedCreateNestedManyWithoutProductsInput
    ProductPropertyUnits?: ProductPropertyUnitsUncheckedCreateNestedManyWithoutProductsInput
    other_Products?: ProductsUncheckedCreateNestedManyWithoutProductsInput
    PropertyUnitProductCategoryProducts?: PropertyUnitProductCategoryProductsUncheckedCreateNestedManyWithoutProductsInput
  }

  export type ProductsCreateOrConnectWithoutProductsInput = {
    where: ProductsWhereUniqueInput
    create: XOR<ProductsCreateWithoutProductsInput, ProductsUncheckedCreateWithoutProductsInput>
  }

  export type PropertyUnitProductCategoryProductsCreateWithoutProductsInput = {
    display_order?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    PropertyUnitProductCategories: PropertyUnitProductCategoriesCreateNestedOneWithoutPropertyUnitProductCategoryProductsInput
  }

  export type PropertyUnitProductCategoryProductsUncheckedCreateWithoutProductsInput = {
    id?: number
    property_unit_product_category_id: number
    display_order?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
  }

  export type PropertyUnitProductCategoryProductsCreateOrConnectWithoutProductsInput = {
    where: PropertyUnitProductCategoryProductsWhereUniqueInput
    create: XOR<PropertyUnitProductCategoryProductsCreateWithoutProductsInput, PropertyUnitProductCategoryProductsUncheckedCreateWithoutProductsInput>
  }

  export type ProductsUpsertWithoutOther_ProductsInput = {
    update: XOR<ProductsUpdateWithoutOther_ProductsInput, ProductsUncheckedUpdateWithoutOther_ProductsInput>
    create: XOR<ProductsCreateWithoutOther_ProductsInput, ProductsUncheckedCreateWithoutOther_ProductsInput>
  }

  export type ProductsUpdateWithoutOther_ProductsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    Products?: ProductsUpdateOneWithoutOther_ProductsInput
    ProductAttributeUnits?: ProductAttributeUnitsUpdateManyWithoutProductsInput
    ProductPropertyUnits?: ProductPropertyUnitsUpdateManyWithoutProductsInput
    PropertyUnitProductCategoryProducts?: PropertyUnitProductCategoryProductsUpdateManyWithoutProductsInput
  }

  export type ProductsUncheckedUpdateWithoutOther_ProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    ProductAttributeUnits?: ProductAttributeUnitsUncheckedUpdateManyWithoutProductsInput
    ProductPropertyUnits?: ProductPropertyUnitsUncheckedUpdateManyWithoutProductsInput
    PropertyUnitProductCategoryProducts?: PropertyUnitProductCategoryProductsUncheckedUpdateManyWithoutProductsInput
  }

  export type ProductAttributeUnitsUpsertWithWhereUniqueWithoutProductsInput = {
    where: ProductAttributeUnitsWhereUniqueInput
    update: XOR<ProductAttributeUnitsUpdateWithoutProductsInput, ProductAttributeUnitsUncheckedUpdateWithoutProductsInput>
    create: XOR<ProductAttributeUnitsCreateWithoutProductsInput, ProductAttributeUnitsUncheckedCreateWithoutProductsInput>
  }

  export type ProductAttributeUnitsUpdateWithWhereUniqueWithoutProductsInput = {
    where: ProductAttributeUnitsWhereUniqueInput
    data: XOR<ProductAttributeUnitsUpdateWithoutProductsInput, ProductAttributeUnitsUncheckedUpdateWithoutProductsInput>
  }

  export type ProductAttributeUnitsUpdateManyWithWhereWithoutProductsInput = {
    where: ProductAttributeUnitsScalarWhereInput
    data: XOR<ProductAttributeUnitsUpdateManyMutationInput, ProductAttributeUnitsUncheckedUpdateManyWithoutProductAttributeUnitsInput>
  }

  export type ProductPropertyUnitsUpsertWithWhereUniqueWithoutProductsInput = {
    where: ProductPropertyUnitsWhereUniqueInput
    update: XOR<ProductPropertyUnitsUpdateWithoutProductsInput, ProductPropertyUnitsUncheckedUpdateWithoutProductsInput>
    create: XOR<ProductPropertyUnitsCreateWithoutProductsInput, ProductPropertyUnitsUncheckedCreateWithoutProductsInput>
  }

  export type ProductPropertyUnitsUpdateWithWhereUniqueWithoutProductsInput = {
    where: ProductPropertyUnitsWhereUniqueInput
    data: XOR<ProductPropertyUnitsUpdateWithoutProductsInput, ProductPropertyUnitsUncheckedUpdateWithoutProductsInput>
  }

  export type ProductPropertyUnitsUpdateManyWithWhereWithoutProductsInput = {
    where: ProductPropertyUnitsScalarWhereInput
    data: XOR<ProductPropertyUnitsUpdateManyMutationInput, ProductPropertyUnitsUncheckedUpdateManyWithoutProductPropertyUnitsInput>
  }

  export type ProductPropertyUnitsScalarWhereInput = {
    AND?: Enumerable<ProductPropertyUnitsScalarWhereInput>
    OR?: Enumerable<ProductPropertyUnitsScalarWhereInput>
    NOT?: Enumerable<ProductPropertyUnitsScalarWhereInput>
    id?: IntFilter | number
    property_unit_id?: IntFilter | number
    product_id?: IntFilter | number
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    created_by?: IntNullableFilter | number | null
    updated_by?: IntNullableFilter | number | null
  }

  export type ProductsUpsertWithWhereUniqueWithoutProductsInput = {
    where: ProductsWhereUniqueInput
    update: XOR<ProductsUpdateWithoutProductsInput, ProductsUncheckedUpdateWithoutProductsInput>
    create: XOR<ProductsCreateWithoutProductsInput, ProductsUncheckedCreateWithoutProductsInput>
  }

  export type ProductsUpdateWithWhereUniqueWithoutProductsInput = {
    where: ProductsWhereUniqueInput
    data: XOR<ProductsUpdateWithoutProductsInput, ProductsUncheckedUpdateWithoutProductsInput>
  }

  export type ProductsUpdateManyWithWhereWithoutProductsInput = {
    where: ProductsScalarWhereInput
    data: XOR<ProductsUpdateManyMutationInput, ProductsUncheckedUpdateManyWithoutOther_ProductsInput>
  }

  export type ProductsScalarWhereInput = {
    AND?: Enumerable<ProductsScalarWhereInput>
    OR?: Enumerable<ProductsScalarWhereInput>
    NOT?: Enumerable<ProductsScalarWhereInput>
    id?: IntFilter | number
    parent_id?: IntNullableFilter | number | null
    name?: StringNullableFilter | string | null
    slug?: StringNullableFilter | string | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    created_by?: IntNullableFilter | number | null
    updated_by?: IntNullableFilter | number | null
  }

  export type PropertyUnitProductCategoryProductsUpsertWithWhereUniqueWithoutProductsInput = {
    where: PropertyUnitProductCategoryProductsWhereUniqueInput
    update: XOR<PropertyUnitProductCategoryProductsUpdateWithoutProductsInput, PropertyUnitProductCategoryProductsUncheckedUpdateWithoutProductsInput>
    create: XOR<PropertyUnitProductCategoryProductsCreateWithoutProductsInput, PropertyUnitProductCategoryProductsUncheckedCreateWithoutProductsInput>
  }

  export type PropertyUnitProductCategoryProductsUpdateWithWhereUniqueWithoutProductsInput = {
    where: PropertyUnitProductCategoryProductsWhereUniqueInput
    data: XOR<PropertyUnitProductCategoryProductsUpdateWithoutProductsInput, PropertyUnitProductCategoryProductsUncheckedUpdateWithoutProductsInput>
  }

  export type PropertyUnitProductCategoryProductsUpdateManyWithWhereWithoutProductsInput = {
    where: PropertyUnitProductCategoryProductsScalarWhereInput
    data: XOR<PropertyUnitProductCategoryProductsUpdateManyMutationInput, PropertyUnitProductCategoryProductsUncheckedUpdateManyWithoutPropertyUnitProductCategoryProductsInput>
  }

  export type PropertyUnitProductCategoryProductsScalarWhereInput = {
    AND?: Enumerable<PropertyUnitProductCategoryProductsScalarWhereInput>
    OR?: Enumerable<PropertyUnitProductCategoryProductsScalarWhereInput>
    NOT?: Enumerable<PropertyUnitProductCategoryProductsScalarWhereInput>
    id?: IntFilter | number
    property_unit_product_category_id?: IntFilter | number
    product_id?: IntFilter | number
    display_order?: IntNullableFilter | number | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    created_by?: IntNullableFilter | number | null
    updated_by?: IntNullableFilter | number | null
  }

  export type ProjectsCreateWithoutProjectProposalsInput = {
    name?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    start_date?: Date | string
    Property_Addresses: Property_AddressesCreateNestedOneWithoutProjectsInput
    ProjectTypeAssociations?: ProjectTypeAssociationsCreateNestedManyWithoutProjectsInput
  }

  export type ProjectsUncheckedCreateWithoutProjectProposalsInput = {
    id?: number
    name?: string | null
    property_address_id: number
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    start_date?: Date | string
    ProjectTypeAssociations?: ProjectTypeAssociationsUncheckedCreateNestedManyWithoutProjectsInput
  }

  export type ProjectsCreateOrConnectWithoutProjectProposalsInput = {
    where: ProjectsWhereUniqueInput
    create: XOR<ProjectsCreateWithoutProjectProposalsInput, ProjectsUncheckedCreateWithoutProjectProposalsInput>
  }

  export type AreaOfWorksCreateWithoutProjectProposalsInput = {
    new_unit?: string | null
    existing_unit?: string | null
    unit_alias?: string | null
    work_type?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    UnitLocations: UnitLocationsCreateNestedOneWithoutAreaOfWorksInput
    ScopeOfWorkPropertyUnits?: ScopeOfWorkPropertyUnitsCreateNestedManyWithoutAreaOfWorksInput
    ScopeOfWorks?: ScopeOfWorksCreateNestedManyWithoutAreaOfWorksInput
  }

  export type AreaOfWorksUncheckedCreateWithoutProjectProposalsInput = {
    id?: number
    unit_location_id: number
    new_unit?: string | null
    existing_unit?: string | null
    unit_alias?: string | null
    work_type?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    ScopeOfWorkPropertyUnits?: ScopeOfWorkPropertyUnitsUncheckedCreateNestedManyWithoutAreaOfWorksInput
    ScopeOfWorks?: ScopeOfWorksUncheckedCreateNestedManyWithoutAreaOfWorksInput
  }

  export type AreaOfWorksCreateOrConnectWithoutProjectProposalsInput = {
    where: AreaOfWorksWhereUniqueInput
    create: XOR<AreaOfWorksCreateWithoutProjectProposalsInput, AreaOfWorksUncheckedCreateWithoutProjectProposalsInput>
  }

  export type ScopeOfWorkPropertyUnitsCreateWithoutProjectProposalsInput = {
    value?: string | null
    attribute_custom_name?: string | null
    attribute_custom_value?: string | null
    attribute_custom_unit?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    AreaOfWorks: AreaOfWorksCreateNestedOneWithoutScopeOfWorkPropertyUnitsInput
    PropertyUnitAttributes: PropertyUnitAttributesCreateNestedOneWithoutScopeOfWorkPropertyUnitsInput
  }

  export type ScopeOfWorkPropertyUnitsUncheckedCreateWithoutProjectProposalsInput = {
    id?: number
    area_of_work_id: number
    property_unit_attribute_id: number
    value?: string | null
    attribute_custom_name?: string | null
    attribute_custom_value?: string | null
    attribute_custom_unit?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
  }

  export type ScopeOfWorkPropertyUnitsCreateOrConnectWithoutProjectProposalsInput = {
    where: ScopeOfWorkPropertyUnitsWhereUniqueInput
    create: XOR<ScopeOfWorkPropertyUnitsCreateWithoutProjectProposalsInput, ScopeOfWorkPropertyUnitsUncheckedCreateWithoutProjectProposalsInput>
  }

  export type ScopeOfWorksCreateWithoutProjectProposalsInput = {
    attribute_custom_name?: string | null
    attribute_custom_value?: string | null
    attribute_custom_unit?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    AreaOfWorks: AreaOfWorksCreateNestedOneWithoutScopeOfWorksInput
    ProductAttributeUnits: ProductAttributeUnitsCreateNestedOneWithoutScopeOfWorksInput
    ProductAttributeUnitValues: ProductAttributeUnitValuesCreateNestedOneWithoutScopeOfWorksInput
  }

  export type ScopeOfWorksUncheckedCreateWithoutProjectProposalsInput = {
    id?: number
    area_of_work_id: number
    product_attribute_unit_id: number
    product_attribute_unit_value_id: number
    attribute_custom_name?: string | null
    attribute_custom_value?: string | null
    attribute_custom_unit?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
  }

  export type ScopeOfWorksCreateOrConnectWithoutProjectProposalsInput = {
    where: ScopeOfWorksWhereUniqueInput
    create: XOR<ScopeOfWorksCreateWithoutProjectProposalsInput, ScopeOfWorksUncheckedCreateWithoutProjectProposalsInput>
  }

  export type ProjectsUpsertWithoutProjectProposalsInput = {
    update: XOR<ProjectsUpdateWithoutProjectProposalsInput, ProjectsUncheckedUpdateWithoutProjectProposalsInput>
    create: XOR<ProjectsCreateWithoutProjectProposalsInput, ProjectsUncheckedCreateWithoutProjectProposalsInput>
  }

  export type ProjectsUpdateWithoutProjectProposalsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    Property_Addresses?: Property_AddressesUpdateOneRequiredWithoutProjectsInput
    ProjectTypeAssociations?: ProjectTypeAssociationsUpdateManyWithoutProjectsInput
  }

  export type ProjectsUncheckedUpdateWithoutProjectProposalsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    property_address_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    ProjectTypeAssociations?: ProjectTypeAssociationsUncheckedUpdateManyWithoutProjectsInput
  }

  export type AreaOfWorksUpsertWithWhereUniqueWithoutProjectProposalsInput = {
    where: AreaOfWorksWhereUniqueInput
    update: XOR<AreaOfWorksUpdateWithoutProjectProposalsInput, AreaOfWorksUncheckedUpdateWithoutProjectProposalsInput>
    create: XOR<AreaOfWorksCreateWithoutProjectProposalsInput, AreaOfWorksUncheckedCreateWithoutProjectProposalsInput>
  }

  export type AreaOfWorksUpdateWithWhereUniqueWithoutProjectProposalsInput = {
    where: AreaOfWorksWhereUniqueInput
    data: XOR<AreaOfWorksUpdateWithoutProjectProposalsInput, AreaOfWorksUncheckedUpdateWithoutProjectProposalsInput>
  }

  export type AreaOfWorksUpdateManyWithWhereWithoutProjectProposalsInput = {
    where: AreaOfWorksScalarWhereInput
    data: XOR<AreaOfWorksUpdateManyMutationInput, AreaOfWorksUncheckedUpdateManyWithoutAreaOfWorksInput>
  }

  export type AreaOfWorksScalarWhereInput = {
    AND?: Enumerable<AreaOfWorksScalarWhereInput>
    OR?: Enumerable<AreaOfWorksScalarWhereInput>
    NOT?: Enumerable<AreaOfWorksScalarWhereInput>
    id?: IntFilter | number
    project_proposal_id?: IntFilter | number
    unit_location_id?: IntFilter | number
    new_unit?: StringNullableFilter | string | null
    existing_unit?: StringNullableFilter | string | null
    unit_alias?: StringNullableFilter | string | null
    work_type?: StringNullableFilter | string | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    created_by?: IntNullableFilter | number | null
    updated_by?: IntNullableFilter | number | null
  }

  export type ScopeOfWorkPropertyUnitsUpsertWithWhereUniqueWithoutProjectProposalsInput = {
    where: ScopeOfWorkPropertyUnitsWhereUniqueInput
    update: XOR<ScopeOfWorkPropertyUnitsUpdateWithoutProjectProposalsInput, ScopeOfWorkPropertyUnitsUncheckedUpdateWithoutProjectProposalsInput>
    create: XOR<ScopeOfWorkPropertyUnitsCreateWithoutProjectProposalsInput, ScopeOfWorkPropertyUnitsUncheckedCreateWithoutProjectProposalsInput>
  }

  export type ScopeOfWorkPropertyUnitsUpdateWithWhereUniqueWithoutProjectProposalsInput = {
    where: ScopeOfWorkPropertyUnitsWhereUniqueInput
    data: XOR<ScopeOfWorkPropertyUnitsUpdateWithoutProjectProposalsInput, ScopeOfWorkPropertyUnitsUncheckedUpdateWithoutProjectProposalsInput>
  }

  export type ScopeOfWorkPropertyUnitsUpdateManyWithWhereWithoutProjectProposalsInput = {
    where: ScopeOfWorkPropertyUnitsScalarWhereInput
    data: XOR<ScopeOfWorkPropertyUnitsUpdateManyMutationInput, ScopeOfWorkPropertyUnitsUncheckedUpdateManyWithoutScopeOfWorkPropertyUnitsInput>
  }

  export type ScopeOfWorksUpsertWithWhereUniqueWithoutProjectProposalsInput = {
    where: ScopeOfWorksWhereUniqueInput
    update: XOR<ScopeOfWorksUpdateWithoutProjectProposalsInput, ScopeOfWorksUncheckedUpdateWithoutProjectProposalsInput>
    create: XOR<ScopeOfWorksCreateWithoutProjectProposalsInput, ScopeOfWorksUncheckedCreateWithoutProjectProposalsInput>
  }

  export type ScopeOfWorksUpdateWithWhereUniqueWithoutProjectProposalsInput = {
    where: ScopeOfWorksWhereUniqueInput
    data: XOR<ScopeOfWorksUpdateWithoutProjectProposalsInput, ScopeOfWorksUncheckedUpdateWithoutProjectProposalsInput>
  }

  export type ScopeOfWorksUpdateManyWithWhereWithoutProjectProposalsInput = {
    where: ScopeOfWorksScalarWhereInput
    data: XOR<ScopeOfWorksUpdateManyMutationInput, ScopeOfWorksUncheckedUpdateManyWithoutScopeOfWorksInput>
  }

  export type Property_AddressesCreateWithoutProjectsInput = {
    street?: string | null
    postal_code?: string | null
    construction_type?: string | null
    withBasement?: boolean
    storyId?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    Cities: CitiesCreateNestedOneWithoutProperty_AddressesInput
    PropertyOwners: PropertyOwnersCreateNestedOneWithoutProperty_AddressesInput
    PropertySubTypes: PropertySubTypesCreateNestedOneWithoutProperty_AddressesInput
  }

  export type Property_AddressesUncheckedCreateWithoutProjectsInput = {
    id?: number
    street?: string | null
    property_owner_id: number
    city_id: number
    property_sub_type_id: number
    postal_code?: string | null
    construction_type?: string | null
    withBasement?: boolean
    storyId?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
  }

  export type Property_AddressesCreateOrConnectWithoutProjectsInput = {
    where: Property_AddressesWhereUniqueInput
    create: XOR<Property_AddressesCreateWithoutProjectsInput, Property_AddressesUncheckedCreateWithoutProjectsInput>
  }

  export type ProjectProposalsCreateWithoutProjectsInput = {
    name?: string | null
    proposal_status?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    AreaOfWorks?: AreaOfWorksCreateNestedManyWithoutProjectProposalsInput
    ScopeOfWorkPropertyUnits?: ScopeOfWorkPropertyUnitsCreateNestedManyWithoutProjectProposalsInput
    ScopeOfWorks?: ScopeOfWorksCreateNestedManyWithoutProjectProposalsInput
  }

  export type ProjectProposalsUncheckedCreateWithoutProjectsInput = {
    id?: number
    name?: string | null
    proposal_status?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    AreaOfWorks?: AreaOfWorksUncheckedCreateNestedManyWithoutProjectProposalsInput
    ScopeOfWorkPropertyUnits?: ScopeOfWorkPropertyUnitsUncheckedCreateNestedManyWithoutProjectProposalsInput
    ScopeOfWorks?: ScopeOfWorksUncheckedCreateNestedManyWithoutProjectProposalsInput
  }

  export type ProjectProposalsCreateOrConnectWithoutProjectsInput = {
    where: ProjectProposalsWhereUniqueInput
    create: XOR<ProjectProposalsCreateWithoutProjectsInput, ProjectProposalsUncheckedCreateWithoutProjectsInput>
  }

  export type ProjectTypeAssociationsCreateWithoutProjectsInput = {
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    ProjectTypes: ProjectTypesCreateNestedOneWithoutProjectTypeAssociationsInput
  }

  export type ProjectTypeAssociationsUncheckedCreateWithoutProjectsInput = {
    id?: number
    project_type_id: number
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
  }

  export type ProjectTypeAssociationsCreateOrConnectWithoutProjectsInput = {
    where: ProjectTypeAssociationsWhereUniqueInput
    create: XOR<ProjectTypeAssociationsCreateWithoutProjectsInput, ProjectTypeAssociationsUncheckedCreateWithoutProjectsInput>
  }

  export type Property_AddressesUpsertWithoutProjectsInput = {
    update: XOR<Property_AddressesUpdateWithoutProjectsInput, Property_AddressesUncheckedUpdateWithoutProjectsInput>
    create: XOR<Property_AddressesCreateWithoutProjectsInput, Property_AddressesUncheckedCreateWithoutProjectsInput>
  }

  export type Property_AddressesUpdateWithoutProjectsInput = {
    street?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    construction_type?: NullableStringFieldUpdateOperationsInput | string | null
    withBasement?: BoolFieldUpdateOperationsInput | boolean
    storyId?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    Cities?: CitiesUpdateOneRequiredWithoutProperty_AddressesInput
    PropertyOwners?: PropertyOwnersUpdateOneRequiredWithoutProperty_AddressesInput
    PropertySubTypes?: PropertySubTypesUpdateOneRequiredWithoutProperty_AddressesInput
  }

  export type Property_AddressesUncheckedUpdateWithoutProjectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    street?: NullableStringFieldUpdateOperationsInput | string | null
    property_owner_id?: IntFieldUpdateOperationsInput | number
    city_id?: IntFieldUpdateOperationsInput | number
    property_sub_type_id?: IntFieldUpdateOperationsInput | number
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    construction_type?: NullableStringFieldUpdateOperationsInput | string | null
    withBasement?: BoolFieldUpdateOperationsInput | boolean
    storyId?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProjectProposalsUpsertWithWhereUniqueWithoutProjectsInput = {
    where: ProjectProposalsWhereUniqueInput
    update: XOR<ProjectProposalsUpdateWithoutProjectsInput, ProjectProposalsUncheckedUpdateWithoutProjectsInput>
    create: XOR<ProjectProposalsCreateWithoutProjectsInput, ProjectProposalsUncheckedCreateWithoutProjectsInput>
  }

  export type ProjectProposalsUpdateWithWhereUniqueWithoutProjectsInput = {
    where: ProjectProposalsWhereUniqueInput
    data: XOR<ProjectProposalsUpdateWithoutProjectsInput, ProjectProposalsUncheckedUpdateWithoutProjectsInput>
  }

  export type ProjectProposalsUpdateManyWithWhereWithoutProjectsInput = {
    where: ProjectProposalsScalarWhereInput
    data: XOR<ProjectProposalsUpdateManyMutationInput, ProjectProposalsUncheckedUpdateManyWithoutProjectProposalsInput>
  }

  export type ProjectProposalsScalarWhereInput = {
    AND?: Enumerable<ProjectProposalsScalarWhereInput>
    OR?: Enumerable<ProjectProposalsScalarWhereInput>
    NOT?: Enumerable<ProjectProposalsScalarWhereInput>
    id?: IntFilter | number
    name?: StringNullableFilter | string | null
    project_id?: IntFilter | number
    proposal_status?: StringNullableFilter | string | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    created_by?: IntNullableFilter | number | null
    updated_by?: IntNullableFilter | number | null
  }

  export type ProjectTypeAssociationsUpsertWithWhereUniqueWithoutProjectsInput = {
    where: ProjectTypeAssociationsWhereUniqueInput
    update: XOR<ProjectTypeAssociationsUpdateWithoutProjectsInput, ProjectTypeAssociationsUncheckedUpdateWithoutProjectsInput>
    create: XOR<ProjectTypeAssociationsCreateWithoutProjectsInput, ProjectTypeAssociationsUncheckedCreateWithoutProjectsInput>
  }

  export type ProjectTypeAssociationsUpdateWithWhereUniqueWithoutProjectsInput = {
    where: ProjectTypeAssociationsWhereUniqueInput
    data: XOR<ProjectTypeAssociationsUpdateWithoutProjectsInput, ProjectTypeAssociationsUncheckedUpdateWithoutProjectsInput>
  }

  export type ProjectTypeAssociationsUpdateManyWithWhereWithoutProjectsInput = {
    where: ProjectTypeAssociationsScalarWhereInput
    data: XOR<ProjectTypeAssociationsUpdateManyMutationInput, ProjectTypeAssociationsUncheckedUpdateManyWithoutProjectTypeAssociationsInput>
  }

  export type ProjectTypeAssociationsScalarWhereInput = {
    AND?: Enumerable<ProjectTypeAssociationsScalarWhereInput>
    OR?: Enumerable<ProjectTypeAssociationsScalarWhereInput>
    NOT?: Enumerable<ProjectTypeAssociationsScalarWhereInput>
    id?: IntFilter | number
    project_id?: IntFilter | number
    project_type_id?: IntFilter | number
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    created_by?: IntNullableFilter | number | null
    updated_by?: IntNullableFilter | number | null
  }

  export type ProjectsCreateWithoutProjectTypeAssociationsInput = {
    name?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    start_date?: Date | string
    Property_Addresses: Property_AddressesCreateNestedOneWithoutProjectsInput
    ProjectProposals?: ProjectProposalsCreateNestedManyWithoutProjectsInput
  }

  export type ProjectsUncheckedCreateWithoutProjectTypeAssociationsInput = {
    id?: number
    name?: string | null
    property_address_id: number
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    start_date?: Date | string
    ProjectProposals?: ProjectProposalsUncheckedCreateNestedManyWithoutProjectsInput
  }

  export type ProjectsCreateOrConnectWithoutProjectTypeAssociationsInput = {
    where: ProjectsWhereUniqueInput
    create: XOR<ProjectsCreateWithoutProjectTypeAssociationsInput, ProjectsUncheckedCreateWithoutProjectTypeAssociationsInput>
  }

  export type ProjectTypesCreateWithoutProjectTypeAssociationsInput = {
    type: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
  }

  export type ProjectTypesUncheckedCreateWithoutProjectTypeAssociationsInput = {
    id?: number
    type: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
  }

  export type ProjectTypesCreateOrConnectWithoutProjectTypeAssociationsInput = {
    where: ProjectTypesWhereUniqueInput
    create: XOR<ProjectTypesCreateWithoutProjectTypeAssociationsInput, ProjectTypesUncheckedCreateWithoutProjectTypeAssociationsInput>
  }

  export type ProjectsUpsertWithoutProjectTypeAssociationsInput = {
    update: XOR<ProjectsUpdateWithoutProjectTypeAssociationsInput, ProjectsUncheckedUpdateWithoutProjectTypeAssociationsInput>
    create: XOR<ProjectsCreateWithoutProjectTypeAssociationsInput, ProjectsUncheckedCreateWithoutProjectTypeAssociationsInput>
  }

  export type ProjectsUpdateWithoutProjectTypeAssociationsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    Property_Addresses?: Property_AddressesUpdateOneRequiredWithoutProjectsInput
    ProjectProposals?: ProjectProposalsUpdateManyWithoutProjectsInput
  }

  export type ProjectsUncheckedUpdateWithoutProjectTypeAssociationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    property_address_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    ProjectProposals?: ProjectProposalsUncheckedUpdateManyWithoutProjectsInput
  }

  export type ProjectTypesUpsertWithoutProjectTypeAssociationsInput = {
    update: XOR<ProjectTypesUpdateWithoutProjectTypeAssociationsInput, ProjectTypesUncheckedUpdateWithoutProjectTypeAssociationsInput>
    create: XOR<ProjectTypesCreateWithoutProjectTypeAssociationsInput, ProjectTypesUncheckedCreateWithoutProjectTypeAssociationsInput>
  }

  export type ProjectTypesUpdateWithoutProjectTypeAssociationsInput = {
    type?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProjectTypesUncheckedUpdateWithoutProjectTypeAssociationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProjectTypeAssociationsCreateWithoutProjectTypesInput = {
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    Projects: ProjectsCreateNestedOneWithoutProjectTypeAssociationsInput
  }

  export type ProjectTypeAssociationsUncheckedCreateWithoutProjectTypesInput = {
    id?: number
    project_id: number
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
  }

  export type ProjectTypeAssociationsCreateOrConnectWithoutProjectTypesInput = {
    where: ProjectTypeAssociationsWhereUniqueInput
    create: XOR<ProjectTypeAssociationsCreateWithoutProjectTypesInput, ProjectTypeAssociationsUncheckedCreateWithoutProjectTypesInput>
  }

  export type ProjectTypeAssociationsUpsertWithWhereUniqueWithoutProjectTypesInput = {
    where: ProjectTypeAssociationsWhereUniqueInput
    update: XOR<ProjectTypeAssociationsUpdateWithoutProjectTypesInput, ProjectTypeAssociationsUncheckedUpdateWithoutProjectTypesInput>
    create: XOR<ProjectTypeAssociationsCreateWithoutProjectTypesInput, ProjectTypeAssociationsUncheckedCreateWithoutProjectTypesInput>
  }

  export type ProjectTypeAssociationsUpdateWithWhereUniqueWithoutProjectTypesInput = {
    where: ProjectTypeAssociationsWhereUniqueInput
    data: XOR<ProjectTypeAssociationsUpdateWithoutProjectTypesInput, ProjectTypeAssociationsUncheckedUpdateWithoutProjectTypesInput>
  }

  export type ProjectTypeAssociationsUpdateManyWithWhereWithoutProjectTypesInput = {
    where: ProjectTypeAssociationsScalarWhereInput
    data: XOR<ProjectTypeAssociationsUpdateManyMutationInput, ProjectTypeAssociationsUncheckedUpdateManyWithoutProjectTypeAssociationsInput>
  }

  export type UnitLocationsCreateWithoutPropertyLevelsInput = {
    unit_name?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    PropertySubTypes: PropertySubTypesCreateNestedOneWithoutUnitLocationsInput
    PropertyUnits: PropertyUnitsCreateNestedOneWithoutUnitLocationsInput
    AreaOfWorks?: AreaOfWorksCreateNestedManyWithoutUnitLocationsInput
  }

  export type UnitLocationsUncheckedCreateWithoutPropertyLevelsInput = {
    id?: number
    unit_name?: string | null
    property_sub_type_id: number
    property_unit_id: number
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    AreaOfWorks?: AreaOfWorksUncheckedCreateNestedManyWithoutUnitLocationsInput
  }

  export type UnitLocationsCreateOrConnectWithoutPropertyLevelsInput = {
    where: UnitLocationsWhereUniqueInput
    create: XOR<UnitLocationsCreateWithoutPropertyLevelsInput, UnitLocationsUncheckedCreateWithoutPropertyLevelsInput>
  }

  export type UnitLocationsUpsertWithWhereUniqueWithoutPropertyLevelsInput = {
    where: UnitLocationsWhereUniqueInput
    update: XOR<UnitLocationsUpdateWithoutPropertyLevelsInput, UnitLocationsUncheckedUpdateWithoutPropertyLevelsInput>
    create: XOR<UnitLocationsCreateWithoutPropertyLevelsInput, UnitLocationsUncheckedCreateWithoutPropertyLevelsInput>
  }

  export type UnitLocationsUpdateWithWhereUniqueWithoutPropertyLevelsInput = {
    where: UnitLocationsWhereUniqueInput
    data: XOR<UnitLocationsUpdateWithoutPropertyLevelsInput, UnitLocationsUncheckedUpdateWithoutPropertyLevelsInput>
  }

  export type UnitLocationsUpdateManyWithWhereWithoutPropertyLevelsInput = {
    where: UnitLocationsScalarWhereInput
    data: XOR<UnitLocationsUpdateManyMutationInput, UnitLocationsUncheckedUpdateManyWithoutUnitLocationsInput>
  }

  export type UnitLocationsScalarWhereInput = {
    AND?: Enumerable<UnitLocationsScalarWhereInput>
    OR?: Enumerable<UnitLocationsScalarWhereInput>
    NOT?: Enumerable<UnitLocationsScalarWhereInput>
    id?: IntFilter | number
    unit_name?: StringNullableFilter | string | null
    property_sub_type_id?: IntFilter | number
    property_level_id?: IntFilter | number
    property_unit_id?: IntFilter | number
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    created_by?: IntNullableFilter | number | null
    updated_by?: IntNullableFilter | number | null
  }

  export type UsersCreateWithoutPropertyOwnersInput = {
    user_type: string
    email: string
    status?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    username?: string | null
    email_verified?: boolean
    name?: string | null
    Backend_Users?: Backend_UsersCreateNestedManyWithoutUsersInput
    Contractors?: ContractorsCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutPropertyOwnersInput = {
    id?: number
    user_type: string
    email: string
    status?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    username?: string | null
    email_verified?: boolean
    name?: string | null
    Backend_Users?: Backend_UsersUncheckedCreateNestedManyWithoutUsersInput
    Contractors?: ContractorsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutPropertyOwnersInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutPropertyOwnersInput, UsersUncheckedCreateWithoutPropertyOwnersInput>
  }

  export type Property_AddressesCreateWithoutPropertyOwnersInput = {
    street?: string | null
    postal_code?: string | null
    construction_type?: string | null
    withBasement?: boolean
    storyId?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    Cities: CitiesCreateNestedOneWithoutProperty_AddressesInput
    PropertySubTypes: PropertySubTypesCreateNestedOneWithoutProperty_AddressesInput
    Projects?: ProjectsCreateNestedManyWithoutProperty_AddressesInput
  }

  export type Property_AddressesUncheckedCreateWithoutPropertyOwnersInput = {
    id?: number
    street?: string | null
    city_id: number
    property_sub_type_id: number
    postal_code?: string | null
    construction_type?: string | null
    withBasement?: boolean
    storyId?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    Projects?: ProjectsUncheckedCreateNestedManyWithoutProperty_AddressesInput
  }

  export type Property_AddressesCreateOrConnectWithoutPropertyOwnersInput = {
    where: Property_AddressesWhereUniqueInput
    create: XOR<Property_AddressesCreateWithoutPropertyOwnersInput, Property_AddressesUncheckedCreateWithoutPropertyOwnersInput>
  }

  export type UsersUpsertWithoutPropertyOwnersInput = {
    update: XOR<UsersUpdateWithoutPropertyOwnersInput, UsersUncheckedUpdateWithoutPropertyOwnersInput>
    create: XOR<UsersCreateWithoutPropertyOwnersInput, UsersUncheckedCreateWithoutPropertyOwnersInput>
  }

  export type UsersUpdateWithoutPropertyOwnersInput = {
    user_type?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    name?: NullableStringFieldUpdateOperationsInput | string | null
    Backend_Users?: Backend_UsersUpdateManyWithoutUsersInput
    Contractors?: ContractorsUpdateManyWithoutUsersInput
  }

  export type UsersUncheckedUpdateWithoutPropertyOwnersInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_type?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    name?: NullableStringFieldUpdateOperationsInput | string | null
    Backend_Users?: Backend_UsersUncheckedUpdateManyWithoutUsersInput
    Contractors?: ContractorsUncheckedUpdateManyWithoutUsersInput
  }

  export type Property_AddressesUpsertWithWhereUniqueWithoutPropertyOwnersInput = {
    where: Property_AddressesWhereUniqueInput
    update: XOR<Property_AddressesUpdateWithoutPropertyOwnersInput, Property_AddressesUncheckedUpdateWithoutPropertyOwnersInput>
    create: XOR<Property_AddressesCreateWithoutPropertyOwnersInput, Property_AddressesUncheckedCreateWithoutPropertyOwnersInput>
  }

  export type Property_AddressesUpdateWithWhereUniqueWithoutPropertyOwnersInput = {
    where: Property_AddressesWhereUniqueInput
    data: XOR<Property_AddressesUpdateWithoutPropertyOwnersInput, Property_AddressesUncheckedUpdateWithoutPropertyOwnersInput>
  }

  export type Property_AddressesUpdateManyWithWhereWithoutPropertyOwnersInput = {
    where: Property_AddressesScalarWhereInput
    data: XOR<Property_AddressesUpdateManyMutationInput, Property_AddressesUncheckedUpdateManyWithoutProperty_AddressesInput>
  }

  export type Property_TypesCreateWithoutPropertySubTypesInput = {
    name: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
  }

  export type Property_TypesUncheckedCreateWithoutPropertySubTypesInput = {
    id?: number
    name: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
  }

  export type Property_TypesCreateOrConnectWithoutPropertySubTypesInput = {
    where: Property_TypesWhereUniqueInput
    create: XOR<Property_TypesCreateWithoutPropertySubTypesInput, Property_TypesUncheckedCreateWithoutPropertySubTypesInput>
  }

  export type Property_AddressesCreateWithoutPropertySubTypesInput = {
    street?: string | null
    postal_code?: string | null
    construction_type?: string | null
    withBasement?: boolean
    storyId?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    Cities: CitiesCreateNestedOneWithoutProperty_AddressesInput
    PropertyOwners: PropertyOwnersCreateNestedOneWithoutProperty_AddressesInput
    Projects?: ProjectsCreateNestedManyWithoutProperty_AddressesInput
  }

  export type Property_AddressesUncheckedCreateWithoutPropertySubTypesInput = {
    id?: number
    street?: string | null
    property_owner_id: number
    city_id: number
    postal_code?: string | null
    construction_type?: string | null
    withBasement?: boolean
    storyId?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    Projects?: ProjectsUncheckedCreateNestedManyWithoutProperty_AddressesInput
  }

  export type Property_AddressesCreateOrConnectWithoutPropertySubTypesInput = {
    where: Property_AddressesWhereUniqueInput
    create: XOR<Property_AddressesCreateWithoutPropertySubTypesInput, Property_AddressesUncheckedCreateWithoutPropertySubTypesInput>
  }

  export type UnitLocationsCreateWithoutPropertySubTypesInput = {
    unit_name?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    PropertyLevels: PropertyLevelsCreateNestedOneWithoutUnitLocationsInput
    PropertyUnits: PropertyUnitsCreateNestedOneWithoutUnitLocationsInput
    AreaOfWorks?: AreaOfWorksCreateNestedManyWithoutUnitLocationsInput
  }

  export type UnitLocationsUncheckedCreateWithoutPropertySubTypesInput = {
    id?: number
    unit_name?: string | null
    property_level_id: number
    property_unit_id: number
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    AreaOfWorks?: AreaOfWorksUncheckedCreateNestedManyWithoutUnitLocationsInput
  }

  export type UnitLocationsCreateOrConnectWithoutPropertySubTypesInput = {
    where: UnitLocationsWhereUniqueInput
    create: XOR<UnitLocationsCreateWithoutPropertySubTypesInput, UnitLocationsUncheckedCreateWithoutPropertySubTypesInput>
  }

  export type Property_TypesUpsertWithoutPropertySubTypesInput = {
    update: XOR<Property_TypesUpdateWithoutPropertySubTypesInput, Property_TypesUncheckedUpdateWithoutPropertySubTypesInput>
    create: XOR<Property_TypesCreateWithoutPropertySubTypesInput, Property_TypesUncheckedCreateWithoutPropertySubTypesInput>
  }

  export type Property_TypesUpdateWithoutPropertySubTypesInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type Property_TypesUncheckedUpdateWithoutPropertySubTypesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type Property_AddressesUpsertWithWhereUniqueWithoutPropertySubTypesInput = {
    where: Property_AddressesWhereUniqueInput
    update: XOR<Property_AddressesUpdateWithoutPropertySubTypesInput, Property_AddressesUncheckedUpdateWithoutPropertySubTypesInput>
    create: XOR<Property_AddressesCreateWithoutPropertySubTypesInput, Property_AddressesUncheckedCreateWithoutPropertySubTypesInput>
  }

  export type Property_AddressesUpdateWithWhereUniqueWithoutPropertySubTypesInput = {
    where: Property_AddressesWhereUniqueInput
    data: XOR<Property_AddressesUpdateWithoutPropertySubTypesInput, Property_AddressesUncheckedUpdateWithoutPropertySubTypesInput>
  }

  export type Property_AddressesUpdateManyWithWhereWithoutPropertySubTypesInput = {
    where: Property_AddressesScalarWhereInput
    data: XOR<Property_AddressesUpdateManyMutationInput, Property_AddressesUncheckedUpdateManyWithoutProperty_AddressesInput>
  }

  export type UnitLocationsUpsertWithWhereUniqueWithoutPropertySubTypesInput = {
    where: UnitLocationsWhereUniqueInput
    update: XOR<UnitLocationsUpdateWithoutPropertySubTypesInput, UnitLocationsUncheckedUpdateWithoutPropertySubTypesInput>
    create: XOR<UnitLocationsCreateWithoutPropertySubTypesInput, UnitLocationsUncheckedCreateWithoutPropertySubTypesInput>
  }

  export type UnitLocationsUpdateWithWhereUniqueWithoutPropertySubTypesInput = {
    where: UnitLocationsWhereUniqueInput
    data: XOR<UnitLocationsUpdateWithoutPropertySubTypesInput, UnitLocationsUncheckedUpdateWithoutPropertySubTypesInput>
  }

  export type UnitLocationsUpdateManyWithWhereWithoutPropertySubTypesInput = {
    where: UnitLocationsScalarWhereInput
    data: XOR<UnitLocationsUpdateManyMutationInput, UnitLocationsUncheckedUpdateManyWithoutUnitLocationsInput>
  }

  export type AttributesCreateWithoutPropertyUnitAttributesInput = {
    name?: string | null
    slug?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    Attributes?: AttributesCreateNestedOneWithoutOther_AttributesInput
    other_Attributes?: AttributesCreateNestedManyWithoutAttributesInput
    AttributeUnits?: AttributeUnitsCreateNestedManyWithoutAttributesInput
    ProductAttributeUnits?: ProductAttributeUnitsCreateNestedManyWithoutAttributesInput
  }

  export type AttributesUncheckedCreateWithoutPropertyUnitAttributesInput = {
    id?: number
    parent_id?: number | null
    name?: string | null
    slug?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    other_Attributes?: AttributesUncheckedCreateNestedManyWithoutAttributesInput
    AttributeUnits?: AttributeUnitsUncheckedCreateNestedManyWithoutAttributesInput
    ProductAttributeUnits?: ProductAttributeUnitsUncheckedCreateNestedManyWithoutAttributesInput
  }

  export type AttributesCreateOrConnectWithoutPropertyUnitAttributesInput = {
    where: AttributesWhereUniqueInput
    create: XOR<AttributesCreateWithoutPropertyUnitAttributesInput, AttributesUncheckedCreateWithoutPropertyUnitAttributesInput>
  }

  export type AttributeUnitsCreateWithoutPropertyUnitAttributesInput = {
    unit_name?: string | null
    slug?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    Attributes?: AttributesCreateNestedOneWithoutAttributeUnitsInput
    ProductAttributeUnits?: ProductAttributeUnitsCreateNestedManyWithoutAttributeUnitsInput
  }

  export type AttributeUnitsUncheckedCreateWithoutPropertyUnitAttributesInput = {
    id?: number
    attribute_parent_id?: number | null
    unit_name?: string | null
    slug?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    ProductAttributeUnits?: ProductAttributeUnitsUncheckedCreateNestedManyWithoutAttributeUnitsInput
  }

  export type AttributeUnitsCreateOrConnectWithoutPropertyUnitAttributesInput = {
    where: AttributeUnitsWhereUniqueInput
    create: XOR<AttributeUnitsCreateWithoutPropertyUnitAttributesInput, AttributeUnitsUncheckedCreateWithoutPropertyUnitAttributesInput>
  }

  export type PropertyUnitsCreateWithoutPropertyUnitAttributesInput = {
    name?: string | null
    slug?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    ProductPropertyUnits?: ProductPropertyUnitsCreateNestedManyWithoutPropertyUnitsInput
    PropertyUnitProductCategories?: PropertyUnitProductCategoriesCreateNestedManyWithoutPropertyUnitsInput
    UnitLocations?: UnitLocationsCreateNestedManyWithoutPropertyUnitsInput
  }

  export type PropertyUnitsUncheckedCreateWithoutPropertyUnitAttributesInput = {
    id?: number
    name?: string | null
    slug?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    ProductPropertyUnits?: ProductPropertyUnitsUncheckedCreateNestedManyWithoutPropertyUnitsInput
    PropertyUnitProductCategories?: PropertyUnitProductCategoriesUncheckedCreateNestedManyWithoutPropertyUnitsInput
    UnitLocations?: UnitLocationsUncheckedCreateNestedManyWithoutPropertyUnitsInput
  }

  export type PropertyUnitsCreateOrConnectWithoutPropertyUnitAttributesInput = {
    where: PropertyUnitsWhereUniqueInput
    create: XOR<PropertyUnitsCreateWithoutPropertyUnitAttributesInput, PropertyUnitsUncheckedCreateWithoutPropertyUnitAttributesInput>
  }

  export type ScopeOfWorkPropertyUnitsCreateWithoutPropertyUnitAttributesInput = {
    value?: string | null
    attribute_custom_name?: string | null
    attribute_custom_value?: string | null
    attribute_custom_unit?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    AreaOfWorks: AreaOfWorksCreateNestedOneWithoutScopeOfWorkPropertyUnitsInput
    ProjectProposals: ProjectProposalsCreateNestedOneWithoutScopeOfWorkPropertyUnitsInput
  }

  export type ScopeOfWorkPropertyUnitsUncheckedCreateWithoutPropertyUnitAttributesInput = {
    id?: number
    project_proposal_id: number
    area_of_work_id: number
    value?: string | null
    attribute_custom_name?: string | null
    attribute_custom_value?: string | null
    attribute_custom_unit?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
  }

  export type ScopeOfWorkPropertyUnitsCreateOrConnectWithoutPropertyUnitAttributesInput = {
    where: ScopeOfWorkPropertyUnitsWhereUniqueInput
    create: XOR<ScopeOfWorkPropertyUnitsCreateWithoutPropertyUnitAttributesInput, ScopeOfWorkPropertyUnitsUncheckedCreateWithoutPropertyUnitAttributesInput>
  }

  export type AttributesUpsertWithoutPropertyUnitAttributesInput = {
    update: XOR<AttributesUpdateWithoutPropertyUnitAttributesInput, AttributesUncheckedUpdateWithoutPropertyUnitAttributesInput>
    create: XOR<AttributesCreateWithoutPropertyUnitAttributesInput, AttributesUncheckedCreateWithoutPropertyUnitAttributesInput>
  }

  export type AttributesUpdateWithoutPropertyUnitAttributesInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    Attributes?: AttributesUpdateOneWithoutOther_AttributesInput
    other_Attributes?: AttributesUpdateManyWithoutAttributesInput
    AttributeUnits?: AttributeUnitsUpdateManyWithoutAttributesInput
    ProductAttributeUnits?: ProductAttributeUnitsUpdateManyWithoutAttributesInput
  }

  export type AttributesUncheckedUpdateWithoutPropertyUnitAttributesInput = {
    id?: IntFieldUpdateOperationsInput | number
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    other_Attributes?: AttributesUncheckedUpdateManyWithoutAttributesInput
    AttributeUnits?: AttributeUnitsUncheckedUpdateManyWithoutAttributesInput
    ProductAttributeUnits?: ProductAttributeUnitsUncheckedUpdateManyWithoutAttributesInput
  }

  export type AttributeUnitsUpsertWithoutPropertyUnitAttributesInput = {
    update: XOR<AttributeUnitsUpdateWithoutPropertyUnitAttributesInput, AttributeUnitsUncheckedUpdateWithoutPropertyUnitAttributesInput>
    create: XOR<AttributeUnitsCreateWithoutPropertyUnitAttributesInput, AttributeUnitsUncheckedCreateWithoutPropertyUnitAttributesInput>
  }

  export type AttributeUnitsUpdateWithoutPropertyUnitAttributesInput = {
    unit_name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    Attributes?: AttributesUpdateOneWithoutAttributeUnitsInput
    ProductAttributeUnits?: ProductAttributeUnitsUpdateManyWithoutAttributeUnitsInput
  }

  export type AttributeUnitsUncheckedUpdateWithoutPropertyUnitAttributesInput = {
    id?: IntFieldUpdateOperationsInput | number
    attribute_parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    unit_name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    ProductAttributeUnits?: ProductAttributeUnitsUncheckedUpdateManyWithoutAttributeUnitsInput
  }

  export type PropertyUnitsUpsertWithoutPropertyUnitAttributesInput = {
    update: XOR<PropertyUnitsUpdateWithoutPropertyUnitAttributesInput, PropertyUnitsUncheckedUpdateWithoutPropertyUnitAttributesInput>
    create: XOR<PropertyUnitsCreateWithoutPropertyUnitAttributesInput, PropertyUnitsUncheckedCreateWithoutPropertyUnitAttributesInput>
  }

  export type PropertyUnitsUpdateWithoutPropertyUnitAttributesInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    ProductPropertyUnits?: ProductPropertyUnitsUpdateManyWithoutPropertyUnitsInput
    PropertyUnitProductCategories?: PropertyUnitProductCategoriesUpdateManyWithoutPropertyUnitsInput
    UnitLocations?: UnitLocationsUpdateManyWithoutPropertyUnitsInput
  }

  export type PropertyUnitsUncheckedUpdateWithoutPropertyUnitAttributesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    ProductPropertyUnits?: ProductPropertyUnitsUncheckedUpdateManyWithoutPropertyUnitsInput
    PropertyUnitProductCategories?: PropertyUnitProductCategoriesUncheckedUpdateManyWithoutPropertyUnitsInput
    UnitLocations?: UnitLocationsUncheckedUpdateManyWithoutPropertyUnitsInput
  }

  export type ScopeOfWorkPropertyUnitsUpsertWithWhereUniqueWithoutPropertyUnitAttributesInput = {
    where: ScopeOfWorkPropertyUnitsWhereUniqueInput
    update: XOR<ScopeOfWorkPropertyUnitsUpdateWithoutPropertyUnitAttributesInput, ScopeOfWorkPropertyUnitsUncheckedUpdateWithoutPropertyUnitAttributesInput>
    create: XOR<ScopeOfWorkPropertyUnitsCreateWithoutPropertyUnitAttributesInput, ScopeOfWorkPropertyUnitsUncheckedCreateWithoutPropertyUnitAttributesInput>
  }

  export type ScopeOfWorkPropertyUnitsUpdateWithWhereUniqueWithoutPropertyUnitAttributesInput = {
    where: ScopeOfWorkPropertyUnitsWhereUniqueInput
    data: XOR<ScopeOfWorkPropertyUnitsUpdateWithoutPropertyUnitAttributesInput, ScopeOfWorkPropertyUnitsUncheckedUpdateWithoutPropertyUnitAttributesInput>
  }

  export type ScopeOfWorkPropertyUnitsUpdateManyWithWhereWithoutPropertyUnitAttributesInput = {
    where: ScopeOfWorkPropertyUnitsScalarWhereInput
    data: XOR<ScopeOfWorkPropertyUnitsUpdateManyMutationInput, ScopeOfWorkPropertyUnitsUncheckedUpdateManyWithoutScopeOfWorkPropertyUnitsInput>
  }

  export type ProductCategoriesCreateWithoutPropertyUnitProductCategoriesInput = {
    name?: string | null
    slug?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
  }

  export type ProductCategoriesUncheckedCreateWithoutPropertyUnitProductCategoriesInput = {
    id?: number
    name?: string | null
    slug?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
  }

  export type ProductCategoriesCreateOrConnectWithoutPropertyUnitProductCategoriesInput = {
    where: ProductCategoriesWhereUniqueInput
    create: XOR<ProductCategoriesCreateWithoutPropertyUnitProductCategoriesInput, ProductCategoriesUncheckedCreateWithoutPropertyUnitProductCategoriesInput>
  }

  export type PropertyUnitsCreateWithoutPropertyUnitProductCategoriesInput = {
    name?: string | null
    slug?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    ProductPropertyUnits?: ProductPropertyUnitsCreateNestedManyWithoutPropertyUnitsInput
    PropertyUnitAttributes?: PropertyUnitAttributesCreateNestedManyWithoutPropertyUnitsInput
    UnitLocations?: UnitLocationsCreateNestedManyWithoutPropertyUnitsInput
  }

  export type PropertyUnitsUncheckedCreateWithoutPropertyUnitProductCategoriesInput = {
    id?: number
    name?: string | null
    slug?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    ProductPropertyUnits?: ProductPropertyUnitsUncheckedCreateNestedManyWithoutPropertyUnitsInput
    PropertyUnitAttributes?: PropertyUnitAttributesUncheckedCreateNestedManyWithoutPropertyUnitsInput
    UnitLocations?: UnitLocationsUncheckedCreateNestedManyWithoutPropertyUnitsInput
  }

  export type PropertyUnitsCreateOrConnectWithoutPropertyUnitProductCategoriesInput = {
    where: PropertyUnitsWhereUniqueInput
    create: XOR<PropertyUnitsCreateWithoutPropertyUnitProductCategoriesInput, PropertyUnitsUncheckedCreateWithoutPropertyUnitProductCategoriesInput>
  }

  export type PropertyUnitProductCategoryProductsCreateWithoutPropertyUnitProductCategoriesInput = {
    display_order?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    Products: ProductsCreateNestedOneWithoutPropertyUnitProductCategoryProductsInput
  }

  export type PropertyUnitProductCategoryProductsUncheckedCreateWithoutPropertyUnitProductCategoriesInput = {
    id?: number
    product_id: number
    display_order?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
  }

  export type PropertyUnitProductCategoryProductsCreateOrConnectWithoutPropertyUnitProductCategoriesInput = {
    where: PropertyUnitProductCategoryProductsWhereUniqueInput
    create: XOR<PropertyUnitProductCategoryProductsCreateWithoutPropertyUnitProductCategoriesInput, PropertyUnitProductCategoryProductsUncheckedCreateWithoutPropertyUnitProductCategoriesInput>
  }

  export type ProductCategoriesUpsertWithoutPropertyUnitProductCategoriesInput = {
    update: XOR<ProductCategoriesUpdateWithoutPropertyUnitProductCategoriesInput, ProductCategoriesUncheckedUpdateWithoutPropertyUnitProductCategoriesInput>
    create: XOR<ProductCategoriesCreateWithoutPropertyUnitProductCategoriesInput, ProductCategoriesUncheckedCreateWithoutPropertyUnitProductCategoriesInput>
  }

  export type ProductCategoriesUpdateWithoutPropertyUnitProductCategoriesInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProductCategoriesUncheckedUpdateWithoutPropertyUnitProductCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PropertyUnitsUpsertWithoutPropertyUnitProductCategoriesInput = {
    update: XOR<PropertyUnitsUpdateWithoutPropertyUnitProductCategoriesInput, PropertyUnitsUncheckedUpdateWithoutPropertyUnitProductCategoriesInput>
    create: XOR<PropertyUnitsCreateWithoutPropertyUnitProductCategoriesInput, PropertyUnitsUncheckedCreateWithoutPropertyUnitProductCategoriesInput>
  }

  export type PropertyUnitsUpdateWithoutPropertyUnitProductCategoriesInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    ProductPropertyUnits?: ProductPropertyUnitsUpdateManyWithoutPropertyUnitsInput
    PropertyUnitAttributes?: PropertyUnitAttributesUpdateManyWithoutPropertyUnitsInput
    UnitLocations?: UnitLocationsUpdateManyWithoutPropertyUnitsInput
  }

  export type PropertyUnitsUncheckedUpdateWithoutPropertyUnitProductCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    ProductPropertyUnits?: ProductPropertyUnitsUncheckedUpdateManyWithoutPropertyUnitsInput
    PropertyUnitAttributes?: PropertyUnitAttributesUncheckedUpdateManyWithoutPropertyUnitsInput
    UnitLocations?: UnitLocationsUncheckedUpdateManyWithoutPropertyUnitsInput
  }

  export type PropertyUnitProductCategoryProductsUpsertWithWhereUniqueWithoutPropertyUnitProductCategoriesInput = {
    where: PropertyUnitProductCategoryProductsWhereUniqueInput
    update: XOR<PropertyUnitProductCategoryProductsUpdateWithoutPropertyUnitProductCategoriesInput, PropertyUnitProductCategoryProductsUncheckedUpdateWithoutPropertyUnitProductCategoriesInput>
    create: XOR<PropertyUnitProductCategoryProductsCreateWithoutPropertyUnitProductCategoriesInput, PropertyUnitProductCategoryProductsUncheckedCreateWithoutPropertyUnitProductCategoriesInput>
  }

  export type PropertyUnitProductCategoryProductsUpdateWithWhereUniqueWithoutPropertyUnitProductCategoriesInput = {
    where: PropertyUnitProductCategoryProductsWhereUniqueInput
    data: XOR<PropertyUnitProductCategoryProductsUpdateWithoutPropertyUnitProductCategoriesInput, PropertyUnitProductCategoryProductsUncheckedUpdateWithoutPropertyUnitProductCategoriesInput>
  }

  export type PropertyUnitProductCategoryProductsUpdateManyWithWhereWithoutPropertyUnitProductCategoriesInput = {
    where: PropertyUnitProductCategoryProductsScalarWhereInput
    data: XOR<PropertyUnitProductCategoryProductsUpdateManyMutationInput, PropertyUnitProductCategoryProductsUncheckedUpdateManyWithoutPropertyUnitProductCategoryProductsInput>
  }

  export type ProductsCreateWithoutPropertyUnitProductCategoryProductsInput = {
    name?: string | null
    slug?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    Products?: ProductsCreateNestedOneWithoutOther_ProductsInput
    ProductAttributeUnits?: ProductAttributeUnitsCreateNestedManyWithoutProductsInput
    ProductPropertyUnits?: ProductPropertyUnitsCreateNestedManyWithoutProductsInput
    other_Products?: ProductsCreateNestedManyWithoutProductsInput
  }

  export type ProductsUncheckedCreateWithoutPropertyUnitProductCategoryProductsInput = {
    id?: number
    parent_id?: number | null
    name?: string | null
    slug?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    ProductAttributeUnits?: ProductAttributeUnitsUncheckedCreateNestedManyWithoutProductsInput
    ProductPropertyUnits?: ProductPropertyUnitsUncheckedCreateNestedManyWithoutProductsInput
    other_Products?: ProductsUncheckedCreateNestedManyWithoutProductsInput
  }

  export type ProductsCreateOrConnectWithoutPropertyUnitProductCategoryProductsInput = {
    where: ProductsWhereUniqueInput
    create: XOR<ProductsCreateWithoutPropertyUnitProductCategoryProductsInput, ProductsUncheckedCreateWithoutPropertyUnitProductCategoryProductsInput>
  }

  export type PropertyUnitProductCategoriesCreateWithoutPropertyUnitProductCategoryProductsInput = {
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    ProductCategories: ProductCategoriesCreateNestedOneWithoutPropertyUnitProductCategoriesInput
    PropertyUnits: PropertyUnitsCreateNestedOneWithoutPropertyUnitProductCategoriesInput
  }

  export type PropertyUnitProductCategoriesUncheckedCreateWithoutPropertyUnitProductCategoryProductsInput = {
    id?: number
    property_unit_id: number
    product_category_id: number
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
  }

  export type PropertyUnitProductCategoriesCreateOrConnectWithoutPropertyUnitProductCategoryProductsInput = {
    where: PropertyUnitProductCategoriesWhereUniqueInput
    create: XOR<PropertyUnitProductCategoriesCreateWithoutPropertyUnitProductCategoryProductsInput, PropertyUnitProductCategoriesUncheckedCreateWithoutPropertyUnitProductCategoryProductsInput>
  }

  export type ProductsUpsertWithoutPropertyUnitProductCategoryProductsInput = {
    update: XOR<ProductsUpdateWithoutPropertyUnitProductCategoryProductsInput, ProductsUncheckedUpdateWithoutPropertyUnitProductCategoryProductsInput>
    create: XOR<ProductsCreateWithoutPropertyUnitProductCategoryProductsInput, ProductsUncheckedCreateWithoutPropertyUnitProductCategoryProductsInput>
  }

  export type ProductsUpdateWithoutPropertyUnitProductCategoryProductsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    Products?: ProductsUpdateOneWithoutOther_ProductsInput
    ProductAttributeUnits?: ProductAttributeUnitsUpdateManyWithoutProductsInput
    ProductPropertyUnits?: ProductPropertyUnitsUpdateManyWithoutProductsInput
    other_Products?: ProductsUpdateManyWithoutProductsInput
  }

  export type ProductsUncheckedUpdateWithoutPropertyUnitProductCategoryProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    ProductAttributeUnits?: ProductAttributeUnitsUncheckedUpdateManyWithoutProductsInput
    ProductPropertyUnits?: ProductPropertyUnitsUncheckedUpdateManyWithoutProductsInput
    other_Products?: ProductsUncheckedUpdateManyWithoutProductsInput
  }

  export type PropertyUnitProductCategoriesUpsertWithoutPropertyUnitProductCategoryProductsInput = {
    update: XOR<PropertyUnitProductCategoriesUpdateWithoutPropertyUnitProductCategoryProductsInput, PropertyUnitProductCategoriesUncheckedUpdateWithoutPropertyUnitProductCategoryProductsInput>
    create: XOR<PropertyUnitProductCategoriesCreateWithoutPropertyUnitProductCategoryProductsInput, PropertyUnitProductCategoriesUncheckedCreateWithoutPropertyUnitProductCategoryProductsInput>
  }

  export type PropertyUnitProductCategoriesUpdateWithoutPropertyUnitProductCategoryProductsInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    ProductCategories?: ProductCategoriesUpdateOneRequiredWithoutPropertyUnitProductCategoriesInput
    PropertyUnits?: PropertyUnitsUpdateOneRequiredWithoutPropertyUnitProductCategoriesInput
  }

  export type PropertyUnitProductCategoriesUncheckedUpdateWithoutPropertyUnitProductCategoryProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    property_unit_id?: IntFieldUpdateOperationsInput | number
    product_category_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProductPropertyUnitsCreateWithoutPropertyUnitsInput = {
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    Products: ProductsCreateNestedOneWithoutProductPropertyUnitsInput
  }

  export type ProductPropertyUnitsUncheckedCreateWithoutPropertyUnitsInput = {
    id?: number
    product_id: number
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
  }

  export type ProductPropertyUnitsCreateOrConnectWithoutPropertyUnitsInput = {
    where: ProductPropertyUnitsWhereUniqueInput
    create: XOR<ProductPropertyUnitsCreateWithoutPropertyUnitsInput, ProductPropertyUnitsUncheckedCreateWithoutPropertyUnitsInput>
  }

  export type PropertyUnitAttributesCreateWithoutPropertyUnitsInput = {
    html_element_type?: string | null
    display_order?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    Attributes: AttributesCreateNestedOneWithoutPropertyUnitAttributesInput
    AttributeUnits: AttributeUnitsCreateNestedOneWithoutPropertyUnitAttributesInput
    ScopeOfWorkPropertyUnits?: ScopeOfWorkPropertyUnitsCreateNestedManyWithoutPropertyUnitAttributesInput
  }

  export type PropertyUnitAttributesUncheckedCreateWithoutPropertyUnitsInput = {
    id?: number
    attribute_id: number
    attribute_unit_id: number
    html_element_type?: string | null
    display_order?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    ScopeOfWorkPropertyUnits?: ScopeOfWorkPropertyUnitsUncheckedCreateNestedManyWithoutPropertyUnitAttributesInput
  }

  export type PropertyUnitAttributesCreateOrConnectWithoutPropertyUnitsInput = {
    where: PropertyUnitAttributesWhereUniqueInput
    create: XOR<PropertyUnitAttributesCreateWithoutPropertyUnitsInput, PropertyUnitAttributesUncheckedCreateWithoutPropertyUnitsInput>
  }

  export type PropertyUnitProductCategoriesCreateWithoutPropertyUnitsInput = {
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    ProductCategories: ProductCategoriesCreateNestedOneWithoutPropertyUnitProductCategoriesInput
    PropertyUnitProductCategoryProducts?: PropertyUnitProductCategoryProductsCreateNestedManyWithoutPropertyUnitProductCategoriesInput
  }

  export type PropertyUnitProductCategoriesUncheckedCreateWithoutPropertyUnitsInput = {
    id?: number
    product_category_id: number
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    PropertyUnitProductCategoryProducts?: PropertyUnitProductCategoryProductsUncheckedCreateNestedManyWithoutPropertyUnitProductCategoriesInput
  }

  export type PropertyUnitProductCategoriesCreateOrConnectWithoutPropertyUnitsInput = {
    where: PropertyUnitProductCategoriesWhereUniqueInput
    create: XOR<PropertyUnitProductCategoriesCreateWithoutPropertyUnitsInput, PropertyUnitProductCategoriesUncheckedCreateWithoutPropertyUnitsInput>
  }

  export type UnitLocationsCreateWithoutPropertyUnitsInput = {
    unit_name?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    PropertyLevels: PropertyLevelsCreateNestedOneWithoutUnitLocationsInput
    PropertySubTypes: PropertySubTypesCreateNestedOneWithoutUnitLocationsInput
    AreaOfWorks?: AreaOfWorksCreateNestedManyWithoutUnitLocationsInput
  }

  export type UnitLocationsUncheckedCreateWithoutPropertyUnitsInput = {
    id?: number
    unit_name?: string | null
    property_sub_type_id: number
    property_level_id: number
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    AreaOfWorks?: AreaOfWorksUncheckedCreateNestedManyWithoutUnitLocationsInput
  }

  export type UnitLocationsCreateOrConnectWithoutPropertyUnitsInput = {
    where: UnitLocationsWhereUniqueInput
    create: XOR<UnitLocationsCreateWithoutPropertyUnitsInput, UnitLocationsUncheckedCreateWithoutPropertyUnitsInput>
  }

  export type ProductPropertyUnitsUpsertWithWhereUniqueWithoutPropertyUnitsInput = {
    where: ProductPropertyUnitsWhereUniqueInput
    update: XOR<ProductPropertyUnitsUpdateWithoutPropertyUnitsInput, ProductPropertyUnitsUncheckedUpdateWithoutPropertyUnitsInput>
    create: XOR<ProductPropertyUnitsCreateWithoutPropertyUnitsInput, ProductPropertyUnitsUncheckedCreateWithoutPropertyUnitsInput>
  }

  export type ProductPropertyUnitsUpdateWithWhereUniqueWithoutPropertyUnitsInput = {
    where: ProductPropertyUnitsWhereUniqueInput
    data: XOR<ProductPropertyUnitsUpdateWithoutPropertyUnitsInput, ProductPropertyUnitsUncheckedUpdateWithoutPropertyUnitsInput>
  }

  export type ProductPropertyUnitsUpdateManyWithWhereWithoutPropertyUnitsInput = {
    where: ProductPropertyUnitsScalarWhereInput
    data: XOR<ProductPropertyUnitsUpdateManyMutationInput, ProductPropertyUnitsUncheckedUpdateManyWithoutProductPropertyUnitsInput>
  }

  export type PropertyUnitAttributesUpsertWithWhereUniqueWithoutPropertyUnitsInput = {
    where: PropertyUnitAttributesWhereUniqueInput
    update: XOR<PropertyUnitAttributesUpdateWithoutPropertyUnitsInput, PropertyUnitAttributesUncheckedUpdateWithoutPropertyUnitsInput>
    create: XOR<PropertyUnitAttributesCreateWithoutPropertyUnitsInput, PropertyUnitAttributesUncheckedCreateWithoutPropertyUnitsInput>
  }

  export type PropertyUnitAttributesUpdateWithWhereUniqueWithoutPropertyUnitsInput = {
    where: PropertyUnitAttributesWhereUniqueInput
    data: XOR<PropertyUnitAttributesUpdateWithoutPropertyUnitsInput, PropertyUnitAttributesUncheckedUpdateWithoutPropertyUnitsInput>
  }

  export type PropertyUnitAttributesUpdateManyWithWhereWithoutPropertyUnitsInput = {
    where: PropertyUnitAttributesScalarWhereInput
    data: XOR<PropertyUnitAttributesUpdateManyMutationInput, PropertyUnitAttributesUncheckedUpdateManyWithoutPropertyUnitAttributesInput>
  }

  export type PropertyUnitProductCategoriesUpsertWithWhereUniqueWithoutPropertyUnitsInput = {
    where: PropertyUnitProductCategoriesWhereUniqueInput
    update: XOR<PropertyUnitProductCategoriesUpdateWithoutPropertyUnitsInput, PropertyUnitProductCategoriesUncheckedUpdateWithoutPropertyUnitsInput>
    create: XOR<PropertyUnitProductCategoriesCreateWithoutPropertyUnitsInput, PropertyUnitProductCategoriesUncheckedCreateWithoutPropertyUnitsInput>
  }

  export type PropertyUnitProductCategoriesUpdateWithWhereUniqueWithoutPropertyUnitsInput = {
    where: PropertyUnitProductCategoriesWhereUniqueInput
    data: XOR<PropertyUnitProductCategoriesUpdateWithoutPropertyUnitsInput, PropertyUnitProductCategoriesUncheckedUpdateWithoutPropertyUnitsInput>
  }

  export type PropertyUnitProductCategoriesUpdateManyWithWhereWithoutPropertyUnitsInput = {
    where: PropertyUnitProductCategoriesScalarWhereInput
    data: XOR<PropertyUnitProductCategoriesUpdateManyMutationInput, PropertyUnitProductCategoriesUncheckedUpdateManyWithoutPropertyUnitProductCategoriesInput>
  }

  export type UnitLocationsUpsertWithWhereUniqueWithoutPropertyUnitsInput = {
    where: UnitLocationsWhereUniqueInput
    update: XOR<UnitLocationsUpdateWithoutPropertyUnitsInput, UnitLocationsUncheckedUpdateWithoutPropertyUnitsInput>
    create: XOR<UnitLocationsCreateWithoutPropertyUnitsInput, UnitLocationsUncheckedCreateWithoutPropertyUnitsInput>
  }

  export type UnitLocationsUpdateWithWhereUniqueWithoutPropertyUnitsInput = {
    where: UnitLocationsWhereUniqueInput
    data: XOR<UnitLocationsUpdateWithoutPropertyUnitsInput, UnitLocationsUncheckedUpdateWithoutPropertyUnitsInput>
  }

  export type UnitLocationsUpdateManyWithWhereWithoutPropertyUnitsInput = {
    where: UnitLocationsScalarWhereInput
    data: XOR<UnitLocationsUpdateManyMutationInput, UnitLocationsUncheckedUpdateManyWithoutUnitLocationsInput>
  }

  export type CitiesCreateWithoutProperty_AddressesInput = {
    name: string
    status?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    States: StatesCreateNestedOneWithoutCitiesInput
  }

  export type CitiesUncheckedCreateWithoutProperty_AddressesInput = {
    id?: number
    state_id: number
    name: string
    status?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
  }

  export type CitiesCreateOrConnectWithoutProperty_AddressesInput = {
    where: CitiesWhereUniqueInput
    create: XOR<CitiesCreateWithoutProperty_AddressesInput, CitiesUncheckedCreateWithoutProperty_AddressesInput>
  }

  export type PropertyOwnersCreateWithoutProperty_AddressesInput = {
    first_name?: string | null
    last_name?: string | null
    mobile?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    Users: UsersCreateNestedOneWithoutPropertyOwnersInput
  }

  export type PropertyOwnersUncheckedCreateWithoutProperty_AddressesInput = {
    id?: number
    user_id: number
    first_name?: string | null
    last_name?: string | null
    mobile?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
  }

  export type PropertyOwnersCreateOrConnectWithoutProperty_AddressesInput = {
    where: PropertyOwnersWhereUniqueInput
    create: XOR<PropertyOwnersCreateWithoutProperty_AddressesInput, PropertyOwnersUncheckedCreateWithoutProperty_AddressesInput>
  }

  export type PropertySubTypesCreateWithoutProperty_AddressesInput = {
    name: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    Property_Types: Property_TypesCreateNestedOneWithoutPropertySubTypesInput
    UnitLocations?: UnitLocationsCreateNestedManyWithoutPropertySubTypesInput
  }

  export type PropertySubTypesUncheckedCreateWithoutProperty_AddressesInput = {
    id?: number
    property_type_id: number
    name: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    UnitLocations?: UnitLocationsUncheckedCreateNestedManyWithoutPropertySubTypesInput
  }

  export type PropertySubTypesCreateOrConnectWithoutProperty_AddressesInput = {
    where: PropertySubTypesWhereUniqueInput
    create: XOR<PropertySubTypesCreateWithoutProperty_AddressesInput, PropertySubTypesUncheckedCreateWithoutProperty_AddressesInput>
  }

  export type ProjectsCreateWithoutProperty_AddressesInput = {
    name?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    start_date?: Date | string
    ProjectProposals?: ProjectProposalsCreateNestedManyWithoutProjectsInput
    ProjectTypeAssociations?: ProjectTypeAssociationsCreateNestedManyWithoutProjectsInput
  }

  export type ProjectsUncheckedCreateWithoutProperty_AddressesInput = {
    id?: number
    name?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    start_date?: Date | string
    ProjectProposals?: ProjectProposalsUncheckedCreateNestedManyWithoutProjectsInput
    ProjectTypeAssociations?: ProjectTypeAssociationsUncheckedCreateNestedManyWithoutProjectsInput
  }

  export type ProjectsCreateOrConnectWithoutProperty_AddressesInput = {
    where: ProjectsWhereUniqueInput
    create: XOR<ProjectsCreateWithoutProperty_AddressesInput, ProjectsUncheckedCreateWithoutProperty_AddressesInput>
  }

  export type CitiesUpsertWithoutProperty_AddressesInput = {
    update: XOR<CitiesUpdateWithoutProperty_AddressesInput, CitiesUncheckedUpdateWithoutProperty_AddressesInput>
    create: XOR<CitiesCreateWithoutProperty_AddressesInput, CitiesUncheckedCreateWithoutProperty_AddressesInput>
  }

  export type CitiesUpdateWithoutProperty_AddressesInput = {
    name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    States?: StatesUpdateOneRequiredWithoutCitiesInput
  }

  export type CitiesUncheckedUpdateWithoutProperty_AddressesInput = {
    id?: IntFieldUpdateOperationsInput | number
    state_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PropertyOwnersUpsertWithoutProperty_AddressesInput = {
    update: XOR<PropertyOwnersUpdateWithoutProperty_AddressesInput, PropertyOwnersUncheckedUpdateWithoutProperty_AddressesInput>
    create: XOR<PropertyOwnersCreateWithoutProperty_AddressesInput, PropertyOwnersUncheckedCreateWithoutProperty_AddressesInput>
  }

  export type PropertyOwnersUpdateWithoutProperty_AddressesInput = {
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    Users?: UsersUpdateOneRequiredWithoutPropertyOwnersInput
  }

  export type PropertyOwnersUncheckedUpdateWithoutProperty_AddressesInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PropertySubTypesUpsertWithoutProperty_AddressesInput = {
    update: XOR<PropertySubTypesUpdateWithoutProperty_AddressesInput, PropertySubTypesUncheckedUpdateWithoutProperty_AddressesInput>
    create: XOR<PropertySubTypesCreateWithoutProperty_AddressesInput, PropertySubTypesUncheckedCreateWithoutProperty_AddressesInput>
  }

  export type PropertySubTypesUpdateWithoutProperty_AddressesInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    Property_Types?: Property_TypesUpdateOneRequiredWithoutPropertySubTypesInput
    UnitLocations?: UnitLocationsUpdateManyWithoutPropertySubTypesInput
  }

  export type PropertySubTypesUncheckedUpdateWithoutProperty_AddressesInput = {
    id?: IntFieldUpdateOperationsInput | number
    property_type_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    UnitLocations?: UnitLocationsUncheckedUpdateManyWithoutPropertySubTypesInput
  }

  export type ProjectsUpsertWithWhereUniqueWithoutProperty_AddressesInput = {
    where: ProjectsWhereUniqueInput
    update: XOR<ProjectsUpdateWithoutProperty_AddressesInput, ProjectsUncheckedUpdateWithoutProperty_AddressesInput>
    create: XOR<ProjectsCreateWithoutProperty_AddressesInput, ProjectsUncheckedCreateWithoutProperty_AddressesInput>
  }

  export type ProjectsUpdateWithWhereUniqueWithoutProperty_AddressesInput = {
    where: ProjectsWhereUniqueInput
    data: XOR<ProjectsUpdateWithoutProperty_AddressesInput, ProjectsUncheckedUpdateWithoutProperty_AddressesInput>
  }

  export type ProjectsUpdateManyWithWhereWithoutProperty_AddressesInput = {
    where: ProjectsScalarWhereInput
    data: XOR<ProjectsUpdateManyMutationInput, ProjectsUncheckedUpdateManyWithoutProjectsInput>
  }

  export type ProjectsScalarWhereInput = {
    AND?: Enumerable<ProjectsScalarWhereInput>
    OR?: Enumerable<ProjectsScalarWhereInput>
    NOT?: Enumerable<ProjectsScalarWhereInput>
    id?: IntFilter | number
    name?: StringNullableFilter | string | null
    property_address_id?: IntFilter | number
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    created_by?: IntNullableFilter | number | null
    updated_by?: IntNullableFilter | number | null
    start_date?: DateTimeFilter | Date | string
  }

  export type PropertySubTypesCreateWithoutProperty_TypesInput = {
    name: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    Property_Addresses?: Property_AddressesCreateNestedManyWithoutPropertySubTypesInput
    UnitLocations?: UnitLocationsCreateNestedManyWithoutPropertySubTypesInput
  }

  export type PropertySubTypesUncheckedCreateWithoutProperty_TypesInput = {
    id?: number
    name: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    Property_Addresses?: Property_AddressesUncheckedCreateNestedManyWithoutPropertySubTypesInput
    UnitLocations?: UnitLocationsUncheckedCreateNestedManyWithoutPropertySubTypesInput
  }

  export type PropertySubTypesCreateOrConnectWithoutProperty_TypesInput = {
    where: PropertySubTypesWhereUniqueInput
    create: XOR<PropertySubTypesCreateWithoutProperty_TypesInput, PropertySubTypesUncheckedCreateWithoutProperty_TypesInput>
  }

  export type PropertySubTypesUpsertWithWhereUniqueWithoutProperty_TypesInput = {
    where: PropertySubTypesWhereUniqueInput
    update: XOR<PropertySubTypesUpdateWithoutProperty_TypesInput, PropertySubTypesUncheckedUpdateWithoutProperty_TypesInput>
    create: XOR<PropertySubTypesCreateWithoutProperty_TypesInput, PropertySubTypesUncheckedCreateWithoutProperty_TypesInput>
  }

  export type PropertySubTypesUpdateWithWhereUniqueWithoutProperty_TypesInput = {
    where: PropertySubTypesWhereUniqueInput
    data: XOR<PropertySubTypesUpdateWithoutProperty_TypesInput, PropertySubTypesUncheckedUpdateWithoutProperty_TypesInput>
  }

  export type PropertySubTypesUpdateManyWithWhereWithoutProperty_TypesInput = {
    where: PropertySubTypesScalarWhereInput
    data: XOR<PropertySubTypesUpdateManyMutationInput, PropertySubTypesUncheckedUpdateManyWithoutPropertySubTypesInput>
  }

  export type PropertySubTypesScalarWhereInput = {
    AND?: Enumerable<PropertySubTypesScalarWhereInput>
    OR?: Enumerable<PropertySubTypesScalarWhereInput>
    NOT?: Enumerable<PropertySubTypesScalarWhereInput>
    id?: IntFilter | number
    property_type_id?: IntFilter | number
    name?: StringFilter | string
    slug?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    created_by?: IntNullableFilter | number | null
    updated_by?: IntNullableFilter | number | null
  }

  export type AreaOfWorksCreateWithoutScopeOfWorkPropertyUnitsInput = {
    new_unit?: string | null
    existing_unit?: string | null
    unit_alias?: string | null
    work_type?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    ProjectProposals: ProjectProposalsCreateNestedOneWithoutAreaOfWorksInput
    UnitLocations: UnitLocationsCreateNestedOneWithoutAreaOfWorksInput
    ScopeOfWorks?: ScopeOfWorksCreateNestedManyWithoutAreaOfWorksInput
  }

  export type AreaOfWorksUncheckedCreateWithoutScopeOfWorkPropertyUnitsInput = {
    id?: number
    project_proposal_id: number
    unit_location_id: number
    new_unit?: string | null
    existing_unit?: string | null
    unit_alias?: string | null
    work_type?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    ScopeOfWorks?: ScopeOfWorksUncheckedCreateNestedManyWithoutAreaOfWorksInput
  }

  export type AreaOfWorksCreateOrConnectWithoutScopeOfWorkPropertyUnitsInput = {
    where: AreaOfWorksWhereUniqueInput
    create: XOR<AreaOfWorksCreateWithoutScopeOfWorkPropertyUnitsInput, AreaOfWorksUncheckedCreateWithoutScopeOfWorkPropertyUnitsInput>
  }

  export type ProjectProposalsCreateWithoutScopeOfWorkPropertyUnitsInput = {
    name?: string | null
    proposal_status?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    Projects: ProjectsCreateNestedOneWithoutProjectProposalsInput
    AreaOfWorks?: AreaOfWorksCreateNestedManyWithoutProjectProposalsInput
    ScopeOfWorks?: ScopeOfWorksCreateNestedManyWithoutProjectProposalsInput
  }

  export type ProjectProposalsUncheckedCreateWithoutScopeOfWorkPropertyUnitsInput = {
    id?: number
    name?: string | null
    project_id: number
    proposal_status?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    AreaOfWorks?: AreaOfWorksUncheckedCreateNestedManyWithoutProjectProposalsInput
    ScopeOfWorks?: ScopeOfWorksUncheckedCreateNestedManyWithoutProjectProposalsInput
  }

  export type ProjectProposalsCreateOrConnectWithoutScopeOfWorkPropertyUnitsInput = {
    where: ProjectProposalsWhereUniqueInput
    create: XOR<ProjectProposalsCreateWithoutScopeOfWorkPropertyUnitsInput, ProjectProposalsUncheckedCreateWithoutScopeOfWorkPropertyUnitsInput>
  }

  export type PropertyUnitAttributesCreateWithoutScopeOfWorkPropertyUnitsInput = {
    html_element_type?: string | null
    display_order?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    Attributes: AttributesCreateNestedOneWithoutPropertyUnitAttributesInput
    AttributeUnits: AttributeUnitsCreateNestedOneWithoutPropertyUnitAttributesInput
    PropertyUnits: PropertyUnitsCreateNestedOneWithoutPropertyUnitAttributesInput
  }

  export type PropertyUnitAttributesUncheckedCreateWithoutScopeOfWorkPropertyUnitsInput = {
    id?: number
    property_unit_id: number
    attribute_id: number
    attribute_unit_id: number
    html_element_type?: string | null
    display_order?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
  }

  export type PropertyUnitAttributesCreateOrConnectWithoutScopeOfWorkPropertyUnitsInput = {
    where: PropertyUnitAttributesWhereUniqueInput
    create: XOR<PropertyUnitAttributesCreateWithoutScopeOfWorkPropertyUnitsInput, PropertyUnitAttributesUncheckedCreateWithoutScopeOfWorkPropertyUnitsInput>
  }

  export type AreaOfWorksUpsertWithoutScopeOfWorkPropertyUnitsInput = {
    update: XOR<AreaOfWorksUpdateWithoutScopeOfWorkPropertyUnitsInput, AreaOfWorksUncheckedUpdateWithoutScopeOfWorkPropertyUnitsInput>
    create: XOR<AreaOfWorksCreateWithoutScopeOfWorkPropertyUnitsInput, AreaOfWorksUncheckedCreateWithoutScopeOfWorkPropertyUnitsInput>
  }

  export type AreaOfWorksUpdateWithoutScopeOfWorkPropertyUnitsInput = {
    new_unit?: NullableStringFieldUpdateOperationsInput | string | null
    existing_unit?: NullableStringFieldUpdateOperationsInput | string | null
    unit_alias?: NullableStringFieldUpdateOperationsInput | string | null
    work_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    ProjectProposals?: ProjectProposalsUpdateOneRequiredWithoutAreaOfWorksInput
    UnitLocations?: UnitLocationsUpdateOneRequiredWithoutAreaOfWorksInput
    ScopeOfWorks?: ScopeOfWorksUpdateManyWithoutAreaOfWorksInput
  }

  export type AreaOfWorksUncheckedUpdateWithoutScopeOfWorkPropertyUnitsInput = {
    id?: IntFieldUpdateOperationsInput | number
    project_proposal_id?: IntFieldUpdateOperationsInput | number
    unit_location_id?: IntFieldUpdateOperationsInput | number
    new_unit?: NullableStringFieldUpdateOperationsInput | string | null
    existing_unit?: NullableStringFieldUpdateOperationsInput | string | null
    unit_alias?: NullableStringFieldUpdateOperationsInput | string | null
    work_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    ScopeOfWorks?: ScopeOfWorksUncheckedUpdateManyWithoutAreaOfWorksInput
  }

  export type ProjectProposalsUpsertWithoutScopeOfWorkPropertyUnitsInput = {
    update: XOR<ProjectProposalsUpdateWithoutScopeOfWorkPropertyUnitsInput, ProjectProposalsUncheckedUpdateWithoutScopeOfWorkPropertyUnitsInput>
    create: XOR<ProjectProposalsCreateWithoutScopeOfWorkPropertyUnitsInput, ProjectProposalsUncheckedCreateWithoutScopeOfWorkPropertyUnitsInput>
  }

  export type ProjectProposalsUpdateWithoutScopeOfWorkPropertyUnitsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    proposal_status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    Projects?: ProjectsUpdateOneRequiredWithoutProjectProposalsInput
    AreaOfWorks?: AreaOfWorksUpdateManyWithoutProjectProposalsInput
    ScopeOfWorks?: ScopeOfWorksUpdateManyWithoutProjectProposalsInput
  }

  export type ProjectProposalsUncheckedUpdateWithoutScopeOfWorkPropertyUnitsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    project_id?: IntFieldUpdateOperationsInput | number
    proposal_status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    AreaOfWorks?: AreaOfWorksUncheckedUpdateManyWithoutProjectProposalsInput
    ScopeOfWorks?: ScopeOfWorksUncheckedUpdateManyWithoutProjectProposalsInput
  }

  export type PropertyUnitAttributesUpsertWithoutScopeOfWorkPropertyUnitsInput = {
    update: XOR<PropertyUnitAttributesUpdateWithoutScopeOfWorkPropertyUnitsInput, PropertyUnitAttributesUncheckedUpdateWithoutScopeOfWorkPropertyUnitsInput>
    create: XOR<PropertyUnitAttributesCreateWithoutScopeOfWorkPropertyUnitsInput, PropertyUnitAttributesUncheckedCreateWithoutScopeOfWorkPropertyUnitsInput>
  }

  export type PropertyUnitAttributesUpdateWithoutScopeOfWorkPropertyUnitsInput = {
    html_element_type?: NullableStringFieldUpdateOperationsInput | string | null
    display_order?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    Attributes?: AttributesUpdateOneRequiredWithoutPropertyUnitAttributesInput
    AttributeUnits?: AttributeUnitsUpdateOneRequiredWithoutPropertyUnitAttributesInput
    PropertyUnits?: PropertyUnitsUpdateOneRequiredWithoutPropertyUnitAttributesInput
  }

  export type PropertyUnitAttributesUncheckedUpdateWithoutScopeOfWorkPropertyUnitsInput = {
    id?: IntFieldUpdateOperationsInput | number
    property_unit_id?: IntFieldUpdateOperationsInput | number
    attribute_id?: IntFieldUpdateOperationsInput | number
    attribute_unit_id?: IntFieldUpdateOperationsInput | number
    html_element_type?: NullableStringFieldUpdateOperationsInput | string | null
    display_order?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AreaOfWorksCreateWithoutScopeOfWorksInput = {
    new_unit?: string | null
    existing_unit?: string | null
    unit_alias?: string | null
    work_type?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    ProjectProposals: ProjectProposalsCreateNestedOneWithoutAreaOfWorksInput
    UnitLocations: UnitLocationsCreateNestedOneWithoutAreaOfWorksInput
    ScopeOfWorkPropertyUnits?: ScopeOfWorkPropertyUnitsCreateNestedManyWithoutAreaOfWorksInput
  }

  export type AreaOfWorksUncheckedCreateWithoutScopeOfWorksInput = {
    id?: number
    project_proposal_id: number
    unit_location_id: number
    new_unit?: string | null
    existing_unit?: string | null
    unit_alias?: string | null
    work_type?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    ScopeOfWorkPropertyUnits?: ScopeOfWorkPropertyUnitsUncheckedCreateNestedManyWithoutAreaOfWorksInput
  }

  export type AreaOfWorksCreateOrConnectWithoutScopeOfWorksInput = {
    where: AreaOfWorksWhereUniqueInput
    create: XOR<AreaOfWorksCreateWithoutScopeOfWorksInput, AreaOfWorksUncheckedCreateWithoutScopeOfWorksInput>
  }

  export type ProductAttributeUnitsCreateWithoutScopeOfWorksInput = {
    name?: string | null
    html_element_type?: string | null
    display_order?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    Attributes: AttributesCreateNestedOneWithoutProductAttributeUnitsInput
    AttributeUnits: AttributeUnitsCreateNestedOneWithoutProductAttributeUnitsInput
    Products: ProductsCreateNestedOneWithoutProductAttributeUnitsInput
    ProductAttributeUnitValues?: ProductAttributeUnitValuesCreateNestedManyWithoutProductAttributeUnitsInput
  }

  export type ProductAttributeUnitsUncheckedCreateWithoutScopeOfWorksInput = {
    id?: number
    name?: string | null
    product_id: number
    attribute_id: number
    attribute_unit_id: number
    html_element_type?: string | null
    display_order?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    ProductAttributeUnitValues?: ProductAttributeUnitValuesUncheckedCreateNestedManyWithoutProductAttributeUnitsInput
  }

  export type ProductAttributeUnitsCreateOrConnectWithoutScopeOfWorksInput = {
    where: ProductAttributeUnitsWhereUniqueInput
    create: XOR<ProductAttributeUnitsCreateWithoutScopeOfWorksInput, ProductAttributeUnitsUncheckedCreateWithoutScopeOfWorksInput>
  }

  export type ProductAttributeUnitValuesCreateWithoutScopeOfWorksInput = {
    value?: string | null
    slug?: string | null
    custom?: boolean
    custom_html_element_type?: string | null
    is_default?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    ProductAttributeUnits: ProductAttributeUnitsCreateNestedOneWithoutProductAttributeUnitValuesInput
  }

  export type ProductAttributeUnitValuesUncheckedCreateWithoutScopeOfWorksInput = {
    id?: number
    value?: string | null
    slug?: string | null
    product_attribute_unit_id: number
    custom?: boolean
    custom_html_element_type?: string | null
    is_default?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
  }

  export type ProductAttributeUnitValuesCreateOrConnectWithoutScopeOfWorksInput = {
    where: ProductAttributeUnitValuesWhereUniqueInput
    create: XOR<ProductAttributeUnitValuesCreateWithoutScopeOfWorksInput, ProductAttributeUnitValuesUncheckedCreateWithoutScopeOfWorksInput>
  }

  export type ProjectProposalsCreateWithoutScopeOfWorksInput = {
    name?: string | null
    proposal_status?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    Projects: ProjectsCreateNestedOneWithoutProjectProposalsInput
    AreaOfWorks?: AreaOfWorksCreateNestedManyWithoutProjectProposalsInput
    ScopeOfWorkPropertyUnits?: ScopeOfWorkPropertyUnitsCreateNestedManyWithoutProjectProposalsInput
  }

  export type ProjectProposalsUncheckedCreateWithoutScopeOfWorksInput = {
    id?: number
    name?: string | null
    project_id: number
    proposal_status?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    AreaOfWorks?: AreaOfWorksUncheckedCreateNestedManyWithoutProjectProposalsInput
    ScopeOfWorkPropertyUnits?: ScopeOfWorkPropertyUnitsUncheckedCreateNestedManyWithoutProjectProposalsInput
  }

  export type ProjectProposalsCreateOrConnectWithoutScopeOfWorksInput = {
    where: ProjectProposalsWhereUniqueInput
    create: XOR<ProjectProposalsCreateWithoutScopeOfWorksInput, ProjectProposalsUncheckedCreateWithoutScopeOfWorksInput>
  }

  export type AreaOfWorksUpsertWithoutScopeOfWorksInput = {
    update: XOR<AreaOfWorksUpdateWithoutScopeOfWorksInput, AreaOfWorksUncheckedUpdateWithoutScopeOfWorksInput>
    create: XOR<AreaOfWorksCreateWithoutScopeOfWorksInput, AreaOfWorksUncheckedCreateWithoutScopeOfWorksInput>
  }

  export type AreaOfWorksUpdateWithoutScopeOfWorksInput = {
    new_unit?: NullableStringFieldUpdateOperationsInput | string | null
    existing_unit?: NullableStringFieldUpdateOperationsInput | string | null
    unit_alias?: NullableStringFieldUpdateOperationsInput | string | null
    work_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    ProjectProposals?: ProjectProposalsUpdateOneRequiredWithoutAreaOfWorksInput
    UnitLocations?: UnitLocationsUpdateOneRequiredWithoutAreaOfWorksInput
    ScopeOfWorkPropertyUnits?: ScopeOfWorkPropertyUnitsUpdateManyWithoutAreaOfWorksInput
  }

  export type AreaOfWorksUncheckedUpdateWithoutScopeOfWorksInput = {
    id?: IntFieldUpdateOperationsInput | number
    project_proposal_id?: IntFieldUpdateOperationsInput | number
    unit_location_id?: IntFieldUpdateOperationsInput | number
    new_unit?: NullableStringFieldUpdateOperationsInput | string | null
    existing_unit?: NullableStringFieldUpdateOperationsInput | string | null
    unit_alias?: NullableStringFieldUpdateOperationsInput | string | null
    work_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    ScopeOfWorkPropertyUnits?: ScopeOfWorkPropertyUnitsUncheckedUpdateManyWithoutAreaOfWorksInput
  }

  export type ProductAttributeUnitsUpsertWithoutScopeOfWorksInput = {
    update: XOR<ProductAttributeUnitsUpdateWithoutScopeOfWorksInput, ProductAttributeUnitsUncheckedUpdateWithoutScopeOfWorksInput>
    create: XOR<ProductAttributeUnitsCreateWithoutScopeOfWorksInput, ProductAttributeUnitsUncheckedCreateWithoutScopeOfWorksInput>
  }

  export type ProductAttributeUnitsUpdateWithoutScopeOfWorksInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    html_element_type?: NullableStringFieldUpdateOperationsInput | string | null
    display_order?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    Attributes?: AttributesUpdateOneRequiredWithoutProductAttributeUnitsInput
    AttributeUnits?: AttributeUnitsUpdateOneRequiredWithoutProductAttributeUnitsInput
    Products?: ProductsUpdateOneRequiredWithoutProductAttributeUnitsInput
    ProductAttributeUnitValues?: ProductAttributeUnitValuesUpdateManyWithoutProductAttributeUnitsInput
  }

  export type ProductAttributeUnitsUncheckedUpdateWithoutScopeOfWorksInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    product_id?: IntFieldUpdateOperationsInput | number
    attribute_id?: IntFieldUpdateOperationsInput | number
    attribute_unit_id?: IntFieldUpdateOperationsInput | number
    html_element_type?: NullableStringFieldUpdateOperationsInput | string | null
    display_order?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    ProductAttributeUnitValues?: ProductAttributeUnitValuesUncheckedUpdateManyWithoutProductAttributeUnitsInput
  }

  export type ProductAttributeUnitValuesUpsertWithoutScopeOfWorksInput = {
    update: XOR<ProductAttributeUnitValuesUpdateWithoutScopeOfWorksInput, ProductAttributeUnitValuesUncheckedUpdateWithoutScopeOfWorksInput>
    create: XOR<ProductAttributeUnitValuesCreateWithoutScopeOfWorksInput, ProductAttributeUnitValuesUncheckedCreateWithoutScopeOfWorksInput>
  }

  export type ProductAttributeUnitValuesUpdateWithoutScopeOfWorksInput = {
    value?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    custom?: BoolFieldUpdateOperationsInput | boolean
    custom_html_element_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_default?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    ProductAttributeUnits?: ProductAttributeUnitsUpdateOneRequiredWithoutProductAttributeUnitValuesInput
  }

  export type ProductAttributeUnitValuesUncheckedUpdateWithoutScopeOfWorksInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    product_attribute_unit_id?: IntFieldUpdateOperationsInput | number
    custom?: BoolFieldUpdateOperationsInput | boolean
    custom_html_element_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_default?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProjectProposalsUpsertWithoutScopeOfWorksInput = {
    update: XOR<ProjectProposalsUpdateWithoutScopeOfWorksInput, ProjectProposalsUncheckedUpdateWithoutScopeOfWorksInput>
    create: XOR<ProjectProposalsCreateWithoutScopeOfWorksInput, ProjectProposalsUncheckedCreateWithoutScopeOfWorksInput>
  }

  export type ProjectProposalsUpdateWithoutScopeOfWorksInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    proposal_status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    Projects?: ProjectsUpdateOneRequiredWithoutProjectProposalsInput
    AreaOfWorks?: AreaOfWorksUpdateManyWithoutProjectProposalsInput
    ScopeOfWorkPropertyUnits?: ScopeOfWorkPropertyUnitsUpdateManyWithoutProjectProposalsInput
  }

  export type ProjectProposalsUncheckedUpdateWithoutScopeOfWorksInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    project_id?: IntFieldUpdateOperationsInput | number
    proposal_status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    AreaOfWorks?: AreaOfWorksUncheckedUpdateManyWithoutProjectProposalsInput
    ScopeOfWorkPropertyUnits?: ScopeOfWorkPropertyUnitsUncheckedUpdateManyWithoutProjectProposalsInput
  }

  export type CountriesCreateWithoutStatesInput = {
    country_name: string
    country_code: string
    iso3?: string | null
    phone_code?: string | null
    status?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
  }

  export type CountriesUncheckedCreateWithoutStatesInput = {
    id?: number
    country_name: string
    country_code: string
    iso3?: string | null
    phone_code?: string | null
    status?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
  }

  export type CountriesCreateOrConnectWithoutStatesInput = {
    where: CountriesWhereUniqueInput
    create: XOR<CountriesCreateWithoutStatesInput, CountriesUncheckedCreateWithoutStatesInput>
  }

  export type CitiesCreateWithoutStatesInput = {
    name: string
    status?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    Property_Addresses?: Property_AddressesCreateNestedManyWithoutCitiesInput
  }

  export type CitiesUncheckedCreateWithoutStatesInput = {
    id?: number
    name: string
    status?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    Property_Addresses?: Property_AddressesUncheckedCreateNestedManyWithoutCitiesInput
  }

  export type CitiesCreateOrConnectWithoutStatesInput = {
    where: CitiesWhereUniqueInput
    create: XOR<CitiesCreateWithoutStatesInput, CitiesUncheckedCreateWithoutStatesInput>
  }

  export type CountriesUpsertWithoutStatesInput = {
    update: XOR<CountriesUpdateWithoutStatesInput, CountriesUncheckedUpdateWithoutStatesInput>
    create: XOR<CountriesCreateWithoutStatesInput, CountriesUncheckedCreateWithoutStatesInput>
  }

  export type CountriesUpdateWithoutStatesInput = {
    country_name?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    iso3?: NullableStringFieldUpdateOperationsInput | string | null
    phone_code?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CountriesUncheckedUpdateWithoutStatesInput = {
    id?: IntFieldUpdateOperationsInput | number
    country_name?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    iso3?: NullableStringFieldUpdateOperationsInput | string | null
    phone_code?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CitiesUpsertWithWhereUniqueWithoutStatesInput = {
    where: CitiesWhereUniqueInput
    update: XOR<CitiesUpdateWithoutStatesInput, CitiesUncheckedUpdateWithoutStatesInput>
    create: XOR<CitiesCreateWithoutStatesInput, CitiesUncheckedCreateWithoutStatesInput>
  }

  export type CitiesUpdateWithWhereUniqueWithoutStatesInput = {
    where: CitiesWhereUniqueInput
    data: XOR<CitiesUpdateWithoutStatesInput, CitiesUncheckedUpdateWithoutStatesInput>
  }

  export type CitiesUpdateManyWithWhereWithoutStatesInput = {
    where: CitiesScalarWhereInput
    data: XOR<CitiesUpdateManyMutationInput, CitiesUncheckedUpdateManyWithoutCitiesInput>
  }

  export type CitiesScalarWhereInput = {
    AND?: Enumerable<CitiesScalarWhereInput>
    OR?: Enumerable<CitiesScalarWhereInput>
    NOT?: Enumerable<CitiesScalarWhereInput>
    id?: IntFilter | number
    state_id?: IntFilter | number
    name?: StringFilter | string
    status?: BoolFilter | boolean
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    created_by?: IntNullableFilter | number | null
    updated_by?: IntNullableFilter | number | null
  }

  export type PropertyLevelsCreateWithoutUnitLocationsInput = {
    name: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
  }

  export type PropertyLevelsUncheckedCreateWithoutUnitLocationsInput = {
    id?: number
    name: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
  }

  export type PropertyLevelsCreateOrConnectWithoutUnitLocationsInput = {
    where: PropertyLevelsWhereUniqueInput
    create: XOR<PropertyLevelsCreateWithoutUnitLocationsInput, PropertyLevelsUncheckedCreateWithoutUnitLocationsInput>
  }

  export type PropertySubTypesCreateWithoutUnitLocationsInput = {
    name: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    Property_Types: Property_TypesCreateNestedOneWithoutPropertySubTypesInput
    Property_Addresses?: Property_AddressesCreateNestedManyWithoutPropertySubTypesInput
  }

  export type PropertySubTypesUncheckedCreateWithoutUnitLocationsInput = {
    id?: number
    property_type_id: number
    name: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    Property_Addresses?: Property_AddressesUncheckedCreateNestedManyWithoutPropertySubTypesInput
  }

  export type PropertySubTypesCreateOrConnectWithoutUnitLocationsInput = {
    where: PropertySubTypesWhereUniqueInput
    create: XOR<PropertySubTypesCreateWithoutUnitLocationsInput, PropertySubTypesUncheckedCreateWithoutUnitLocationsInput>
  }

  export type PropertyUnitsCreateWithoutUnitLocationsInput = {
    name?: string | null
    slug?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    ProductPropertyUnits?: ProductPropertyUnitsCreateNestedManyWithoutPropertyUnitsInput
    PropertyUnitAttributes?: PropertyUnitAttributesCreateNestedManyWithoutPropertyUnitsInput
    PropertyUnitProductCategories?: PropertyUnitProductCategoriesCreateNestedManyWithoutPropertyUnitsInput
  }

  export type PropertyUnitsUncheckedCreateWithoutUnitLocationsInput = {
    id?: number
    name?: string | null
    slug?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    ProductPropertyUnits?: ProductPropertyUnitsUncheckedCreateNestedManyWithoutPropertyUnitsInput
    PropertyUnitAttributes?: PropertyUnitAttributesUncheckedCreateNestedManyWithoutPropertyUnitsInput
    PropertyUnitProductCategories?: PropertyUnitProductCategoriesUncheckedCreateNestedManyWithoutPropertyUnitsInput
  }

  export type PropertyUnitsCreateOrConnectWithoutUnitLocationsInput = {
    where: PropertyUnitsWhereUniqueInput
    create: XOR<PropertyUnitsCreateWithoutUnitLocationsInput, PropertyUnitsUncheckedCreateWithoutUnitLocationsInput>
  }

  export type AreaOfWorksCreateWithoutUnitLocationsInput = {
    new_unit?: string | null
    existing_unit?: string | null
    unit_alias?: string | null
    work_type?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    ProjectProposals: ProjectProposalsCreateNestedOneWithoutAreaOfWorksInput
    ScopeOfWorkPropertyUnits?: ScopeOfWorkPropertyUnitsCreateNestedManyWithoutAreaOfWorksInput
    ScopeOfWorks?: ScopeOfWorksCreateNestedManyWithoutAreaOfWorksInput
  }

  export type AreaOfWorksUncheckedCreateWithoutUnitLocationsInput = {
    id?: number
    project_proposal_id: number
    new_unit?: string | null
    existing_unit?: string | null
    unit_alias?: string | null
    work_type?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    ScopeOfWorkPropertyUnits?: ScopeOfWorkPropertyUnitsUncheckedCreateNestedManyWithoutAreaOfWorksInput
    ScopeOfWorks?: ScopeOfWorksUncheckedCreateNestedManyWithoutAreaOfWorksInput
  }

  export type AreaOfWorksCreateOrConnectWithoutUnitLocationsInput = {
    where: AreaOfWorksWhereUniqueInput
    create: XOR<AreaOfWorksCreateWithoutUnitLocationsInput, AreaOfWorksUncheckedCreateWithoutUnitLocationsInput>
  }

  export type PropertyLevelsUpsertWithoutUnitLocationsInput = {
    update: XOR<PropertyLevelsUpdateWithoutUnitLocationsInput, PropertyLevelsUncheckedUpdateWithoutUnitLocationsInput>
    create: XOR<PropertyLevelsCreateWithoutUnitLocationsInput, PropertyLevelsUncheckedCreateWithoutUnitLocationsInput>
  }

  export type PropertyLevelsUpdateWithoutUnitLocationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PropertyLevelsUncheckedUpdateWithoutUnitLocationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PropertySubTypesUpsertWithoutUnitLocationsInput = {
    update: XOR<PropertySubTypesUpdateWithoutUnitLocationsInput, PropertySubTypesUncheckedUpdateWithoutUnitLocationsInput>
    create: XOR<PropertySubTypesCreateWithoutUnitLocationsInput, PropertySubTypesUncheckedCreateWithoutUnitLocationsInput>
  }

  export type PropertySubTypesUpdateWithoutUnitLocationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    Property_Types?: Property_TypesUpdateOneRequiredWithoutPropertySubTypesInput
    Property_Addresses?: Property_AddressesUpdateManyWithoutPropertySubTypesInput
  }

  export type PropertySubTypesUncheckedUpdateWithoutUnitLocationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    property_type_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    Property_Addresses?: Property_AddressesUncheckedUpdateManyWithoutPropertySubTypesInput
  }

  export type PropertyUnitsUpsertWithoutUnitLocationsInput = {
    update: XOR<PropertyUnitsUpdateWithoutUnitLocationsInput, PropertyUnitsUncheckedUpdateWithoutUnitLocationsInput>
    create: XOR<PropertyUnitsCreateWithoutUnitLocationsInput, PropertyUnitsUncheckedCreateWithoutUnitLocationsInput>
  }

  export type PropertyUnitsUpdateWithoutUnitLocationsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    ProductPropertyUnits?: ProductPropertyUnitsUpdateManyWithoutPropertyUnitsInput
    PropertyUnitAttributes?: PropertyUnitAttributesUpdateManyWithoutPropertyUnitsInput
    PropertyUnitProductCategories?: PropertyUnitProductCategoriesUpdateManyWithoutPropertyUnitsInput
  }

  export type PropertyUnitsUncheckedUpdateWithoutUnitLocationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    ProductPropertyUnits?: ProductPropertyUnitsUncheckedUpdateManyWithoutPropertyUnitsInput
    PropertyUnitAttributes?: PropertyUnitAttributesUncheckedUpdateManyWithoutPropertyUnitsInput
    PropertyUnitProductCategories?: PropertyUnitProductCategoriesUncheckedUpdateManyWithoutPropertyUnitsInput
  }

  export type AreaOfWorksUpsertWithWhereUniqueWithoutUnitLocationsInput = {
    where: AreaOfWorksWhereUniqueInput
    update: XOR<AreaOfWorksUpdateWithoutUnitLocationsInput, AreaOfWorksUncheckedUpdateWithoutUnitLocationsInput>
    create: XOR<AreaOfWorksCreateWithoutUnitLocationsInput, AreaOfWorksUncheckedCreateWithoutUnitLocationsInput>
  }

  export type AreaOfWorksUpdateWithWhereUniqueWithoutUnitLocationsInput = {
    where: AreaOfWorksWhereUniqueInput
    data: XOR<AreaOfWorksUpdateWithoutUnitLocationsInput, AreaOfWorksUncheckedUpdateWithoutUnitLocationsInput>
  }

  export type AreaOfWorksUpdateManyWithWhereWithoutUnitLocationsInput = {
    where: AreaOfWorksScalarWhereInput
    data: XOR<AreaOfWorksUpdateManyMutationInput, AreaOfWorksUncheckedUpdateManyWithoutAreaOfWorksInput>
  }

  export type Backend_UsersCreateWithoutUsersInput = {
    first_name?: string | null
    last_name?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
  }

  export type Backend_UsersUncheckedCreateWithoutUsersInput = {
    id?: number
    first_name?: string | null
    last_name?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
  }

  export type Backend_UsersCreateOrConnectWithoutUsersInput = {
    where: Backend_UsersWhereUniqueInput
    create: XOR<Backend_UsersCreateWithoutUsersInput, Backend_UsersUncheckedCreateWithoutUsersInput>
  }

  export type ContractorsCreateWithoutUsersInput = {
    first_name?: string | null
    last_name?: string | null
    mobile?: string | null
    company_name?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
  }

  export type ContractorsUncheckedCreateWithoutUsersInput = {
    id?: number
    first_name?: string | null
    last_name?: string | null
    mobile?: string | null
    company_name?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
  }

  export type ContractorsCreateOrConnectWithoutUsersInput = {
    where: ContractorsWhereUniqueInput
    create: XOR<ContractorsCreateWithoutUsersInput, ContractorsUncheckedCreateWithoutUsersInput>
  }

  export type PropertyOwnersCreateWithoutUsersInput = {
    first_name?: string | null
    last_name?: string | null
    mobile?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    Property_Addresses?: Property_AddressesCreateNestedManyWithoutPropertyOwnersInput
  }

  export type PropertyOwnersUncheckedCreateWithoutUsersInput = {
    id?: number
    first_name?: string | null
    last_name?: string | null
    mobile?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: number | null
    updated_by?: number | null
    Property_Addresses?: Property_AddressesUncheckedCreateNestedManyWithoutPropertyOwnersInput
  }

  export type PropertyOwnersCreateOrConnectWithoutUsersInput = {
    where: PropertyOwnersWhereUniqueInput
    create: XOR<PropertyOwnersCreateWithoutUsersInput, PropertyOwnersUncheckedCreateWithoutUsersInput>
  }

  export type Backend_UsersUpsertWithWhereUniqueWithoutUsersInput = {
    where: Backend_UsersWhereUniqueInput
    update: XOR<Backend_UsersUpdateWithoutUsersInput, Backend_UsersUncheckedUpdateWithoutUsersInput>
    create: XOR<Backend_UsersCreateWithoutUsersInput, Backend_UsersUncheckedCreateWithoutUsersInput>
  }

  export type Backend_UsersUpdateWithWhereUniqueWithoutUsersInput = {
    where: Backend_UsersWhereUniqueInput
    data: XOR<Backend_UsersUpdateWithoutUsersInput, Backend_UsersUncheckedUpdateWithoutUsersInput>
  }

  export type Backend_UsersUpdateManyWithWhereWithoutUsersInput = {
    where: Backend_UsersScalarWhereInput
    data: XOR<Backend_UsersUpdateManyMutationInput, Backend_UsersUncheckedUpdateManyWithoutBackend_UsersInput>
  }

  export type Backend_UsersScalarWhereInput = {
    AND?: Enumerable<Backend_UsersScalarWhereInput>
    OR?: Enumerable<Backend_UsersScalarWhereInput>
    NOT?: Enumerable<Backend_UsersScalarWhereInput>
    id?: IntFilter | number
    user_id?: IntFilter | number
    first_name?: StringNullableFilter | string | null
    last_name?: StringNullableFilter | string | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    created_by?: IntNullableFilter | number | null
    updated_by?: IntNullableFilter | number | null
  }

  export type ContractorsUpsertWithWhereUniqueWithoutUsersInput = {
    where: ContractorsWhereUniqueInput
    update: XOR<ContractorsUpdateWithoutUsersInput, ContractorsUncheckedUpdateWithoutUsersInput>
    create: XOR<ContractorsCreateWithoutUsersInput, ContractorsUncheckedCreateWithoutUsersInput>
  }

  export type ContractorsUpdateWithWhereUniqueWithoutUsersInput = {
    where: ContractorsWhereUniqueInput
    data: XOR<ContractorsUpdateWithoutUsersInput, ContractorsUncheckedUpdateWithoutUsersInput>
  }

  export type ContractorsUpdateManyWithWhereWithoutUsersInput = {
    where: ContractorsScalarWhereInput
    data: XOR<ContractorsUpdateManyMutationInput, ContractorsUncheckedUpdateManyWithoutContractorsInput>
  }

  export type ContractorsScalarWhereInput = {
    AND?: Enumerable<ContractorsScalarWhereInput>
    OR?: Enumerable<ContractorsScalarWhereInput>
    NOT?: Enumerable<ContractorsScalarWhereInput>
    id?: IntFilter | number
    user_id?: IntFilter | number
    first_name?: StringNullableFilter | string | null
    last_name?: StringNullableFilter | string | null
    mobile?: StringNullableFilter | string | null
    company_name?: StringNullableFilter | string | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    created_by?: IntNullableFilter | number | null
    updated_by?: IntNullableFilter | number | null
  }

  export type PropertyOwnersUpsertWithWhereUniqueWithoutUsersInput = {
    where: PropertyOwnersWhereUniqueInput
    update: XOR<PropertyOwnersUpdateWithoutUsersInput, PropertyOwnersUncheckedUpdateWithoutUsersInput>
    create: XOR<PropertyOwnersCreateWithoutUsersInput, PropertyOwnersUncheckedCreateWithoutUsersInput>
  }

  export type PropertyOwnersUpdateWithWhereUniqueWithoutUsersInput = {
    where: PropertyOwnersWhereUniqueInput
    data: XOR<PropertyOwnersUpdateWithoutUsersInput, PropertyOwnersUncheckedUpdateWithoutUsersInput>
  }

  export type PropertyOwnersUpdateManyWithWhereWithoutUsersInput = {
    where: PropertyOwnersScalarWhereInput
    data: XOR<PropertyOwnersUpdateManyMutationInput, PropertyOwnersUncheckedUpdateManyWithoutPropertyOwnersInput>
  }

  export type PropertyOwnersScalarWhereInput = {
    AND?: Enumerable<PropertyOwnersScalarWhereInput>
    OR?: Enumerable<PropertyOwnersScalarWhereInput>
    NOT?: Enumerable<PropertyOwnersScalarWhereInput>
    id?: IntFilter | number
    user_id?: IntFilter | number
    first_name?: StringNullableFilter | string | null
    last_name?: StringNullableFilter | string | null
    mobile?: StringNullableFilter | string | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    created_by?: IntNullableFilter | number | null
    updated_by?: IntNullableFilter | number | null
  }

  export type ScopeOfWorkPropertyUnitsUpdateWithoutAreaOfWorksInput = {
    value?: NullableStringFieldUpdateOperationsInput | string | null
    attribute_custom_name?: NullableStringFieldUpdateOperationsInput | string | null
    attribute_custom_value?: NullableStringFieldUpdateOperationsInput | string | null
    attribute_custom_unit?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    ProjectProposals?: ProjectProposalsUpdateOneRequiredWithoutScopeOfWorkPropertyUnitsInput
    PropertyUnitAttributes?: PropertyUnitAttributesUpdateOneRequiredWithoutScopeOfWorkPropertyUnitsInput
  }

  export type ScopeOfWorkPropertyUnitsUncheckedUpdateWithoutAreaOfWorksInput = {
    id?: IntFieldUpdateOperationsInput | number
    project_proposal_id?: IntFieldUpdateOperationsInput | number
    property_unit_attribute_id?: IntFieldUpdateOperationsInput | number
    value?: NullableStringFieldUpdateOperationsInput | string | null
    attribute_custom_name?: NullableStringFieldUpdateOperationsInput | string | null
    attribute_custom_value?: NullableStringFieldUpdateOperationsInput | string | null
    attribute_custom_unit?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ScopeOfWorkPropertyUnitsUncheckedUpdateManyWithoutScopeOfWorkPropertyUnitsInput = {
    id?: IntFieldUpdateOperationsInput | number
    project_proposal_id?: IntFieldUpdateOperationsInput | number
    property_unit_attribute_id?: IntFieldUpdateOperationsInput | number
    value?: NullableStringFieldUpdateOperationsInput | string | null
    attribute_custom_name?: NullableStringFieldUpdateOperationsInput | string | null
    attribute_custom_value?: NullableStringFieldUpdateOperationsInput | string | null
    attribute_custom_unit?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ScopeOfWorksUpdateWithoutAreaOfWorksInput = {
    attribute_custom_name?: NullableStringFieldUpdateOperationsInput | string | null
    attribute_custom_value?: NullableStringFieldUpdateOperationsInput | string | null
    attribute_custom_unit?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    ProductAttributeUnits?: ProductAttributeUnitsUpdateOneRequiredWithoutScopeOfWorksInput
    ProductAttributeUnitValues?: ProductAttributeUnitValuesUpdateOneRequiredWithoutScopeOfWorksInput
    ProjectProposals?: ProjectProposalsUpdateOneRequiredWithoutScopeOfWorksInput
  }

  export type ScopeOfWorksUncheckedUpdateWithoutAreaOfWorksInput = {
    id?: IntFieldUpdateOperationsInput | number
    project_proposal_id?: IntFieldUpdateOperationsInput | number
    product_attribute_unit_id?: IntFieldUpdateOperationsInput | number
    product_attribute_unit_value_id?: IntFieldUpdateOperationsInput | number
    attribute_custom_name?: NullableStringFieldUpdateOperationsInput | string | null
    attribute_custom_value?: NullableStringFieldUpdateOperationsInput | string | null
    attribute_custom_unit?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ScopeOfWorksUncheckedUpdateManyWithoutScopeOfWorksInput = {
    id?: IntFieldUpdateOperationsInput | number
    project_proposal_id?: IntFieldUpdateOperationsInput | number
    product_attribute_unit_id?: IntFieldUpdateOperationsInput | number
    product_attribute_unit_value_id?: IntFieldUpdateOperationsInput | number
    attribute_custom_name?: NullableStringFieldUpdateOperationsInput | string | null
    attribute_custom_value?: NullableStringFieldUpdateOperationsInput | string | null
    attribute_custom_unit?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AttributesUpdateWithoutAttributesInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    other_Attributes?: AttributesUpdateManyWithoutAttributesInput
    AttributeUnits?: AttributeUnitsUpdateManyWithoutAttributesInput
    ProductAttributeUnits?: ProductAttributeUnitsUpdateManyWithoutAttributesInput
    PropertyUnitAttributes?: PropertyUnitAttributesUpdateManyWithoutAttributesInput
  }

  export type AttributesUncheckedUpdateWithoutAttributesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    other_Attributes?: AttributesUncheckedUpdateManyWithoutAttributesInput
    AttributeUnits?: AttributeUnitsUncheckedUpdateManyWithoutAttributesInput
    ProductAttributeUnits?: ProductAttributeUnitsUncheckedUpdateManyWithoutAttributesInput
    PropertyUnitAttributes?: PropertyUnitAttributesUncheckedUpdateManyWithoutAttributesInput
  }

  export type AttributesUncheckedUpdateManyWithoutOther_AttributesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AttributeUnitsUpdateWithoutAttributesInput = {
    unit_name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    ProductAttributeUnits?: ProductAttributeUnitsUpdateManyWithoutAttributeUnitsInput
    PropertyUnitAttributes?: PropertyUnitAttributesUpdateManyWithoutAttributeUnitsInput
  }

  export type AttributeUnitsUncheckedUpdateWithoutAttributesInput = {
    id?: IntFieldUpdateOperationsInput | number
    unit_name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    ProductAttributeUnits?: ProductAttributeUnitsUncheckedUpdateManyWithoutAttributeUnitsInput
    PropertyUnitAttributes?: PropertyUnitAttributesUncheckedUpdateManyWithoutAttributeUnitsInput
  }

  export type AttributeUnitsUncheckedUpdateManyWithoutAttributeUnitsInput = {
    id?: IntFieldUpdateOperationsInput | number
    unit_name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProductAttributeUnitsUpdateWithoutAttributesInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    html_element_type?: NullableStringFieldUpdateOperationsInput | string | null
    display_order?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    AttributeUnits?: AttributeUnitsUpdateOneRequiredWithoutProductAttributeUnitsInput
    Products?: ProductsUpdateOneRequiredWithoutProductAttributeUnitsInput
    ProductAttributeUnitValues?: ProductAttributeUnitValuesUpdateManyWithoutProductAttributeUnitsInput
    ScopeOfWorks?: ScopeOfWorksUpdateManyWithoutProductAttributeUnitsInput
  }

  export type ProductAttributeUnitsUncheckedUpdateWithoutAttributesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    product_id?: IntFieldUpdateOperationsInput | number
    attribute_unit_id?: IntFieldUpdateOperationsInput | number
    html_element_type?: NullableStringFieldUpdateOperationsInput | string | null
    display_order?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    ProductAttributeUnitValues?: ProductAttributeUnitValuesUncheckedUpdateManyWithoutProductAttributeUnitsInput
    ScopeOfWorks?: ScopeOfWorksUncheckedUpdateManyWithoutProductAttributeUnitsInput
  }

  export type ProductAttributeUnitsUncheckedUpdateManyWithoutProductAttributeUnitsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    product_id?: IntFieldUpdateOperationsInput | number
    attribute_unit_id?: IntFieldUpdateOperationsInput | number
    html_element_type?: NullableStringFieldUpdateOperationsInput | string | null
    display_order?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PropertyUnitAttributesUpdateWithoutAttributesInput = {
    html_element_type?: NullableStringFieldUpdateOperationsInput | string | null
    display_order?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    AttributeUnits?: AttributeUnitsUpdateOneRequiredWithoutPropertyUnitAttributesInput
    PropertyUnits?: PropertyUnitsUpdateOneRequiredWithoutPropertyUnitAttributesInput
    ScopeOfWorkPropertyUnits?: ScopeOfWorkPropertyUnitsUpdateManyWithoutPropertyUnitAttributesInput
  }

  export type PropertyUnitAttributesUncheckedUpdateWithoutAttributesInput = {
    id?: IntFieldUpdateOperationsInput | number
    property_unit_id?: IntFieldUpdateOperationsInput | number
    attribute_unit_id?: IntFieldUpdateOperationsInput | number
    html_element_type?: NullableStringFieldUpdateOperationsInput | string | null
    display_order?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    ScopeOfWorkPropertyUnits?: ScopeOfWorkPropertyUnitsUncheckedUpdateManyWithoutPropertyUnitAttributesInput
  }

  export type PropertyUnitAttributesUncheckedUpdateManyWithoutPropertyUnitAttributesInput = {
    id?: IntFieldUpdateOperationsInput | number
    property_unit_id?: IntFieldUpdateOperationsInput | number
    attribute_unit_id?: IntFieldUpdateOperationsInput | number
    html_element_type?: NullableStringFieldUpdateOperationsInput | string | null
    display_order?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProductAttributeUnitsUpdateWithoutAttributeUnitsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    html_element_type?: NullableStringFieldUpdateOperationsInput | string | null
    display_order?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    Attributes?: AttributesUpdateOneRequiredWithoutProductAttributeUnitsInput
    Products?: ProductsUpdateOneRequiredWithoutProductAttributeUnitsInput
    ProductAttributeUnitValues?: ProductAttributeUnitValuesUpdateManyWithoutProductAttributeUnitsInput
    ScopeOfWorks?: ScopeOfWorksUpdateManyWithoutProductAttributeUnitsInput
  }

  export type ProductAttributeUnitsUncheckedUpdateWithoutAttributeUnitsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    product_id?: IntFieldUpdateOperationsInput | number
    attribute_id?: IntFieldUpdateOperationsInput | number
    html_element_type?: NullableStringFieldUpdateOperationsInput | string | null
    display_order?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    ProductAttributeUnitValues?: ProductAttributeUnitValuesUncheckedUpdateManyWithoutProductAttributeUnitsInput
    ScopeOfWorks?: ScopeOfWorksUncheckedUpdateManyWithoutProductAttributeUnitsInput
  }

  export type PropertyUnitAttributesUpdateWithoutAttributeUnitsInput = {
    html_element_type?: NullableStringFieldUpdateOperationsInput | string | null
    display_order?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    Attributes?: AttributesUpdateOneRequiredWithoutPropertyUnitAttributesInput
    PropertyUnits?: PropertyUnitsUpdateOneRequiredWithoutPropertyUnitAttributesInput
    ScopeOfWorkPropertyUnits?: ScopeOfWorkPropertyUnitsUpdateManyWithoutPropertyUnitAttributesInput
  }

  export type PropertyUnitAttributesUncheckedUpdateWithoutAttributeUnitsInput = {
    id?: IntFieldUpdateOperationsInput | number
    property_unit_id?: IntFieldUpdateOperationsInput | number
    attribute_id?: IntFieldUpdateOperationsInput | number
    html_element_type?: NullableStringFieldUpdateOperationsInput | string | null
    display_order?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    ScopeOfWorkPropertyUnits?: ScopeOfWorkPropertyUnitsUncheckedUpdateManyWithoutPropertyUnitAttributesInput
  }

  export type Property_AddressesUpdateWithoutCitiesInput = {
    street?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    construction_type?: NullableStringFieldUpdateOperationsInput | string | null
    withBasement?: BoolFieldUpdateOperationsInput | boolean
    storyId?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    PropertyOwners?: PropertyOwnersUpdateOneRequiredWithoutProperty_AddressesInput
    PropertySubTypes?: PropertySubTypesUpdateOneRequiredWithoutProperty_AddressesInput
    Projects?: ProjectsUpdateManyWithoutProperty_AddressesInput
  }

  export type Property_AddressesUncheckedUpdateWithoutCitiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    street?: NullableStringFieldUpdateOperationsInput | string | null
    property_owner_id?: IntFieldUpdateOperationsInput | number
    property_sub_type_id?: IntFieldUpdateOperationsInput | number
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    construction_type?: NullableStringFieldUpdateOperationsInput | string | null
    withBasement?: BoolFieldUpdateOperationsInput | boolean
    storyId?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    Projects?: ProjectsUncheckedUpdateManyWithoutProperty_AddressesInput
  }

  export type Property_AddressesUncheckedUpdateManyWithoutProperty_AddressesInput = {
    id?: IntFieldUpdateOperationsInput | number
    street?: NullableStringFieldUpdateOperationsInput | string | null
    property_owner_id?: IntFieldUpdateOperationsInput | number
    property_sub_type_id?: IntFieldUpdateOperationsInput | number
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    construction_type?: NullableStringFieldUpdateOperationsInput | string | null
    withBasement?: BoolFieldUpdateOperationsInput | boolean
    storyId?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type StatesUpdateWithoutCountriesInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    state_code?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    Cities?: CitiesUpdateManyWithoutStatesInput
  }

  export type StatesUncheckedUpdateWithoutCountriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    state_code?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    Cities?: CitiesUncheckedUpdateManyWithoutStatesInput
  }

  export type StatesUncheckedUpdateManyWithoutStatesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    state_code?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProductAttributeUnitValuesUpdateWithoutProductAttributeUnitsInput = {
    value?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    custom?: BoolFieldUpdateOperationsInput | boolean
    custom_html_element_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_default?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    ScopeOfWorks?: ScopeOfWorksUpdateManyWithoutProductAttributeUnitValuesInput
  }

  export type ProductAttributeUnitValuesUncheckedUpdateWithoutProductAttributeUnitsInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    custom?: BoolFieldUpdateOperationsInput | boolean
    custom_html_element_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_default?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    ScopeOfWorks?: ScopeOfWorksUncheckedUpdateManyWithoutProductAttributeUnitValuesInput
  }

  export type ProductAttributeUnitValuesUncheckedUpdateManyWithoutProductAttributeUnitValuesInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    custom?: BoolFieldUpdateOperationsInput | boolean
    custom_html_element_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_default?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ScopeOfWorksUpdateWithoutProductAttributeUnitsInput = {
    attribute_custom_name?: NullableStringFieldUpdateOperationsInput | string | null
    attribute_custom_value?: NullableStringFieldUpdateOperationsInput | string | null
    attribute_custom_unit?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    AreaOfWorks?: AreaOfWorksUpdateOneRequiredWithoutScopeOfWorksInput
    ProductAttributeUnitValues?: ProductAttributeUnitValuesUpdateOneRequiredWithoutScopeOfWorksInput
    ProjectProposals?: ProjectProposalsUpdateOneRequiredWithoutScopeOfWorksInput
  }

  export type ScopeOfWorksUncheckedUpdateWithoutProductAttributeUnitsInput = {
    id?: IntFieldUpdateOperationsInput | number
    project_proposal_id?: IntFieldUpdateOperationsInput | number
    area_of_work_id?: IntFieldUpdateOperationsInput | number
    product_attribute_unit_value_id?: IntFieldUpdateOperationsInput | number
    attribute_custom_name?: NullableStringFieldUpdateOperationsInput | string | null
    attribute_custom_value?: NullableStringFieldUpdateOperationsInput | string | null
    attribute_custom_unit?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ScopeOfWorksUpdateWithoutProductAttributeUnitValuesInput = {
    attribute_custom_name?: NullableStringFieldUpdateOperationsInput | string | null
    attribute_custom_value?: NullableStringFieldUpdateOperationsInput | string | null
    attribute_custom_unit?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    AreaOfWorks?: AreaOfWorksUpdateOneRequiredWithoutScopeOfWorksInput
    ProductAttributeUnits?: ProductAttributeUnitsUpdateOneRequiredWithoutScopeOfWorksInput
    ProjectProposals?: ProjectProposalsUpdateOneRequiredWithoutScopeOfWorksInput
  }

  export type ScopeOfWorksUncheckedUpdateWithoutProductAttributeUnitValuesInput = {
    id?: IntFieldUpdateOperationsInput | number
    project_proposal_id?: IntFieldUpdateOperationsInput | number
    area_of_work_id?: IntFieldUpdateOperationsInput | number
    product_attribute_unit_id?: IntFieldUpdateOperationsInput | number
    attribute_custom_name?: NullableStringFieldUpdateOperationsInput | string | null
    attribute_custom_value?: NullableStringFieldUpdateOperationsInput | string | null
    attribute_custom_unit?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PropertyUnitProductCategoriesUpdateWithoutProductCategoriesInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    PropertyUnits?: PropertyUnitsUpdateOneRequiredWithoutPropertyUnitProductCategoriesInput
    PropertyUnitProductCategoryProducts?: PropertyUnitProductCategoryProductsUpdateManyWithoutPropertyUnitProductCategoriesInput
  }

  export type PropertyUnitProductCategoriesUncheckedUpdateWithoutProductCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    property_unit_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    PropertyUnitProductCategoryProducts?: PropertyUnitProductCategoryProductsUncheckedUpdateManyWithoutPropertyUnitProductCategoriesInput
  }

  export type PropertyUnitProductCategoriesUncheckedUpdateManyWithoutPropertyUnitProductCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    property_unit_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProductAttributeUnitsUpdateWithoutProductsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    html_element_type?: NullableStringFieldUpdateOperationsInput | string | null
    display_order?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    Attributes?: AttributesUpdateOneRequiredWithoutProductAttributeUnitsInput
    AttributeUnits?: AttributeUnitsUpdateOneRequiredWithoutProductAttributeUnitsInput
    ProductAttributeUnitValues?: ProductAttributeUnitValuesUpdateManyWithoutProductAttributeUnitsInput
    ScopeOfWorks?: ScopeOfWorksUpdateManyWithoutProductAttributeUnitsInput
  }

  export type ProductAttributeUnitsUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    attribute_id?: IntFieldUpdateOperationsInput | number
    attribute_unit_id?: IntFieldUpdateOperationsInput | number
    html_element_type?: NullableStringFieldUpdateOperationsInput | string | null
    display_order?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    ProductAttributeUnitValues?: ProductAttributeUnitValuesUncheckedUpdateManyWithoutProductAttributeUnitsInput
    ScopeOfWorks?: ScopeOfWorksUncheckedUpdateManyWithoutProductAttributeUnitsInput
  }

  export type ProductPropertyUnitsUpdateWithoutProductsInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    PropertyUnits?: PropertyUnitsUpdateOneRequiredWithoutProductPropertyUnitsInput
  }

  export type ProductPropertyUnitsUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    property_unit_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProductPropertyUnitsUncheckedUpdateManyWithoutProductPropertyUnitsInput = {
    id?: IntFieldUpdateOperationsInput | number
    property_unit_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProductsUpdateWithoutProductsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    ProductAttributeUnits?: ProductAttributeUnitsUpdateManyWithoutProductsInput
    ProductPropertyUnits?: ProductPropertyUnitsUpdateManyWithoutProductsInput
    other_Products?: ProductsUpdateManyWithoutProductsInput
    PropertyUnitProductCategoryProducts?: PropertyUnitProductCategoryProductsUpdateManyWithoutProductsInput
  }

  export type ProductsUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    ProductAttributeUnits?: ProductAttributeUnitsUncheckedUpdateManyWithoutProductsInput
    ProductPropertyUnits?: ProductPropertyUnitsUncheckedUpdateManyWithoutProductsInput
    other_Products?: ProductsUncheckedUpdateManyWithoutProductsInput
    PropertyUnitProductCategoryProducts?: PropertyUnitProductCategoryProductsUncheckedUpdateManyWithoutProductsInput
  }

  export type ProductsUncheckedUpdateManyWithoutOther_ProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PropertyUnitProductCategoryProductsUpdateWithoutProductsInput = {
    display_order?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    PropertyUnitProductCategories?: PropertyUnitProductCategoriesUpdateOneRequiredWithoutPropertyUnitProductCategoryProductsInput
  }

  export type PropertyUnitProductCategoryProductsUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    property_unit_product_category_id?: IntFieldUpdateOperationsInput | number
    display_order?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PropertyUnitProductCategoryProductsUncheckedUpdateManyWithoutPropertyUnitProductCategoryProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    property_unit_product_category_id?: IntFieldUpdateOperationsInput | number
    display_order?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AreaOfWorksUpdateWithoutProjectProposalsInput = {
    new_unit?: NullableStringFieldUpdateOperationsInput | string | null
    existing_unit?: NullableStringFieldUpdateOperationsInput | string | null
    unit_alias?: NullableStringFieldUpdateOperationsInput | string | null
    work_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    UnitLocations?: UnitLocationsUpdateOneRequiredWithoutAreaOfWorksInput
    ScopeOfWorkPropertyUnits?: ScopeOfWorkPropertyUnitsUpdateManyWithoutAreaOfWorksInput
    ScopeOfWorks?: ScopeOfWorksUpdateManyWithoutAreaOfWorksInput
  }

  export type AreaOfWorksUncheckedUpdateWithoutProjectProposalsInput = {
    id?: IntFieldUpdateOperationsInput | number
    unit_location_id?: IntFieldUpdateOperationsInput | number
    new_unit?: NullableStringFieldUpdateOperationsInput | string | null
    existing_unit?: NullableStringFieldUpdateOperationsInput | string | null
    unit_alias?: NullableStringFieldUpdateOperationsInput | string | null
    work_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    ScopeOfWorkPropertyUnits?: ScopeOfWorkPropertyUnitsUncheckedUpdateManyWithoutAreaOfWorksInput
    ScopeOfWorks?: ScopeOfWorksUncheckedUpdateManyWithoutAreaOfWorksInput
  }

  export type AreaOfWorksUncheckedUpdateManyWithoutAreaOfWorksInput = {
    id?: IntFieldUpdateOperationsInput | number
    unit_location_id?: IntFieldUpdateOperationsInput | number
    new_unit?: NullableStringFieldUpdateOperationsInput | string | null
    existing_unit?: NullableStringFieldUpdateOperationsInput | string | null
    unit_alias?: NullableStringFieldUpdateOperationsInput | string | null
    work_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ScopeOfWorkPropertyUnitsUpdateWithoutProjectProposalsInput = {
    value?: NullableStringFieldUpdateOperationsInput | string | null
    attribute_custom_name?: NullableStringFieldUpdateOperationsInput | string | null
    attribute_custom_value?: NullableStringFieldUpdateOperationsInput | string | null
    attribute_custom_unit?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    AreaOfWorks?: AreaOfWorksUpdateOneRequiredWithoutScopeOfWorkPropertyUnitsInput
    PropertyUnitAttributes?: PropertyUnitAttributesUpdateOneRequiredWithoutScopeOfWorkPropertyUnitsInput
  }

  export type ScopeOfWorkPropertyUnitsUncheckedUpdateWithoutProjectProposalsInput = {
    id?: IntFieldUpdateOperationsInput | number
    area_of_work_id?: IntFieldUpdateOperationsInput | number
    property_unit_attribute_id?: IntFieldUpdateOperationsInput | number
    value?: NullableStringFieldUpdateOperationsInput | string | null
    attribute_custom_name?: NullableStringFieldUpdateOperationsInput | string | null
    attribute_custom_value?: NullableStringFieldUpdateOperationsInput | string | null
    attribute_custom_unit?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ScopeOfWorksUpdateWithoutProjectProposalsInput = {
    attribute_custom_name?: NullableStringFieldUpdateOperationsInput | string | null
    attribute_custom_value?: NullableStringFieldUpdateOperationsInput | string | null
    attribute_custom_unit?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    AreaOfWorks?: AreaOfWorksUpdateOneRequiredWithoutScopeOfWorksInput
    ProductAttributeUnits?: ProductAttributeUnitsUpdateOneRequiredWithoutScopeOfWorksInput
    ProductAttributeUnitValues?: ProductAttributeUnitValuesUpdateOneRequiredWithoutScopeOfWorksInput
  }

  export type ScopeOfWorksUncheckedUpdateWithoutProjectProposalsInput = {
    id?: IntFieldUpdateOperationsInput | number
    area_of_work_id?: IntFieldUpdateOperationsInput | number
    product_attribute_unit_id?: IntFieldUpdateOperationsInput | number
    product_attribute_unit_value_id?: IntFieldUpdateOperationsInput | number
    attribute_custom_name?: NullableStringFieldUpdateOperationsInput | string | null
    attribute_custom_value?: NullableStringFieldUpdateOperationsInput | string | null
    attribute_custom_unit?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProjectProposalsUpdateWithoutProjectsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    proposal_status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    AreaOfWorks?: AreaOfWorksUpdateManyWithoutProjectProposalsInput
    ScopeOfWorkPropertyUnits?: ScopeOfWorkPropertyUnitsUpdateManyWithoutProjectProposalsInput
    ScopeOfWorks?: ScopeOfWorksUpdateManyWithoutProjectProposalsInput
  }

  export type ProjectProposalsUncheckedUpdateWithoutProjectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    proposal_status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    AreaOfWorks?: AreaOfWorksUncheckedUpdateManyWithoutProjectProposalsInput
    ScopeOfWorkPropertyUnits?: ScopeOfWorkPropertyUnitsUncheckedUpdateManyWithoutProjectProposalsInput
    ScopeOfWorks?: ScopeOfWorksUncheckedUpdateManyWithoutProjectProposalsInput
  }

  export type ProjectProposalsUncheckedUpdateManyWithoutProjectProposalsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    proposal_status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProjectTypeAssociationsUpdateWithoutProjectsInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    ProjectTypes?: ProjectTypesUpdateOneRequiredWithoutProjectTypeAssociationsInput
  }

  export type ProjectTypeAssociationsUncheckedUpdateWithoutProjectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    project_type_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProjectTypeAssociationsUncheckedUpdateManyWithoutProjectTypeAssociationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    project_type_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProjectTypeAssociationsUpdateWithoutProjectTypesInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    Projects?: ProjectsUpdateOneRequiredWithoutProjectTypeAssociationsInput
  }

  export type ProjectTypeAssociationsUncheckedUpdateWithoutProjectTypesInput = {
    id?: IntFieldUpdateOperationsInput | number
    project_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UnitLocationsUpdateWithoutPropertyLevelsInput = {
    unit_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    PropertySubTypes?: PropertySubTypesUpdateOneRequiredWithoutUnitLocationsInput
    PropertyUnits?: PropertyUnitsUpdateOneRequiredWithoutUnitLocationsInput
    AreaOfWorks?: AreaOfWorksUpdateManyWithoutUnitLocationsInput
  }

  export type UnitLocationsUncheckedUpdateWithoutPropertyLevelsInput = {
    id?: IntFieldUpdateOperationsInput | number
    unit_name?: NullableStringFieldUpdateOperationsInput | string | null
    property_sub_type_id?: IntFieldUpdateOperationsInput | number
    property_unit_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    AreaOfWorks?: AreaOfWorksUncheckedUpdateManyWithoutUnitLocationsInput
  }

  export type UnitLocationsUncheckedUpdateManyWithoutUnitLocationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    unit_name?: NullableStringFieldUpdateOperationsInput | string | null
    property_sub_type_id?: IntFieldUpdateOperationsInput | number
    property_unit_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type Property_AddressesUpdateWithoutPropertyOwnersInput = {
    street?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    construction_type?: NullableStringFieldUpdateOperationsInput | string | null
    withBasement?: BoolFieldUpdateOperationsInput | boolean
    storyId?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    Cities?: CitiesUpdateOneRequiredWithoutProperty_AddressesInput
    PropertySubTypes?: PropertySubTypesUpdateOneRequiredWithoutProperty_AddressesInput
    Projects?: ProjectsUpdateManyWithoutProperty_AddressesInput
  }

  export type Property_AddressesUncheckedUpdateWithoutPropertyOwnersInput = {
    id?: IntFieldUpdateOperationsInput | number
    street?: NullableStringFieldUpdateOperationsInput | string | null
    city_id?: IntFieldUpdateOperationsInput | number
    property_sub_type_id?: IntFieldUpdateOperationsInput | number
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    construction_type?: NullableStringFieldUpdateOperationsInput | string | null
    withBasement?: BoolFieldUpdateOperationsInput | boolean
    storyId?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    Projects?: ProjectsUncheckedUpdateManyWithoutProperty_AddressesInput
  }

  export type Property_AddressesUpdateWithoutPropertySubTypesInput = {
    street?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    construction_type?: NullableStringFieldUpdateOperationsInput | string | null
    withBasement?: BoolFieldUpdateOperationsInput | boolean
    storyId?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    Cities?: CitiesUpdateOneRequiredWithoutProperty_AddressesInput
    PropertyOwners?: PropertyOwnersUpdateOneRequiredWithoutProperty_AddressesInput
    Projects?: ProjectsUpdateManyWithoutProperty_AddressesInput
  }

  export type Property_AddressesUncheckedUpdateWithoutPropertySubTypesInput = {
    id?: IntFieldUpdateOperationsInput | number
    street?: NullableStringFieldUpdateOperationsInput | string | null
    property_owner_id?: IntFieldUpdateOperationsInput | number
    city_id?: IntFieldUpdateOperationsInput | number
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    construction_type?: NullableStringFieldUpdateOperationsInput | string | null
    withBasement?: BoolFieldUpdateOperationsInput | boolean
    storyId?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    Projects?: ProjectsUncheckedUpdateManyWithoutProperty_AddressesInput
  }

  export type UnitLocationsUpdateWithoutPropertySubTypesInput = {
    unit_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    PropertyLevels?: PropertyLevelsUpdateOneRequiredWithoutUnitLocationsInput
    PropertyUnits?: PropertyUnitsUpdateOneRequiredWithoutUnitLocationsInput
    AreaOfWorks?: AreaOfWorksUpdateManyWithoutUnitLocationsInput
  }

  export type UnitLocationsUncheckedUpdateWithoutPropertySubTypesInput = {
    id?: IntFieldUpdateOperationsInput | number
    unit_name?: NullableStringFieldUpdateOperationsInput | string | null
    property_level_id?: IntFieldUpdateOperationsInput | number
    property_unit_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    AreaOfWorks?: AreaOfWorksUncheckedUpdateManyWithoutUnitLocationsInput
  }

  export type ScopeOfWorkPropertyUnitsUpdateWithoutPropertyUnitAttributesInput = {
    value?: NullableStringFieldUpdateOperationsInput | string | null
    attribute_custom_name?: NullableStringFieldUpdateOperationsInput | string | null
    attribute_custom_value?: NullableStringFieldUpdateOperationsInput | string | null
    attribute_custom_unit?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    AreaOfWorks?: AreaOfWorksUpdateOneRequiredWithoutScopeOfWorkPropertyUnitsInput
    ProjectProposals?: ProjectProposalsUpdateOneRequiredWithoutScopeOfWorkPropertyUnitsInput
  }

  export type ScopeOfWorkPropertyUnitsUncheckedUpdateWithoutPropertyUnitAttributesInput = {
    id?: IntFieldUpdateOperationsInput | number
    project_proposal_id?: IntFieldUpdateOperationsInput | number
    area_of_work_id?: IntFieldUpdateOperationsInput | number
    value?: NullableStringFieldUpdateOperationsInput | string | null
    attribute_custom_name?: NullableStringFieldUpdateOperationsInput | string | null
    attribute_custom_value?: NullableStringFieldUpdateOperationsInput | string | null
    attribute_custom_unit?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PropertyUnitProductCategoryProductsUpdateWithoutPropertyUnitProductCategoriesInput = {
    display_order?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    Products?: ProductsUpdateOneRequiredWithoutPropertyUnitProductCategoryProductsInput
  }

  export type PropertyUnitProductCategoryProductsUncheckedUpdateWithoutPropertyUnitProductCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    product_id?: IntFieldUpdateOperationsInput | number
    display_order?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProductPropertyUnitsUpdateWithoutPropertyUnitsInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    Products?: ProductsUpdateOneRequiredWithoutProductPropertyUnitsInput
  }

  export type ProductPropertyUnitsUncheckedUpdateWithoutPropertyUnitsInput = {
    id?: IntFieldUpdateOperationsInput | number
    product_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PropertyUnitAttributesUpdateWithoutPropertyUnitsInput = {
    html_element_type?: NullableStringFieldUpdateOperationsInput | string | null
    display_order?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    Attributes?: AttributesUpdateOneRequiredWithoutPropertyUnitAttributesInput
    AttributeUnits?: AttributeUnitsUpdateOneRequiredWithoutPropertyUnitAttributesInput
    ScopeOfWorkPropertyUnits?: ScopeOfWorkPropertyUnitsUpdateManyWithoutPropertyUnitAttributesInput
  }

  export type PropertyUnitAttributesUncheckedUpdateWithoutPropertyUnitsInput = {
    id?: IntFieldUpdateOperationsInput | number
    attribute_id?: IntFieldUpdateOperationsInput | number
    attribute_unit_id?: IntFieldUpdateOperationsInput | number
    html_element_type?: NullableStringFieldUpdateOperationsInput | string | null
    display_order?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    ScopeOfWorkPropertyUnits?: ScopeOfWorkPropertyUnitsUncheckedUpdateManyWithoutPropertyUnitAttributesInput
  }

  export type PropertyUnitProductCategoriesUpdateWithoutPropertyUnitsInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    ProductCategories?: ProductCategoriesUpdateOneRequiredWithoutPropertyUnitProductCategoriesInput
    PropertyUnitProductCategoryProducts?: PropertyUnitProductCategoryProductsUpdateManyWithoutPropertyUnitProductCategoriesInput
  }

  export type PropertyUnitProductCategoriesUncheckedUpdateWithoutPropertyUnitsInput = {
    id?: IntFieldUpdateOperationsInput | number
    product_category_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    PropertyUnitProductCategoryProducts?: PropertyUnitProductCategoryProductsUncheckedUpdateManyWithoutPropertyUnitProductCategoriesInput
  }

  export type UnitLocationsUpdateWithoutPropertyUnitsInput = {
    unit_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    PropertyLevels?: PropertyLevelsUpdateOneRequiredWithoutUnitLocationsInput
    PropertySubTypes?: PropertySubTypesUpdateOneRequiredWithoutUnitLocationsInput
    AreaOfWorks?: AreaOfWorksUpdateManyWithoutUnitLocationsInput
  }

  export type UnitLocationsUncheckedUpdateWithoutPropertyUnitsInput = {
    id?: IntFieldUpdateOperationsInput | number
    unit_name?: NullableStringFieldUpdateOperationsInput | string | null
    property_sub_type_id?: IntFieldUpdateOperationsInput | number
    property_level_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    AreaOfWorks?: AreaOfWorksUncheckedUpdateManyWithoutUnitLocationsInput
  }

  export type ProjectsUpdateWithoutProperty_AddressesInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    ProjectProposals?: ProjectProposalsUpdateManyWithoutProjectsInput
    ProjectTypeAssociations?: ProjectTypeAssociationsUpdateManyWithoutProjectsInput
  }

  export type ProjectsUncheckedUpdateWithoutProperty_AddressesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    ProjectProposals?: ProjectProposalsUncheckedUpdateManyWithoutProjectsInput
    ProjectTypeAssociations?: ProjectTypeAssociationsUncheckedUpdateManyWithoutProjectsInput
  }

  export type ProjectsUncheckedUpdateManyWithoutProjectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertySubTypesUpdateWithoutProperty_TypesInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    Property_Addresses?: Property_AddressesUpdateManyWithoutPropertySubTypesInput
    UnitLocations?: UnitLocationsUpdateManyWithoutPropertySubTypesInput
  }

  export type PropertySubTypesUncheckedUpdateWithoutProperty_TypesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    Property_Addresses?: Property_AddressesUncheckedUpdateManyWithoutPropertySubTypesInput
    UnitLocations?: UnitLocationsUncheckedUpdateManyWithoutPropertySubTypesInput
  }

  export type PropertySubTypesUncheckedUpdateManyWithoutPropertySubTypesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CitiesUpdateWithoutStatesInput = {
    name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    Property_Addresses?: Property_AddressesUpdateManyWithoutCitiesInput
  }

  export type CitiesUncheckedUpdateWithoutStatesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    Property_Addresses?: Property_AddressesUncheckedUpdateManyWithoutCitiesInput
  }

  export type CitiesUncheckedUpdateManyWithoutCitiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AreaOfWorksUpdateWithoutUnitLocationsInput = {
    new_unit?: NullableStringFieldUpdateOperationsInput | string | null
    existing_unit?: NullableStringFieldUpdateOperationsInput | string | null
    unit_alias?: NullableStringFieldUpdateOperationsInput | string | null
    work_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    ProjectProposals?: ProjectProposalsUpdateOneRequiredWithoutAreaOfWorksInput
    ScopeOfWorkPropertyUnits?: ScopeOfWorkPropertyUnitsUpdateManyWithoutAreaOfWorksInput
    ScopeOfWorks?: ScopeOfWorksUpdateManyWithoutAreaOfWorksInput
  }

  export type AreaOfWorksUncheckedUpdateWithoutUnitLocationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    project_proposal_id?: IntFieldUpdateOperationsInput | number
    new_unit?: NullableStringFieldUpdateOperationsInput | string | null
    existing_unit?: NullableStringFieldUpdateOperationsInput | string | null
    unit_alias?: NullableStringFieldUpdateOperationsInput | string | null
    work_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    ScopeOfWorkPropertyUnits?: ScopeOfWorkPropertyUnitsUncheckedUpdateManyWithoutAreaOfWorksInput
    ScopeOfWorks?: ScopeOfWorksUncheckedUpdateManyWithoutAreaOfWorksInput
  }

  export type Backend_UsersUpdateWithoutUsersInput = {
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type Backend_UsersUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type Backend_UsersUncheckedUpdateManyWithoutBackend_UsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ContractorsUpdateWithoutUsersInput = {
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ContractorsUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ContractorsUncheckedUpdateManyWithoutContractorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PropertyOwnersUpdateWithoutUsersInput = {
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    Property_Addresses?: Property_AddressesUpdateManyWithoutPropertyOwnersInput
  }

  export type PropertyOwnersUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    Property_Addresses?: Property_AddressesUncheckedUpdateManyWithoutPropertyOwnersInput
  }

  export type PropertyOwnersUncheckedUpdateManyWithoutPropertyOwnersInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.DMMF.Document;
}